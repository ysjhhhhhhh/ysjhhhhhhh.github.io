<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Netflix系列 | Gridea</title>
<meta name="description" content="温故而知新" />
<link rel="shortcut icon" href="https://ysjhhhhhhh.github.io/favicon.ico?v=1576150912235">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://ysjhhhhhhh.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://ysjhhhhhhh.github.io">
  <img class="avatar" src="https://ysjhhhhhhh.github.io/images/avatar.png?v=1576150912235" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Netflix系列
            </h2>
            <div class="post-info">
              <span>
                2018-06-19
              </span>
              <span>
                35 min read
              </span>
              
                <a href="https://ysjhhhhhhh.github.io/tag/QNP_cGyqV" class="post-tag">
                  # Gridea
                </a>
              
            </div>
            
              <img class="post-feature-image" src="data:image/png;base64,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" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>[TOC]</p>
<h1 id="netflix体系简介">Netflix体系简介</h1>
<p>Netflix这可是个大boss，地位仅次于老大，老大各项服务依赖与它，与各种Netflix OSS组件集成，组成微服务的核心，它的小弟主要有Eureka, Hystrix, Zuul, Archaius… 太多了</p>
<h2 id="核心成员">核心成员</h2>
<h3 id="netflix-eureka">Netflix Eureka</h3>
<p>服务中心，云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。这个可是springcloud最牛鼻的小弟，服务中心，任何小弟需要其它小弟支持什么都需要从这里来拿，同样的你有什么独门武功的都赶紧过报道，方便以后其它小弟来调用；它的好处是你不需要直接找各种什么小弟支持，只需要到服务中心来领取，也不需要知道提供支持的其它小弟在哪里，还是几个小弟来支持的，反正拿来用就行，服务中心来保证稳定性和质量。</p>
<h3 id="netflix-ribbon">Netflix Ribbon</h3>
<p>Ribbon是一个客户端负载均衡组件，帮我们实现后端服务节点动态扩容，而不影响调用方。</p>
<h3 id="netflix-hystrix">Netflix Hystrix</h3>
<p>熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。比如突然某个小弟生病了，但是你还需要它的支持，然后调用之后它半天没有响应，你却不知道，一直在等等这个响应；有可能别的小弟也正在调用你的武功绝技，那么当请求多之后，就会发生严重的阻塞影响老大的整体计划。这个时候Hystrix就派上用场了，当Hystrix发现某个小弟不在状态不稳定立马马上让它下线，让其它小弟来顶上来，或者给你说不用等了这个小弟今天肯定不行，该干嘛赶紧干嘛去别在这排队了。</p>
<h3 id="netflix-zuul">Netflix Zuul</h3>
<p>Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。当其它门派来找大哥办事的时候一定要先经过zuul,看下有没有带刀子什么的给拦截回去，或者是需要找那个小弟的直接给带过去。</p>
<h3 id="netflix-archaius">Netflix Archaius</h3>
<p>配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。可以实现动态获取配置， 原理是每隔60s（默认，可配置）从配置源读取一次内容，这样修改了配置文件后不需要重启服务就可以使修改后的内容生效，前提使用archaius的API来读取。</p>
<h1 id="eurekanetflix-服务发现与注册">Eureka(Netflix) - 服务发现与注册</h1>
<h2 id="eureka介绍">Eureka介绍</h2>
<blockquote>
<p>Eureka是xxx</p>
</blockquote>
<h2 id="eureka的使用方法">Eureka的使用方法</h2>
<p>Eureka分为服务端和客户端，Eureka Server负责集中管理所有注册上来的微服务,维护一个完整的服务列表，同时监控每个服务的状态（通过客户端定时renew），及时下线down掉的服务<br>
Eureka Client端负责上报服务、服务下线、拉取服务端的服务列表等功能。</p>
<h3 id="eureka-server端配置">Eureka Server端配置</h3>
<ol>
<li>添加依赖</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>properties配置</li>
</ol>
<pre><code class="language-yml">spring:
  application:
    name: eureka-server
  profiles:
    active: dev

security:
  basic:
    enabled: true
  user:
    name: lisi
    password: 123

eureka:
  instance:
    prefer-ip-address: true #在某些情况下，Eureka优先使用IP地址而不是主机名。设置为true，当应用程序向eureka注册时，它将使用其IP地址而不是其主机名
    #instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
  client:
    registerWithEureka: true
    fetchRegistry: true

---
spring:
  profiles: dev
server:
  port: 8781
eureka:
  instance:
    hostname: peer1
    lease-renewal-interval-in-seconds: 30   #eureka client续租的超时时长
  client:
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
    register-with-eureka: false  #单机模式：禁止向别的eureka server注册自己
    fetch-registry: false #单机模式：禁止从别的eureka server获取服务列表

security:
  basic:
    enabled: false
---
spring:
  profiles: peer1
server:
  port: 8781
eureka:
  instance:
    hostname: peer1
  client:
    service-url:
      defaultZone: http://${security.user.name}:${security.user.password}@peer2:8782/eureka/,http://${security.user.name}:${security.user.password}@peer3:8783/eureka/
security:
  basic:
    enabled: true


---
spring:
  profiles: peer2
server:
  port: 8782
eureka:
  instance:
    hostname: peer2
  client:
    service-url:
      defaultZone: http://${security.user.name}:${security.user.password}@peer1:8781/eureka/,http://${security.user.name}:${security.user.password}@peer3:8783/eureka/

---
spring:
  profiles: peer3
server:
  port: 8783
eureka:
  instance:
    hostname: peer3
  client:
    service-url:
      defaultZone: http://${security.user.name}:${security.user.password}@peer1:8781/eureka/,http://${security.user.name}:${security.user.password}@peer2:8782/eureka/
</code></pre>
<ol start="3">
<li>开启应用的Eureka Server功能<br>
在应用启动类上加 @EnableEurekaServer注解</li>
</ol>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaServer
public class EurekaApplication
{
    public static void main( String[] args )
    {
        SpringApplication.run(EurekaApplication.class, args);
    }
}
</code></pre>
<h3 id="eureka-client端">Eureka Client端</h3>
<ol>
<li>添加依赖</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>客户端配置</li>
</ol>
<pre><code class="language-yml">eureka:
  client:
    serviceUrl:
#      defaultZone: http://lisi:123@peer1:8781/eureka/
      defaultZone: http://peer1:8781/eureka/
  instance:
    prefer-ip-address: true #在某些情况下，Eureka优先使用IP地址而不是主机名。设置为true，当应用程序向eureka注册时，它将使用其IP地址而不是其主机名
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
</code></pre>
<ol start="3">
<li>开启应用的Eureka Client功能<br>
在应用启动类上加 @EnableEurekaClient或者@EnableDiscoveryClient注解</li>
</ol>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaClient
// @EnableDiscoveryClient  //与EnableEurekaClient二选一
public class ClientApplicationStart {
    public static void main(String[] args) {
        new SpringApplicationBuilder(ClientApplicationStart.class).web(true).run(args);
    }
}
</code></pre>
<h2 id="eureka的保护模式">Eureka的保护模式</h2>
<p>在使用Eureka作为服务注册中心时，有时控制台的网页上会出现红色的警告：<br>
EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</p>
<p>出现此问题的原因是要从Eureka服务注册中心的原理说起， 所有注册到Eureka中的微服务与Eureka Server之间一直保持着一个心跳连接， 当Eureka Server这边收不到某个微服务（其实就是Eureka Client）的心跳连接时，有可能有两种情况： 1. 微服务真的挂了； 2. Eureka Server与微服务(Eureka Client)之间的网络中断，但微服务本身并没有挂。</p>
<p>默认情况下，如果Eureka Server在一定时间内没有接收到某个微服务实例的心跳，Eureka Server将会注销该实例（默认90秒）。但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，这就可能变得非常危险了----因为微服务本身是健康的，此时本不应该注销这个微服务。</p>
<p>Eureka Server通过“自我保护模式”来解决这个问题----当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。</p>
<p>自我保护模式是一种对网络异常的安全保护措施。使用自我保护模式，而已让Eureka集群更加的健壮、稳定。</p>
<p>如果不想看到这个警告，我们也可以通过下面的配置显式关闭保护模式（生产环境不建议关掉）：</p>
<pre><code class="language-properties"># 关闭Eureka Server保护模式
eureka.server.enable-self-preservation=false
</code></pre>
<h1 id="ribbionnetflix-客户端负载均衡">Ribbion(Netflix) - 客户端负载均衡</h1>
<h2 id="ribbon介绍">Ribbon介绍</h2>
<p>Ribbon是一个客户端负载均衡组件，帮我们实现后端服务节点动态扩容，而不影响调用方。</p>
<h2 id="ribbon的使用方法">Ribbon的使用方法</h2>
<p>Eureka和Feign中已经默认集成了Ribbon，如果项目中引入了Eureka，通过在RestTemplate上添加@LoadBalanced；如果用的是Feign声明式REST客户端，feign默认就已经帮我们开启了ribbon负载均衡能力。</p>
<h2 id="ribbon的配置">Ribbon的配置</h2>
<h3 id="通过代码修改ribbon全局配置">通过代码修改ribbon全局配置</h3>
<ol>
<li>创建Ribbon配置类</li>
</ol>
<pre><code class="language-java">/**
 * 通过注解的方式自定义ribbon策略
 * 可自定义的属性参见：https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/2.0.2.RELEASE/single/spring-cloud-netflix.html#_customizing_the_ribbon_client
 * 注意：此配置不可放置到ComponentScan可以扫描到的位置（一般来说可以放到Application启动类的上层包中），否则就会全局生效
 */
@Configuration  //官方文档说配置类必须加上此注解，但本人测试不加也可以，建议最好还是按官方要求加上
public class RibbonConfiguration {
    @Bean
    public IRule ribbonRule() {
        return new RoundRobinRule();
    }
}
</code></pre>
<ol start="2">
<li>在Spring @Configuration类中引用配置，并加上@RibbonClients注解引用上面定义的配置</li>
</ol>
<pre><code class="language-java">/**
 * 用用全局配置
 * @author: john
 * @create: 2018-12-14 20:37:14
 */
@Configuration
@RibbonClients(defaultConfiguration = RibbonConfiguration.class)    //配置ribbon全局策略
public class ApplicationConfiguration {
}
</code></pre>
<h3 id="通过代码修改指定微服务的ribbon配置">通过代码修改指定微服务的ribbon配置</h3>
<ol>
<li>创建Robbon配置类</li>
</ol>
<blockquote>
<p>见1.1中创建的Ribbon配置类</p>
</blockquote>
<ol start="2">
<li>在Spring @Configuration类中引用配置，并且加上@RibbonClient注解</li>
</ol>
<pre><code class="language-java">/**
 * @className: PrintServiceConfiguration
 * @description: 通过注解的方式自定义指定service的ribbon配置
 * @author: john
 * @create: 2018-12-14 20:29:19
 */
@Configuration
@RibbonClient(name = &quot;MICROSERVER-PRINT&quot;, configuration = RibbonConfiguration.class) //name对应微服务名称
public class PrintServiceConfiguration {
}

</code></pre>
<h3 id="属性文件全局配置">属性文件全局配置</h3>
<pre><code>官方文档中没有找到，应该是不支持
</code></pre>
<h3 id="属性文件特定配置">属性文件特定配置</h3>
<pre><code>&lt;clientName&gt;.ribbon.xxx，支持的属性如下：
- NFLoadBalancerClassName: should implement ILoadBalancer
- NFLoadBalancerRuleClassName: should implement IRule
- NFLoadBalancerPingClassName: should implement IPing
- NIWSServerListClassName: should implement ServerList
- NIWSServerListFilterClassName should implement ServerListFilter

例如：
```yml
microserver-print:
    ribbon:
        NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #设置ribbon访问microserver-print这个微服务的负载均衡Rule
```
</code></pre>
<h2 id="ribbon与eureka配合使用">Ribbon与Eureka配合使用</h2>
<p>Eureka中已经默认集成了Ribbon，所以当我们引入Eureka后，不需要额外做什么操作只要在ResultTemplate的Bean配置上加上@LoadBalanced（或者和Feign一起使用，feign也集成了ribbon）。</p>
<pre><code class="language-java">@Configuration
public class ApplicationConfiguration {
    @Bean
    @LoadBalanced
    public RestTemplate setRestTemplate() {
        return new RestTemplate();
    }
}

// 使用RestTemplate通过服务ID调用服务，http://{serviceId}/path
@RequestMapping(&quot;/name/{name}&quot;)
public String nameHello(@PathVariable String name, Model model) {
    String result = restTemplate.getForObject(&quot;http://hello-server/name/&quot;+name, String.class);
    model.addAttribute(&quot;msg&quot;, result);
    return &quot;index&quot;;
}

</code></pre>
<blockquote>
<p>当Ribbon与Eureka一起使用时，Eureka会修改Ribbon以下几个全局配置：</p>
<ul>
<li>ribbonServerList被设置为：DiscoveryEnabledNIWSServerList的扩展DomainExtractingServerList</li>
<li>IPing被设置为：NIWSDiscoveryPing</li>
</ul>
</blockquote>
<h2 id="ribbon脱离eureka单独使用">Ribbon脱离Eureka单独使用</h2>
<p>Ribbon本身并不依赖Eureka，完全可以单独作为客户端负载均衡使用。用法如下：<br>
在yml文件中做如下配置：</p>
<pre><code class="language-yml"># 测试use ribbon without eureka, must set ribbon.eureka.enabled=false
print:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
    listOfServers: localhost:8001,localhost:8002

ribbon:
  eureka:
    enabled: false  #如果项目引入了Eureka，必须设置关闭在eureka中使用ribbon

</code></pre>
<p>然后通过以下两种方式使用ribbon：</p>
<ol>
<li>在RestTemplate配置Bean上添加@LoadBalanced注解。访问http://print/rest/print/ 就会开启ribbon的负载均衡能力</li>
<li>直接通过ribbon提供的API使用</li>
</ol>
<pre><code class="language-java">public class MyClass {
    @Autowired
    private LoadBalancerClient loadBalancer;

    public void doStuff() {
        ServiceInstance instance = loadBalancer.choose(&quot;print&quot;);
        URI storesUri = URI.create(String.format(&quot;http://%s:%s&quot;, instance.getHost(), instance.getPort()));
        // ... do something with the URI
    }
}
</code></pre>
<h1 id="hystrixnetflix-服务熔断-降级-限流-隔离">Hystrix(Netflix) - 服务熔断、降级、限流、隔离</h1>
<h2 id="hystrix介绍">Hystrix介绍</h2>
<blockquote>
<p>在分布式环境中，许多服务依赖项中的一些不可避免地会失败。<br>
Hystrix是一个库，可通过添加延迟容错和容错逻辑来帮助您控制这些分布式服务之间的交互。<br>
Hystrix通过隔离服务之间的访问点，阻止它们之间的级联故障以及提供后备选项来实现这一目标，这些都可以提高系统的整体恢复能力</p>
</blockquote>
<blockquote>
<p>通俗的说Hystrix是Netflix公司开源的一个用于服务调用的断路器组件，给我们提供了包括服务熔断、降级、超时、资源隔离在内的完整解决方案。</p>
</blockquote>
<h2 id="hystrix的用法">Hystrix的用法</h2>
<p>Hystrix已经集成到了Feign中，可以和feign无缝对接。 如果没有引入Feign，我们也可以通过引入Hystrix相关依赖，通过HystrixCommand对指定的请求包裹Hystrix熔断功能。</p>
<h3 id="hystrix和feign一起使用">Hystrix和Feign一起使用</h3>
<blockquote>
<p>参见Feign章节中的《Feign与Hystrix集成》部分</p>
</blockquote>
<h3 id="hystrix与resttemplate一起使用">Hystrix与RestTemplate一起使用</h3>
<ol>
<li>引入Hystrix依赖包</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>在Application启动类中开启Hystrix熔断</li>
<li>在SpringMVC Controller的请求方法上添加 @HystrixCommand注解</li>
</ol>
<pre><code class="language-java">/**
 * commandKey用于在Properties文件中配置此Command的参数，也可以直接用注解在这里配置参数
 * fallbackMethod指定服务降级时调用的方法
 */
@HystrixCommand(fallbackMethod = &quot;addFallback&quot;,commandKey = &quot;addFallbackCommandKey&quot;)    
@GetMapping(&quot;/add/{num1}_{num2}&quot;)
public Map&lt;String, Object&gt; add(@PathVariable int num1, @PathVariable int num2) {
    Map&lt;String, Object&gt; result = restTemplate.getForObject(calcServerUrl+&quot;add/&quot;+num1+&quot;_&quot;+num2, Map.class);
    return result;
}
</code></pre>
<h2 id="hystrix的配置">Hystrix的配置</h2>
<p>和Netflix Ribbon组件类似，Hystrix的所有配置参数也分四个级别：</p>
<ol>
<li>Global default from code（代码中全局默认）</li>
<li>Dynamic global default property （properties文件全局配置）</li>
<li>Instance default from code（代码中修改指定实例的参数）</li>
<li>Dynamic instance property (通过properteis文件修改指定实例的参数)</li>
</ol>
<p>以上四种方式的配置优先级依次升高，下面我们来依次介绍这四种方式的配置方法</p>
<h3 id="hystrix代码全局默认参数">Hystrix代码全局默认参数</h3>
<p>指的是Hystrix源码中设置的默认参数，我们可以在Properties文件中通过将CommandKey指向&quot;default&quot;，修改大部分全局默认参数。</p>
<h3 id="通过代码修改指定hystrixcommand参数">通过代码修改指定HystrixCommand参数</h3>
<h4 id="通过javanica的方式修改单个方法的hystrix参数推荐">通过javanica的方式修改单个方法的Hystrix参数（推荐）</h4>
<p>直接配置方法上的@HystrixCommand注解参数即可，如</p>
<pre><code class="language-java">@HystrixCommand(
        fallbackMethod = &quot;addFallback&quot;, commandKey = &quot;calc-add-command&quot;,
        groupKey = &quot;calc-command-group&quot;, threadPoolKey = &quot;calc-add-command-pool&quot;,
        commandProperties = {
                @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;1500&quot;),
                @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;3&quot;),
                @HystrixProperty(name = &quot;metrics.rollingStats.timeInMilliseconds&quot;, value = &quot;10000&quot;),
                @HystrixProperty(name = &quot;metrics.rollingPercentile.enabled&quot;, value = &quot;false&quot;)
        },
        threadPoolProperties = {
                @HystrixProperty(name = &quot;coreSize&quot;, value = &quot;10&quot;),
                @HystrixProperty(name = &quot;queueSizeRejectionThreshold&quot;, value = &quot;9&quot;)
        }
)
@GetMapping(&quot;/add/{num1}_{num2}&quot;)
public Map&lt;String, Object&gt; add(@ApiParam @PathVariable int num1, @ApiParam @PathVariable int num2) {
    log.info(&quot;request calc.add, params: &quot; + num1 + &quot;,&quot; + num2);
    Map&lt;String, Object&gt; result = restTemplate.getForObject(calcServerUrl + &quot;add/&quot; + num1 + &quot;_&quot; + num2, Map.class);
    return result;
}

</code></pre>
<p>注：如果不配threadPoolKey的话，默认会取groupKey得值。相同threadPoolKey会共享同一个线程池的资源</p>
<h4 id="通过javanica的方式修改多个方法的hystrix参数">通过javanica的方式修改多个方法的Hystrix参数</h4>
<p>通过在类上面添加 @DefaultProperteis注解，可以修改此类中所有用@HystrixCommand注解的方法的默认Hystrix参数</p>
<pre><code class="language-java">@DefaultProperties(groupKey = &quot;DefaultGroupKey&quot;)
class Service {
    @HystrixCommand // hystrix command group key is 'DefaultGroupKey'
    public Object commandInheritsDefaultProperties() {
        return null;
    }
    @HystrixCommand(groupKey = &quot;SpecificGroupKey&quot;) // command overrides default group key
    public Object commandOverridesGroupKey() {
        return null;
    }
}
</code></pre>
<h4 id="通过自定义command类的方式包裹请求方法不推荐实际写起来太复杂">通过自定义Command类的方式包裹请求方法（不推荐，实际写起来太复杂）</h4>
<pre><code class="language-java">public class CommandHelloWorld extends HystrixCommand&lt;String&gt; {

    private final String name;

    static HystrixCommand.Setter commandSetter;

    static {
        HystrixCommandProperties.Setter commandPropertiesSetter = HystrixCommandProperties.Setter()
                .withExecutionIsolationSemaphoreMaxConcurrentRequests(20)   //最大并发请求数
                .withExecutionTimeoutInMilliseconds(1500)   //请求超过1.5秒执行降级逻辑
                .withCircuitBreakerRequestVolumeThreshold(3)    //在一个统计窗口期内，请求失败3次熔断
                .withCircuitBreakerSleepWindowInMilliseconds(2000)  //开启熔断后多久进入半熔断状态，断路器根据下一次的执行结果决定是否继续开启熔断
                .withMetricsRollingStatisticalWindowInMilliseconds(10000)   //10秒内如果大于等于3个错误请求就开启熔断
                .withMetricsRollingPercentileEnabled(false);    //关闭以错误请求百分比为度量指标的逻辑，仅按一个统计时间窗口内错误请求次数计算(主要是方便演示)

        HystrixThreadPoolProperties.Setter threadPoolPropertiesSetter = HystrixThreadPoolProperties.Setter()
                .withCoreSize(10)
                .withMaxQueueSize(10);

        commandSetter = HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;defalt-hystrix-group&quot;))
                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;default-hystrix-threadpool&quot;))
                .andCommandKey(HystrixCommandKey.Factory.asKey(&quot;default&quot;))
                .andCommandPropertiesDefaults(commandPropertiesSetter)
                .andThreadPoolPropertiesDefaults(threadPoolPropertiesSetter)
                ;
    }

    public CommandHelloWorld(String name) {
        super(commandSetter);
        this.name = name;
    }

    @Override
    protected String run() {
        // a real example would do work like a network call here
        return &quot;Hello &quot; + this.name;
    }
}

//调用
String s = new CommandHelloWorld(&quot;World&quot;).execute();
</code></pre>
<p>这种方式一般一个请求就得写一个自定义HystrixCommand，太复杂。当然也可以封装一个通用的CommonHystrixCommand，将业务逻辑抽象后传进来调用。不过一般工作中不会这么写，因为通过Properties配置文件或者javanica的方式会方便很多</p>
<pre><code class="language-java">// 这是一个利用Callable把业务方法和降级方法都传进来的例子，只是提供思路，当然还有其他更好的方式也是可以的
public static class DefaultHystrixCommand&lt;E&gt; extends HystrixCommand&lt;E&gt; {

        static HystrixCommand.Setter commandSetter;

        private Callable&lt;E&gt; callable;
        private Callable&lt;E&gt; fallBackCallable;

        static {
            HystrixCommandProperties.Setter commandPropertiesSetter = HystrixCommandProperties.Setter()
                    .withExecutionIsolationSemaphoreMaxConcurrentRequests(20)   //最大并发请求数
                    .withExecutionTimeoutInMilliseconds(5000)   //请求超过1.5秒执行降级逻辑
                    .withCircuitBreakerRequestVolumeThreshold(20)    //在一个统计窗口期内，请求失败3次熔断
                    .withCircuitBreakerSleepWindowInMilliseconds(2000)  //开启熔断后多久进入半熔断状态，断路器根据下一次的执行结果决定是否继续开启熔断
                    .withMetricsRollingStatisticalWindowInMilliseconds(10000)   //10秒内如果大于等于3个错误请求就开启熔断
                    .withMetricsRollingPercentileEnabled(false);    //关闭以错误请求百分比为度量指标的逻辑，仅按一个统计时间窗口内错误请求次数计算(主要是方便演示)

            HystrixThreadPoolProperties.Setter threadPoolPropertiesSetter = HystrixThreadPoolProperties.Setter()
                    .withCoreSize(10)
                    .withMaxQueueSize(8)
                    .withQueueSizeRejectionThreshold(4);

            commandSetter = HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;defalt-hystrix-group&quot;))
                    .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;default-hystrix-threadpool&quot;))
                    .andCommandKey(HystrixCommandKey.Factory.asKey(&quot;default&quot;))
                    .andCommandPropertiesDefaults(commandPropertiesSetter)
                    .andThreadPoolPropertiesDefaults(threadPoolPropertiesSetter)
            ;
        }
        public DefaultHystrixCommand(Callable callable, Callable fallbackCallable) {
            super(commandSetter);
            this.callable = callable;
            this.fallBackCallable = fallbackCallable;
        }

        @Override
        protected E run() throws Exception {
            return this.callable.call();
        }

        @Override
        protected E getFallback(){
            try {
                return this.fallBackCallable.call();
            } catch (Exception e) {
                throw new RuntimeException(&quot;执行降级方法失败&quot;, e);
            }
        }
    }
</code></pre>
<h3 id="通过代码修改feignclient的hystrix参数配置">通过代码修改FeignClient的Hystrix参数配置</h3>
<ol>
<li>定义配置类</li>
</ol>
<pre><code class="language-java">@Configuration
public class DefaultFeignWithHystrixConfiguration {
    //这个是修改feign的请求超时时间，和Hystrix参数无关
    @Bean
    public Request.Options requestOptions() {
        return new Request.Options(1500, 1500);
    }

    @Bean
    public HystrixFeign.Builder feignBuilder() {
        return HystrixFeign.builder().setterFactory((target, method) -&gt; {
            HystrixCommandProperties.Setter commandPropertiesSetter = HystrixCommandProperties.Setter()
//                    .withExecutionIsolationSemaphoreMaxConcurrentRequests(20)   //最大并发请求数
                    .withExecutionTimeoutInMilliseconds(7000)   //请求超过1.5秒执行降级逻辑
                    .withCircuitBreakerRequestVolumeThreshold(20)    //在一个统计窗口期内，请求失败3次熔断
                    .withCircuitBreakerSleepWindowInMilliseconds(2000)  //开启熔断后多久进入半熔断状态，断路器根据下一次的执行结果决定是否继续开启熔断
                    .withMetricsRollingStatisticalWindowInMilliseconds(10000)   //10秒内如果大于等于3个错误请求就开启熔断
                    .withMetricsRollingPercentileEnabled(false);    //关闭以错误请求百分比为度量指标的逻辑，仅按一个统计时间窗口内错误请求次数计算(主要是方便演示)

            HystrixThreadPoolProperties.Setter threadPoolPropertiesSetter = HystrixThreadPoolProperties.Setter()
                    .withCoreSize(10)
                    .withMaxQueueSize(8)
                    .withQueueSizeRejectionThreshold(4);

//            String groupKey = target.name();
//            String commandKey = Feign.configKey(target.type(), method);
            String groupKey = &quot;default&quot;;
            String commandKey = &quot;default&quot;;
            return HystrixCommand.Setter
                    .withGroupKey(HystrixCommandGroupKey.Factory.asKey(groupKey))
                    .andCommandKey(HystrixCommandKey.Factory.asKey(commandKey))
                    .andCommandPropertiesDefaults(commandPropertiesSetter)
                    .andThreadPoolPropertiesDefaults(threadPoolPropertiesSetter);
        });
    }
}
</code></pre>
<p><font color="red">上面的配置类也不能放到@ComponentScan能扫描到的路径下，否则就会覆盖所有FeignClient的默认配置。</font></p>
<ol start="2">
<li>在需要的FeignClient上通过注解引用此配置就可以了</li>
</ol>
<pre><code class="language-java">@FeignClient(value = &quot;MICROSERVER-CALC&quot;, fallback = CalcServiceFallback.class, configuration = DefaultFeignWithHystrixConfiguration.class)
public interface CalcService {
}
</code></pre>
<h3 id="通过properties修改指定hystrixcommand的参数">通过Properties修改指定HystrixCommand的参数</h3>
<pre><code class="language-yml">hystrix:
  command:
    hystrixCommandName (如：calc_add_command):  #对应@HystrixCommand注解的commandKey属性，指定特定熔断器的属性(一般建议在代码中通过注解配置)，此处换成default可修改全局属性。
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 5000 #设置熔断器判定超时的时间，超过此时间的请求会执行降级逻辑，默认1s
      circuitBreaker:
        requestVolumeThreshold: 2 #设置熔断阈值，在熔断统计窗口期内，错误请求（超时、异常）次数达到阈值就会触发熔断，执行降级逻辑，默认20
        sleepWindowInMilliseconds: 10000  #设置熔断器多久进入半开状态，然后再次尝试确定熔断器是否应再次关闭，默认5s
        errorThresholdPercentage: 50  #设置在熔断统计窗口期内，错误请求达到百分之多少触发熔断，默认50
      metrics:
        rollingStats:
          timeInMilliseconds: 5000 #熔断度量窗口期时间， 默认10s
</code></pre>
<h3 id="通过properties修改hystrix全局默认参数">通过Properties修改Hystrix全局默认参数</h3>
<p>修改指定HystrixCommand的参数，将上面参数中command的名称calc_add_command换成default即可</p>
<h3 id="在properties中修改feignclient的hystrix参数">在Properties中修改FeignClient的Hystrix参数</h3>
<p>如果是修改某个FeignClient的hystrix参数，将上面参数中command的名称修改为FeignClient接口的simpleName.methodName(参数表)，中间不能有空格，例如：CalcServer#add(int,int)</p>
<p>参见 <a href="https://blog.csdn.net/xiao_jun_0820/article/details/78174502">源码资料</a></p>
<h3 id="常用配置项">常用配置项</h3>
<p>更多配置项请参见：<a href="https://github.com/Netflix/Hystrix/wiki/Configuration">Hystrix官方wiki</a></p>
<h4 id="关于queuesizerejectionthreshold与maxqueuesize">关于queueSizeRejectionThreshold与maxQueueSize</h4>
<p>官方的说法是maxQueueSize设置的是BlockingQueue的size，由于此size不能动态调整，所以maxQueueSize只能启动时加载，加载后无法动态调整。为了解决这个问题，官方提供了queueSizeRejectionThreshold参数，相当于人为的制造了一个“maxQueueSize”，当队列中达到此值后，再进来的新请求会直接reject，即使还没达到Queue的maxSize。</p>
<h2 id="hystrix-metrics-stream">Hystrix Metrics Stream</h2>
<blockquote>
<p>Hystrix Metrics Stream用于通过流式数据的方式输出Hystrix使用过程中产生的各项指标，可通过Hystrix Dashboard查看。</p>
</blockquote>
<h3 id="配置方法">配置方法</h3>
<ol>
<li>引入Hystrix完整依赖</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>在Application启动类上开启Hystrix功能</li>
</ol>
<pre><code class="language-java">@SpringBootApplication
@EnableCircuitBreaker   //注意，要用metrics stream功能必须通过此注解显示打开断路器功能
public class ClientApplicationStart {
    public static void main(String[] args) {
        new SpringApplicationBuilder(ClientApplicationStart.class).web(true).run(args);
    }
}
</code></pre>
<p>通过浏览器访问： http://host:port/hystrix.stream 就可以看到Hystrix实时输出的流式JSON数据，将此地址配置到Hystrix Dashboard中就可以查看</p>
<p>注：Hystrix Metrics Stream必须配合SpringBoot Actuator一起使用</p>
<h2 id="hystrix的监控-hystrix-dashboard">Hystrix的监控 - Hystrix Dashboard</h2>
<blockquote>
<p>参见 <a href="#hystrix-dashboard">Hystrix Dashboard章节</a></p>
</blockquote>
<h1 id="zuulnetflix-统一网关-地址路由">Zuul(Netflix) - 统一网关、地址路由</h1>
<h2 id="zuul介绍">Zuul介绍</h2>
<blockquote>
<p>Zuul是Netflx开源的微服务网关。可以和Eureka、Ribbon、Hystrix配合使用，一个主要的功能就是可以将后端众多的微服务屏蔽、整合，对前端提供一套统一的服务(有点像是后端的Facade)。</p>
</blockquote>
<p>Zuul提供了以下几项支持：</p>
<ul>
<li>认证安全: 识别每一个资源的验证要求，并拒绝那些不符的请求</li>
<li>监控</li>
<li>动态路由: 动态将请求路由到不同后端集群</li>
<li>压力测试: 逐渐增加指向集群的流量，以了解性能</li>
<li>金丝雀测试: 灰度发布</li>
<li>流量控制: 为每一种负载类型分配对应容量，并弃用超出限定值的请求</li>
<li>服务迁移</li>
<li>静态资源响应处理: 边缘位置进行响应，避免转发到内部集群</li>
</ul>
<h2 id="zuul的用法">Zuul的用法</h2>
<ol>
<li>引入依赖包</li>
</ol>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- eureka依赖是可选的，取决于是否需要代理接入eureka注册中心的服务 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ol start="2">
<li>在Application启动类添加注解</li>
</ol>
<ul>
<li>Server模式</li>
</ul>
<pre><code class="language-java">@SpringBootApplication
@EnableZuulServer
public class GatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(GatewayApplication.class, args);
    }
}
</code></pre>
<p>Server模式会关闭所有的代理相关功能</p>
<ul>
<li>Reverse Proxy模式</li>
</ul>
<pre><code class="language-java">@SpringBootApplication
@EnableZuulProxy
public class GatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(GatewayApplication.class, args);
    }
}
</code></pre>
<h3 id="动态路由需要在reverse-proxy模式下">动态路由(需要在Reverse Proxy模式下)</h3>
<h4 id="通过服务名代理">通过服务名代理</h4>
<pre><code class="language-yml">zuul:
  routes:
    microserver-calc: /calcs-direct/**  #直接通过服务名配置代理（必须是有效的服务名），所有访问/mi
</code></pre>
<h4 id="serviceidpath的方式">ServiceId+Path的方式</h4>
<pre><code class="language-yml">zuul:
  routes:
    calc-service: #通过path+serviceId的方式，这种适合配置参数比较多的情况（route的名字可以任意）
      path: /calcs/**  #匹配访问地址，访问地址如果可以匹配，则自动代理到对应的微服务
      serviceId: microserver-calc   #必须是有效的微服务名称
</code></pre>
<h4 id="忽略代理指定服务">忽略代理指定服务</h4>
<pre><code class="language-yml">zuul:
  routes:
    microserver-calc: /calcs-direct/** 
  ignored-services: '*' #除了显示配置到路由规则里的服务外（如：microserver-calc），不代理其他任务服务(也可以配置多个服务名:service1,service2)
  ignoredPatterns: /**/admin/** #更细粒度的忽略配置
  
</code></pre>
<h4 id="代理未接入服务注册中心的服务">代理未接入服务注册中心的服务</h4>
<pre><code class="language-yml">zuul:
  routes:
    service-calc:
      path: /calcs/**
      serviceId: service-calc-ribbon  #通过ribbon配置一个静态服务列表的service，用于代理为接入Eureka的服务
      
#ribbon:
#  eureka:
#    enabled: false

service-calc-ribbon:
  ribbon:
    NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList  #如果不配置ServerList类型为ConfigurationBasedServerList的话就需要禁用ribbon的eureka支持
    ConnectTimeout: 500
    ReadTimeout: 2000
    listOfServers: http://localhost:8101,http://localhost:8102
</code></pre>
<h4 id="测过正则配置代理规则">测过正则配置代理规则</h4>
<pre><code class="language-java">// 从符合servicePattern的服务名中抽取出符合条件的内容，注入到路由模式中。
// 下面的配置可以将服务&quot;myusers-v1&quot;映射成&quot;/myusers/v1/**&quot;
@Bean
public PatternServiceRouteMapper serviceRouteMapper() {
    return new PatternServiceRouteMapper(&quot;(?&lt;name&gt;^.+)-(?&lt;version&gt;v.+$)&quot;,
            &quot;${name}/${version}&quot;);
}
</code></pre>
<p><font color="red">注：这种只针对注册到服务中心的服务生效</font></p>
<h4 id="添加全局访问前缀">添加全局访问前缀</h4>
<pre><code class="language-yml">server:
  port: 8080

zuul:
  routes:
    microserver-calc: /calcs/**  
  prefix: /api
  strip-prefix: true  #默认就是true
</code></pre>
<ul>
<li>当strip-prefix设置为true时<br>
访问：http://localhost:8080/api/calcs/**<br>
会被映射到微服务：microserver-calc/**</li>
<li>当strip-prefix设置为false时<br>
访问：http://localhost:8080/api/calcs/**<br>
会被映射到微服务：microserver-calc/api/**</li>
</ul>
<h4 id="给指定服务添加前缀">给指定服务添加前缀</h4>
<pre><code class="language-yml">server:
  port: 8080

zuul:
  routes:
    microserver-calc: #给指定服务配置前缀(这里的服务名称必须是真实的服务名，eureka或者手动用ribbon配置的名称) 
      path: /calc/**  #指定访问microserver-calc服务的前缀是/calc
      strip-prefix: false
</code></pre>
<h4 id="本地转发forward">本地转发(forward)</h4>
<pre><code class="language-yml">zuul:
  routes:
    route-name:
      path: /path-a/**
      url: forward:/path-b
</code></pre>
<h4 id="路由规则先后顺序">路由规则先后顺序</h4>
<pre><code class="language-yml">zuul:
  routes:
    users:
      path: /myusers/**
    legacy:
      path: /**
</code></pre>
<p>上面的配置如果用的是yml格式配置文件，如果访问/myusers/**会优先命中users服务；但是如果用properties文件，则可能导致无法路由到users服务</p>
<h3 id="聚合多个后端微服务提供统一api给前端">聚合多个后端微服务提供统一API给前端</h3>
<p>其实很简单，就是在Zuul层封装后端的多个请求，组合结果后返回给终端</p>
<pre><code class="language-java">@RestController
public class AggregationController {
  public static final Logger LOGGER = LoggerFactory.getLogger(ZuulApplication.class);

  @Autowired
  private RestTemplate restTemplate;
	
  @GetMapping(&quot;/aggregate/{id}&quot;)
  public Map&lt;String, User&gt; findById(@PathVariable Long id) throws Exception {
	  Map&lt;String, User&gt; dataMap = new HashMap&lt;&gt;();
	  User user = restTemplate.getForObject(&quot;http://microservice-provider-user/&quot; + id, User.class);
	  User orderUser = restTemplate.getForObject(&quot;http://microservice-consumer-order/user/&quot; + id, User.class);
	  dataMap.put(&quot;user&quot;, user);
	  dataMap.put(&quot;orderUser&quot;, orderUser);
	  return dataMap;
  }
}
</code></pre>
<h3 id="zuul的访问超时控制">Zuul的访问超时控制</h3>
<h4 id="通过serviceid代理的请求">通过ServiceId代理的请求</h4>
<p>由于通过ServiceId的方式代理的请求(包括手动配置的Ribbon 服务和自动服务发现的服务)会走Ribbon和Hystrix，所以我们要控制超时就包括Ribbon请求的超时和Hystrix的访问超时。</p>
<pre><code class="language-yml">test-service:
  ribbon:
    ReadTimeout:100
    ConnectTimeout:500
    MaxAutoRetries:1
    MaxAutoRetriesNextServer:1
</code></pre>
<p>上面这段配置通过Zuul访问test-service服务时，Ribbon的ConnectTimeout是500ms，ReadTimeout是100ms，重试次数为1次； Zuul会根据ribbon设置的超时时间和重试次数，自动设置Hystrix的超时时间(上面这段配置, Zuul会把Hystrix的超时时间设置为:(100+500)*2=1200ms<br>
当然，我们也可以通过添加下面的配置显示指定Hystrix参数</p>
<pre><code class="language-yml">hystrix:
  command:
    service-calc-ribbon:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 3000
</code></pre>
<p>这里如果不显示设置，Zuul会根据ribbon设置的ConnectionTimeout和ReadTimeout自动确定Hystrix的超时时间（所以一般可以通过配置ribbon的超时时间来控制hystrix超时），由于ribbon默认重试次数是1，所以Hystrix的超时时间会被设置为(500+2000)*2=5000</p>
<h4 id="通过url代理的请求">通过URL代理的请求</h4>
<p>通过简单url配置的代理由于并没有走Ribbon和Hystrix，所有涉及到的超时参数只有ConnectTimeout和ReadTimeout，我们可以通过下面两个参数来分别设置：</p>
<pre><code>zuul.host.connect-timeout-millis=500 zuul.host.socket-timeout-millis=1000
</code></pre>
<h3 id="设置zuul请求使用的网络客户端">设置Zuul请求使用的网络客户端</h3>
<p>Zuul现在默认使用Apache HTTP Client代替已过时的Ribbon RestClient，可以通过下面的配置更改zuul使用的网络客户端</p>
<pre><code class="language-properties">ribbon.restclient.enabled=true #启用Ribbon RestClient
ribbon.okhttp.enabled=true #启用OkHttpClient
</code></pre>
<p>还可以通过自定义ClosableHttpClient或者OkHttpClient来设置Ribbon RestClient和OkHttpClient客户端的属性</p>
<h3 id="禁用zuul过滤器">禁用Zuul过滤器</h3>
<p>Zuul默认开启了好多各种用途的过滤器，我们也可以根据需要禁用自己不需要的过滤器（具体过滤器可查看ZuulFilter的子类）</p>
<pre><code class="language-properties">zuul.&lt;SimpleClassName&gt;.&lt;filterType&gt;.disable=true
</code></pre>
<p>如：禁用org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter</p>
<pre><code>zuul.SendResponseFilter.post.disable=true
</code></pre>
<h3 id="zuul针对特定路由的服务熔断">Zuul针对特定路由的服务熔断</h3>
<p>简单的降级处理示例：</p>
<pre><code class="language-java">@Component
public class MyGlobalFallbackProvider implements FallbackProvider {
    @Override
    public String getRoute() {
        return null;    //返回要设置降级的微服务名称或者配置的route名称，return &quot;*&quot;或者null 匹配所有微服务和路由（全局降级配置）
    }

    @Override
    public ClientHttpResponse fallbackResponse() {
        return response(HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @Override
    public ClientHttpResponse fallbackResponse(Throwable cause) {
        if(cause instanceof HystrixTimeoutException) {
            return response(HttpStatus.GATEWAY_TIMEOUT);
        } else {
            return fallbackResponse();
        }
    }

    public ClientHttpResponse response(final HttpStatus httpStatus) {
        return new ClientHttpResponse() {
            @Override
            public HttpStatus getStatusCode() throws IOException {
                return httpStatus;
            }

            @Override
            public int getRawStatusCode() throws IOException {
                return httpStatus.value();
            }

            @Override
            public String getStatusText() throws IOException {
                return httpStatus.getReasonPhrase();
            }

            @Override
            public void close() {

            }

            @Override
            public InputStream getBody() throws IOException {
                return new ByteArrayInputStream(&quot;服务不可用，请稍后再试。&quot;.getBytes());
            }

            @Override
            public HttpHeaders getHeaders() {
                // headers设定
                HttpHeaders headers = new HttpHeaders();
//                MediaType mt = new MediaType(&quot;application&quot;, &quot;json&quot;, Charset.forName(&quot;UTF-8&quot;));
                MediaType mt = MediaType.APPLICATION_JSON_UTF8;
                headers.setContentType(mt);
                return headers;
            }
        };
    }
}
</code></pre>
<blockquote>
<p>Zuul 目前只支持服务级别的熔断，不支持具体到某个URL进行熔断。</p>
</blockquote>
<h3 id="zuul路由重试">Zuul路由重试</h3>
<p>有时候因为网络或者其它原因，服务可能会暂时的不可用，这个时候我们希望可以再次对服务进行重试，Zuul也帮我们实现了此功能，需要结合Spring Retry 一起来实现</p>
<ol>
<li>添加依赖</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;
	&lt;artifactId&gt;spring-retry&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>配置方法</li>
</ol>
<pre><code class="language-yml">#是否开启重试功能
zuul.retryable=true
#对当前服务的重试次数
ribbon.MaxAutoRetries=2
#切换相同Server的次数
ribbon.MaxAutoRetriesNextServer=0
</code></pre>
<p>这样我们就开启了Zuul的重试功能。</p>
<h3 id="zuul高可用">Zuul高可用</h3>
<p><img src="http://www.itmind.net/assets/images/2018/springcloud/zuul-case.png" alt="Zuul高可用"><br>
我们实际使用Zuul的方式如上图，不同的客户端使用不同的负载将请求分发到后端的Zuul，Zuul在通过Eureka调用后端服务，最后对外输出。因此为了保证Zuul的高可用性，前端可以同时启动多个Zuul实例进行负载，在Zuul的前端使用<font color="red">Nginx</font>或者<font color="red">F5</font>进行负载转发以达到高可用性。</p>
<h3 id="zuul的核心filter">Zuul的核心——Filter</h3>
<p>Filter是Zuul的核心，用来实现对外服务的控制。Filter的生命周期有4个，分别是“PRE”、“ROUTING”、“POST”、“ERROR”，整个生命周期可以用下图来表示。<br>
<img src="http://www.itmind.net/assets/images/2018/springcloud/zuul-core.png" alt="Zuul Filter"><br>
Zuul大部分功能都是通过过滤器来实现的，这些过滤器类型对应于请求的典型生命周期。</p>
<ul>
<li>PRE： 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。</li>
<li>ROUTING：这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用Apache HttpClient或Netfilx Ribbon请求微服务。</li>
<li>POST：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。</li>
<li>ERROR：在其他阶段发生错误时执行该过滤器。 除了默认的过滤器类型，Zuul还允许我们创建自定义的过滤器类型。例如，我们可以定制一种STATIC类型的过滤器，直接在Zuul中生成响应，而不将请求转发到后端的微服务。</li>
</ul>
<h4 id="zuul中默认实现的filter">Zuul中默认实现的Filter</h4>
<table>
<thead>
<tr>
<th>类型</th>
<th>顺序</th>
<th>过滤器</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>pre</td>
<td>-3</td>
<td>ServletDetectionFilter</td>
<td>标记处理Servlet的类型</td>
</tr>
<tr>
<td>pre</td>
<td>-2</td>
<td>Servlet30WrapperFilter</td>
<td>包装HttpServletRequest请求</td>
</tr>
<tr>
<td>pre</td>
<td>-1</td>
<td>FormBodyWrapperFilter</td>
<td>包装请求体</td>
</tr>
<tr>
<td>route</td>
<td>1</td>
<td>DebugFilter</td>
<td>标记调试标志</td>
</tr>
<tr>
<td>route</td>
<td>5</td>
<td>PreDecorationFilter</td>
<td>处理请求上下文供后续使用</td>
</tr>
<tr>
<td>route</td>
<td>10</td>
<td>RibbonRoutingFilter</td>
<td>serviceId请求转发</td>
</tr>
<tr>
<td>route</td>
<td>100</td>
<td>SimpleHostRoutingFilter</td>
<td>url请求转发</td>
</tr>
<tr>
<td>route</td>
<td>500</td>
<td>SendForwardFilter</td>
<td>forward请求转发</td>
</tr>
<tr>
<td>post</td>
<td>0</td>
<td>SendErrorFilter</td>
<td>处理有错误的请求响应</td>
</tr>
<tr>
<td>post</td>
<td>1000</td>
<td>SendResponseFilter</td>
<td>处理正常的请求响应</td>
</tr>
</tbody>
</table>
<h4 id="禁用指定的filter">禁用指定的Filter</h4>
<pre><code class="language-yml">zuul:
  FormBodyWrapperFilter:
    pre:
	  disable: true
</code></pre>
<h4 id="自定义filter示例">自定义Filter示例</h4>
<p>我们假设有这样一个场景，因为服务网关应对的是外部的所有请求，为了避免产生安全隐患，我们需要对请求做一定的限制，比如请求中含有Token便让请求继续往下走，如果请求不带Token就直接返回并给出提示。</p>
<ol>
<li>首先自定义一个Filter，在run()方法中验证参数是否含有Token。</li>
</ol>
<pre><code class="language-java">public class TokenFilter extends ZuulFilter {

    private final Logger logger = LoggerFactory.getLogger(TokenFilter.class);

    @Override
    public String filterType() {
        return &quot;pre&quot;; // 可以在请求被路由之前调用
    }

    @Override
    public int filterOrder() {
        return 0; // filter执行顺序，通过数字指定 ,优先级为0，数字越大，优先级越低
    }

    @Override
    public boolean shouldFilter() {
        return true;// 是否执行该过滤器，此处为true，说明需要过滤
    }

    @Override
    public Object run() {
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();

        logger.info(&quot;---&gt;&gt;&gt; TokenFilter {},{}&quot;, request.getMethod(), request.getRequestURL().toString());

        String token = request.getParameter(&quot;token&quot;);// 获取请求的参数

        if (StringUtils.isNotBlank(token)) {
            ctx.setSendZuulResponse(true); //对请求进行路由
            ctx.setResponseStatusCode(200);
            ctx.set(&quot;isSuccess&quot;, true);
            return null;
        } else {
            ctx.setSendZuulResponse(false); //不对其进行路由
            ctx.setResponseStatusCode(400);
            ctx.setResponseBody(&quot;token is empty&quot;);
            ctx.set(&quot;isSuccess&quot;, false);
            return null;
        }
    }

}
</code></pre>
<ol start="2">
<li>将TokenFilter加入到请求拦截队列，在启动类中添加以下代码</li>
</ol>
<pre><code class="language-java">@Bean
public TokenFilter tokenFilter() {
	return new TokenFilter();
}
</code></pre>
<p>通过上面这例子我们可以看出，我们可以使用“PRE”类型的Filter做很多的验证工作，在实际使用中我们可以结合shiro、oauth2.0等技术去做鉴权、验证。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#netflix%E4%BD%93%E7%B3%BB%E7%AE%80%E4%BB%8B">Netflix体系简介</a>
<ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%88%90%E5%91%98">核心成员</a>
<ul>
<li><a href="#netflix-eureka">Netflix Eureka</a></li>
<li><a href="#netflix-ribbon">Netflix Ribbon</a></li>
<li><a href="#netflix-hystrix">Netflix Hystrix</a></li>
<li><a href="#netflix-zuul">Netflix Zuul</a></li>
<li><a href="#netflix-archaius">Netflix Archaius</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#eurekanetflix-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E6%B3%A8%E5%86%8C">Eureka(Netflix) - 服务发现与注册</a>
<ul>
<li><a href="#eureka%E4%BB%8B%E7%BB%8D">Eureka介绍</a></li>
<li><a href="#eureka%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">Eureka的使用方法</a>
<ul>
<li><a href="#eureka-server%E7%AB%AF%E9%85%8D%E7%BD%AE">Eureka Server端配置</a></li>
<li><a href="#eureka-client%E7%AB%AF">Eureka Client端</a></li>
</ul>
</li>
<li><a href="#eureka%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F">Eureka的保护模式</a></li>
</ul>
</li>
<li><a href="#ribbionnetflix-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">Ribbion(Netflix) - 客户端负载均衡</a>
<ul>
<li><a href="#ribbon%E4%BB%8B%E7%BB%8D">Ribbon介绍</a></li>
<li><a href="#ribbon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">Ribbon的使用方法</a></li>
<li><a href="#ribbon%E7%9A%84%E9%85%8D%E7%BD%AE">Ribbon的配置</a>
<ul>
<li><a href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9ribbon%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE">通过代码修改ribbon全局配置</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84ribbon%E9%85%8D%E7%BD%AE">通过代码修改指定微服务的ribbon配置</a></li>
<li><a href="#%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE">属性文件全局配置</a></li>
<li><a href="#%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6%E7%89%B9%E5%AE%9A%E9%85%8D%E7%BD%AE">属性文件特定配置</a></li>
</ul>
</li>
<li><a href="#ribbon%E4%B8%8Eeureka%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8">Ribbon与Eureka配合使用</a></li>
<li><a href="#ribbon%E8%84%B1%E7%A6%BBeureka%E5%8D%95%E7%8B%AC%E4%BD%BF%E7%94%A8">Ribbon脱离Eureka单独使用</a></li>
</ul>
</li>
<li><a href="#hystrixnetflix-%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD-%E9%99%8D%E7%BA%A7-%E9%99%90%E6%B5%81-%E9%9A%94%E7%A6%BB">Hystrix(Netflix) - 服务熔断、降级、限流、隔离</a>
<ul>
<li><a href="#hystrix%E4%BB%8B%E7%BB%8D">Hystrix介绍</a></li>
<li><a href="#hystrix%E7%9A%84%E7%94%A8%E6%B3%95">Hystrix的用法</a>
<ul>
<li><a href="#hystrix%E5%92%8Cfeign%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8">Hystrix和Feign一起使用</a></li>
<li><a href="#hystrix%E4%B8%8Eresttemplate%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8">Hystrix与RestTemplate一起使用</a></li>
</ul>
</li>
<li><a href="#hystrix%E7%9A%84%E9%85%8D%E7%BD%AE">Hystrix的配置</a>
<ul>
<li><a href="#hystrix%E4%BB%A3%E7%A0%81%E5%85%A8%E5%B1%80%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">Hystrix代码全局默认参数</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9Ahystrixcommand%E5%8F%82%E6%95%B0">通过代码修改指定HystrixCommand参数</a>
<ul>
<li><a href="#%E9%80%9A%E8%BF%87javanica%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BF%AE%E6%94%B9%E5%8D%95%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84hystrix%E5%8F%82%E6%95%B0%E6%8E%A8%E8%8D%90">通过javanica的方式修改单个方法的Hystrix参数（推荐）</a></li>
<li><a href="#%E9%80%9A%E8%BF%87javanica%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BF%AE%E6%94%B9%E5%A4%9A%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84hystrix%E5%8F%82%E6%95%B0">通过javanica的方式修改多个方法的Hystrix参数</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89command%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8C%85%E8%A3%B9%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%B8%8D%E6%8E%A8%E8%8D%90%E5%AE%9E%E9%99%85%E5%86%99%E8%B5%B7%E6%9D%A5%E5%A4%AA%E5%A4%8D%E6%9D%82">通过自定义Command类的方式包裹请求方法（不推荐，实际写起来太复杂）</a></li>
</ul>
</li>
<li><a href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9feignclient%E7%9A%84hystrix%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE">通过代码修改FeignClient的Hystrix参数配置</a></li>
<li><a href="#%E9%80%9A%E8%BF%87properties%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9Ahystrixcommand%E7%9A%84%E5%8F%82%E6%95%B0">通过Properties修改指定HystrixCommand的参数</a></li>
<li><a href="#%E9%80%9A%E8%BF%87properties%E4%BF%AE%E6%94%B9hystrix%E5%85%A8%E5%B1%80%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">通过Properties修改Hystrix全局默认参数</a></li>
<li><a href="#%E5%9C%A8properties%E4%B8%AD%E4%BF%AE%E6%94%B9feignclient%E7%9A%84hystrix%E5%8F%82%E6%95%B0">在Properties中修改FeignClient的Hystrix参数</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E9%A1%B9">常用配置项</a>
<ul>
<li><a href="#%E5%85%B3%E4%BA%8Equeuesizerejectionthreshold%E4%B8%8Emaxqueuesize">关于queueSizeRejectionThreshold与maxQueueSize</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#hystrix-metrics-stream">Hystrix Metrics Stream</a>
<ul>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95">配置方法</a></li>
</ul>
</li>
<li><a href="#hystrix%E7%9A%84%E7%9B%91%E6%8E%A7-hystrix-dashboard">Hystrix的监控 - Hystrix Dashboard</a></li>
</ul>
</li>
<li><a href="#zuulnetflix-%E7%BB%9F%E4%B8%80%E7%BD%91%E5%85%B3-%E5%9C%B0%E5%9D%80%E8%B7%AF%E7%94%B1">Zuul(Netflix) - 统一网关、地址路由</a>
<ul>
<li><a href="#zuul%E4%BB%8B%E7%BB%8D">Zuul介绍</a></li>
<li><a href="#zuul%E7%9A%84%E7%94%A8%E6%B3%95">Zuul的用法</a>
<ul>
<li><a href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E9%9C%80%E8%A6%81%E5%9C%A8reverse-proxy%E6%A8%A1%E5%BC%8F%E4%B8%8B">动态路由(需要在Reverse Proxy模式下)</a>
<ul>
<li><a href="#%E9%80%9A%E8%BF%87%E6%9C%8D%E5%8A%A1%E5%90%8D%E4%BB%A3%E7%90%86">通过服务名代理</a></li>
<li><a href="#serviceidpath%E7%9A%84%E6%96%B9%E5%BC%8F">ServiceId+Path的方式</a></li>
<li><a href="#%E5%BF%BD%E7%95%A5%E4%BB%A3%E7%90%86%E6%8C%87%E5%AE%9A%E6%9C%8D%E5%8A%A1">忽略代理指定服务</a></li>
<li><a href="#%E4%BB%A3%E7%90%86%E6%9C%AA%E6%8E%A5%E5%85%A5%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E6%9C%8D%E5%8A%A1">代理未接入服务注册中心的服务</a></li>
<li><a href="#%E6%B5%8B%E8%BF%87%E6%AD%A3%E5%88%99%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E8%A7%84%E5%88%99">测过正则配置代理规则</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E8%AE%BF%E9%97%AE%E5%89%8D%E7%BC%80">添加全局访问前缀</a></li>
<li><a href="#%E7%BB%99%E6%8C%87%E5%AE%9A%E6%9C%8D%E5%8A%A1%E6%B7%BB%E5%8A%A0%E5%89%8D%E7%BC%80">给指定服务添加前缀</a></li>
<li><a href="#%E6%9C%AC%E5%9C%B0%E8%BD%AC%E5%8F%91forward">本地转发(forward)</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F">路由规则先后顺序</a></li>
</ul>
</li>
<li><a href="#%E8%81%9A%E5%90%88%E5%A4%9A%E4%B8%AA%E5%90%8E%E7%AB%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80api%E7%BB%99%E5%89%8D%E7%AB%AF">聚合多个后端微服务提供统一API给前端</a></li>
<li><a href="#zuul%E7%9A%84%E8%AE%BF%E9%97%AE%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6">Zuul的访问超时控制</a>
<ul>
<li><a href="#%E9%80%9A%E8%BF%87serviceid%E4%BB%A3%E7%90%86%E7%9A%84%E8%AF%B7%E6%B1%82">通过ServiceId代理的请求</a></li>
<li><a href="#%E9%80%9A%E8%BF%87url%E4%BB%A3%E7%90%86%E7%9A%84%E8%AF%B7%E6%B1%82">通过URL代理的请求</a></li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E7%BD%AEzuul%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E5%AE%A2%E6%88%B7%E7%AB%AF">设置Zuul请求使用的网络客户端</a></li>
<li><a href="#%E7%A6%81%E7%94%A8zuul%E8%BF%87%E6%BB%A4%E5%99%A8">禁用Zuul过滤器</a></li>
<li><a href="#zuul%E9%92%88%E5%AF%B9%E7%89%B9%E5%AE%9A%E8%B7%AF%E7%94%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD">Zuul针对特定路由的服务熔断</a></li>
<li><a href="#zuul%E8%B7%AF%E7%94%B1%E9%87%8D%E8%AF%95">Zuul路由重试</a></li>
<li><a href="#zuul%E9%AB%98%E5%8F%AF%E7%94%A8">Zuul高可用</a></li>
<li><a href="#zuul%E7%9A%84%E6%A0%B8%E5%BF%83filter">Zuul的核心——Filter</a>
<ul>
<li><a href="#zuul%E4%B8%AD%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0%E7%9A%84filter">Zuul中默认实现的Filter</a></li>
<li><a href="#%E7%A6%81%E7%94%A8%E6%8C%87%E5%AE%9A%E7%9A%84filter">禁用指定的Filter</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89filter%E7%A4%BA%E4%BE%8B">自定义Filter示例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://ysjhhhhhhh.github.io/post/springcloud-quan-ju-yi-lai-ding-yi">
              <h3 class="post-title">
                SpringCloud全局依赖定义
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://ysjhhhhhhh.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
