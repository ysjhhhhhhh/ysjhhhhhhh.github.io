<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ysjhhhhhhh.github.io</id>
    <title>Gridea</title>
    <updated>2019-12-11T06:35:32.959Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ysjhhhhhhh.github.io"/>
    <link rel="self" href="https://ysjhhhhhhh.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://ysjhhhhhhh.github.io/images/avatar.png</logo>
    <icon>https://ysjhhhhhhh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Cookie&Session]]></title>
        <id>https://ysjhhhhhhh.github.io/post/Cookie&amp;Session</id>
        <link href="https://ysjhhhhhhh.github.io/post/Cookie&amp;Session">
        </link>
        <updated>2018-03-30T10:24:34.000Z</updated>
        <summary type="html"><![CDATA[<p>[TOC]</p>
<h1 id="cookie">Cookie</h1>
<blockquote>
<p>饼干. 其实是一份小数据， 是服务器给客户端，并且存储在客户端上的一份小数据</p>
</blockquote>
<h2 id="应用场景">应用场景</h2>
<blockquote>
<p>自动登录、浏览记录、购物车。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="cookie">Cookie</h1>
<blockquote>
<p>饼干. 其实是一份小数据， 是服务器给客户端，并且存储在客户端上的一份小数据</p>
</blockquote>
<h2 id="应用场景">应用场景</h2>
<blockquote>
<p>自动登录、浏览记录、购物车。</p>
</blockquote>
<!-- more -->
<h2 id="为什么要有这个cookie">为什么要有这个Cookie</h2>
<blockquote>
<p>http的请求是无状态。 客户端与服务器在通讯的时候，是无状态的，其实就是客户端在第二次来访的时候，服务器根本就不知道这个客户端以前有没有来访问过。 为了更好的用户体验，更好的交互 [自动登录]，其实从公司层面讲，就是为了更好的收集用户习惯[大数据]</p>
</blockquote>
<h2 id="cookie怎么用">Cookie怎么用</h2>
<h3 id="添加cookie给客户端">添加Cookie给客户端</h3>
<ol>
<li>在响应的时候，添加cookie</li>
</ol>
<pre><code class="language-java">	Cookie cookie = new Cookie(&quot;aa&quot;, &quot;bb&quot;);	
	//给响应，添加一个cookie
	response.addCookie(cookie);
</code></pre>
<ol start="2">
<li>客户端收到的信息里面，响应头中多了一个字段 Set-Cookie<br>
<img src="https://ysjhhhhhhh.github.io/post-images/1576045567472.png" alt=""></li>
</ol>
<h3 id="获取客户端带过来的cookie">获取客户端带过来的Cookie</h3>
<pre><code class="language-java">//获取客户端带过来的cookie
Cookie[] cookies = request.getCookies();
if(cookies != null){
    for (Cookie c : cookies) {
        String cookieName = c.getName();
        String cookieValue = c.getValue();
        System.out.println(cookieName + &quot; = &quot;+ cookieValue);
    }
}
</code></pre>
<h3 id="清除cookie">清除Cookie</h3>
<blockquote>
<p>Cookie没有提供delete方法，我们要删除需要设置maxAge 为0 。</p>
</blockquote>
<pre><code>Cookie cookie = new Cookie(&quot;history&quot;,&quot;&quot;);
cookie.setMaxAge(0); //设置立即删除
cookie.setPath(&quot;/CookieDemo02&quot;);
response.addCookie(cookie);
</code></pre>
<h3 id="其他常用方法">其他常用方法</h3>
<pre><code class="language-java">//关闭浏览器后，cookie就没有了。 ---&gt; 针对没有设置cookie的有效期。
//	expiry： 有效 以秒计算。
//正值 ： 表示 在这个数字过后，cookie将会失效。
//负值： 关闭浏览器，那么cookie就失效， 默认值是 -1
cookie.setMaxAge(60 * 60 * 24 * 7);

//赋值新的值
//cookie.setValue(newValue);

//用于指定只有请求了指定的域名，才会带上该cookie
cookie.setDomain(&quot;.itheima.com&quot;);

//只有访问该域名下的cookieDemo的这个路径地址才会带cookie
cookie.setPath(&quot;/CookieDemo&quot;);
</code></pre>
<h2 id="cookie示例-实现记住密码功能">Cookie示例 实现记住密码功能</h2>
<ol>
<li>用户打开网站后，自动读取Cookie中存储的用户名、密码</li>
<li>如果存在，自动填充到表单中</li>
<li>如果不存在，说明是第一次登录，需要登录后在后台将用户名、密码写入Cookie中，以便下次登录时自动填充</li>
</ol>
<h3 id="主要实现代码">主要实现代码</h3>
<h4 id="前端登录页">前端登录页</h4>
<pre><code class="language-jsp">&lt;body&gt;
	&lt;form action=&quot;LoginServlet&quot; method=&quot;post&quot;&gt;
		用户名： &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;userName&quot; onblur=&quot;inputPwd()&quot; &gt;
		&lt;br /&gt;
		密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码：
		&lt;input id=&quot;pwd&quot; type=&quot;password&quot; name=&quot;password&quot;&gt;
		&lt;br /&gt;
		&lt;input type=&quot;checkbox&quot; name=&quot;remeber_me&quot; value=&quot;true&quot; /&gt; 记住密码 
		&lt;br /&gt;
		&lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
	&lt;/form&gt;
&lt;/body&gt;
&lt;!-- 引入js操作Cookie的第三方库，也可以使用原生js API --&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
	
	// 从cookies里面按照用户输入的username去查找对应的password,
	// 如果找到，说明用户已经登录成功过，并且已经记录到cookie里。
	// 我们直接把对应的密码从cookie中拿出来，设置password密码框里
	
	// my_cookies其实就是一个map， 存储了所有的cookie键值对
	var my_cookies = Cookies.get();
	console.log(my_cookies);
	
	var pwdInput = document.getElementById(&quot;pwd&quot;);
	var username = document.getElementById(&quot;username&quot;);
	
	// 当输入完用户名，文本框失去焦点时，去cookie中找对应的密码，
	// 如果找到，直接填充到密码框里
	function inputPwd() {
		var userName = username.value;
		var cookieKey = &quot;username-&quot; + userName;
		console.log(cookieKey);
		var cookiePwd = my_cookies[cookieKey];
		console.log(cookiePwd);
		if(cookiePwd) {
			pwdInput.value = cookiePwd;
		}
	}
&lt;/script&gt;
</code></pre>
<h4 id="后台处理代码">后台处理代码</h4>
<pre><code class="language-java">protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		request.setCharacterEncoding(&quot;UTF-8&quot;);
		
		// 获取前台表单提交的用户名、密码
		String userName = request.getParameter(&quot;userName&quot;);
		String password = request.getParameter(&quot;password&quot;);
		
		// 获取前台是否勾上了记住密码
		String sRemeber = request.getParameter(&quot;remeber_me&quot;);
		boolean remeber = false;
		try {
			remeber = Boolean.parseBoolean(sRemeber);
		} catch (Exception e) {
		}
		
		
		// 设置响应格式和编码
		response.setContentType(&quot;text/html;charset=UTF-8&quot;);
		
		PrintWriter out = response.getWriter();
		if(isBlank(userName) || isBlank(password)) {
			out.println(&quot;&lt;script&gt;alert('用户名或密码不能为空!'); window.location.href='login.jsp';&lt;/script&gt;&quot;);
			return;
		}
		
		if(!userAccountData.containsKey(userName)) {
			out.println(&quot;&lt;script&gt;alert('不好意思，您还没有注册！'); window.location.href='login.jsp';&lt;/script&gt;&quot;);
			return;
		}
		
		String orginPassword = userAccountData.get(userName);
		if(password.startsWith(&quot;pwd-&quot;)) {
			password = password.substring(4);
		}
		
		if(orginPassword.equals(password)) {
			out.println(&quot;登录成功！&quot;);
			if(remeber) {
				Cookie cookie = new Cookie(&quot;username-&quot; + userName, &quot;pwd-&quot; + password);
				cookie.setMaxAge(120);
				response.addCookie(cookie);
			}
			return;
		} else {
			out.println(&quot;&lt;script&gt;alert('用户名或密码不正确，请重新输入！'); window.location.href='login.jsp';&lt;/script&gt;&quot;);
			return;
		}
	}
</code></pre>
<h2 id="cookie总结">Cookie总结</h2>
<ol>
<li>
<p>服务器给客户端发送过来的一小份数据，并且存放在客户端上。</p>
</li>
<li>
<p>创建Cookie:</p>
<p>使用new来创建Cookie对象</p>
<pre><code class="language-java">Cookie cookie = new Cookie(&quot;xxx&quot;, &quot;wangzhenongyao&quot;);
</code></pre>
</li>
<li>
<p>添加cookie</p>
<p>添加cookie通过响应对象的addCookie方法</p>
<pre><code class="language-java">// 底层实现原理其实是在响应头中添加了一个： Set-Cookie: password=qiaoshouyuan; Max-Age=60; Expires=Fri, 20-Sep-2019 08:41:19 GMT; HttpOnly
response.addCookie();
</code></pre>
</li>
<li>
<p>获取cookie</p>
<pre><code class="language-java">Cookie[] cookies = request.getCookies();
</code></pre>
</li>
<li>
<p>Cookie有效时间</p>
<ol>
<li>
<p>会话Cookie</p>
<p>默认情况下，关闭了浏览器，那么cookie就会消失。</p>
<blockquote>
<p>这是默认的行为，但是大部分现代的浏览器都不会这么做，比如chrome浏览器，默认打开时会恢复上次关闭时的状态，所有关闭浏览器cookie并不会失效。 我们可以设置浏览器打开时不恢复上次状态，改为打开新的标签页即可。</p>
</blockquote>
</li>
<li>
<p>持久Cookie</p>
<p>通过设置MaxAge指定存活时间，在存活时间内，都有效，并且会保存在客户端上。</p>
</li>
</ol>
<pre><code>cookie.setMaxAge(0); //设置立即删除  
cookie.setMaxAge(100); //100 秒
</code></pre>
</li>
<li>
<p>Cookie的安全问题。</p>
<blockquote>
<p>由于Cookie会保存在客户端上，所以有安全隐患问题。  还有一个问题， Cookie的大小与个数有限制。 为了解决这个问题 ---&gt; Session .</p>
</blockquote>
</li>
<li>
<p>Cookie不能直接存储中文，需要做转码</p>
</li>
</ol>
<h1 id="session">Session</h1>
<blockquote>
<p>会话 ， Session是基于Cookie的一种会话机制。 Cookie是服务器返回一小份数据给客户端，并且存放在客户端上。 Session是，数据存放在服务器端。</p>
</blockquote>
<h2 id="常用api">常用API</h2>
<pre><code class="language-java">//得到会话ID
String id = session.getId();

//存值
session.setAttribute(name, value);

//取值
session.getAttribute(name);

//移除值
session.removeAttribute(name);
</code></pre>
<h2 id="session创建和销毁">Session创建和销毁</h2>
<h3 id="创建">创建</h3>
<blockquote>
<p>在调用所有可以获取session的页面中(如：JSP、Servlet)，就会创建Session，并且浏览器Cookie中也会生成JSESSIONID</p>
</blockquote>
<h3 id="获取session">获取Session</h3>
<pre><code>request.getSession();
</code></pre>
<h3 id="销毁">销毁</h3>
<blockquote>
<p>session 是存放在服务器的内存中的一份数据。</p>
</blockquote>
<blockquote>
<ol>
<li>关闭服务器</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>session会话时间过期。 有效期过了，默认有效期： 30分钟。</li>
</ol>
</blockquote>
<h3 id="移除session中的元素">移除Session中的元素</h3>
<pre><code>//强制干掉会话，里面存放的任何数据就都没有了。
session.invalidate();

//从session中移除某一个数据
//session.removeAttribute(&quot;cart&quot;);
</code></pre>
<h1 id="总结">总结：</h1>
<h2 id="cookie-2">Cookie</h2>
<p>服务器给客户端发送一小份数据， 存放在客户端上。</p>
<h3 id="基本用法">基本用法：</h3>
<pre><code>添加cookie

获取cookie。
</code></pre>
<h3 id="什么时候有cookie">什么时候有cookie</h3>
<p>response.addCookie(new Cookie())</p>
<h3 id="cookie-分类">Cookie 分类</h3>
<ul>
<li>
<p>会话Cookie</p>
<pre><code>  关闭浏览器，就失效
</code></pre>
</li>
<li>
<p>持久cookie</p>
<p>存放在客户端上。 在指定的期限内有效。</p>
<pre><code>	setMaxAge();
</code></pre>
</li>
</ul>
<h2 id="session-2">Session</h2>
<p>也是基于cookie的一种会话技术，  数据存放存放在服务器端，会在cookie里面添加一个字段 JSESSIONID . 是tomcat服务器生成。</p>
<h3 id="常用api-2">常用API</h3>
<pre><code>
setAttribute 存数据
 
getAttribute 取数据

removeAttribute  移除数据

req.getRequestedSessionId();  获取会话id
session.getId();  获取会话id

invalidate() 强制让会话失效。
</code></pre>
<h3 id="创建和销毁">创建和销毁</h3>
<ul>
<li>创建： 首次访问所有可以调用request.getSession方法的页面时，session创建，同时JSESSIONID也会生成</li>
<li>销毁：
<ul>
<li>关闭浏览器</li>
<li>会话超时（默认是30分钟）</li>
<li>服务端调用invalidate</li>
</ul>
</li>
</ul>
<h2 id="cookie和session的区别">Cookie和Session的区别</h2>
<ol>
<li>Cookie数据存放到客户端（浏览器），Session存放在服务端；</li>
<li>Cookie存放的数据大小有限制，不能超过4k；很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>Cookie由于存放在客户端硬盘上，所以相较于Session来说安全性低一点；</li>
<li>cookie失效时间是通过setMaxAge来设置，session是通过setInactiveInterval方法设置</li>
<li>Cookie中只能存储字符串的值，而且还不能中文。而Session中可以存储任意语言的字符串，或者Java中的所有类型。</li>
<li>Cookie是由程序员在业务代码中自己创建的，而Session是由容器创建的。</li>
</ol>
<h2 id="cookie和session的关系">Cookie和Session的关系</h2>
<p>HTTP协议本身是无状态的，也就是说服务端无法通过一个请求判断出谁是谁，而Session作为服务端跟踪用户状态的一项技术，在整个容器中存在很多份数据。如何知道一个请求进来应该拿哪份Session数据这是个问题。那么要解决这个问题，我们需要在请求中添加一个标识，Cookie技术就解决了这个问题。具体来说，Tomcat会在浏览器第一次访问JSP、Servlet时分配一个独一无二的Cookie标识(JSESSIONID)，写到浏览器端。后续每次请求时，浏览器会携带这个标识，进而服务端就可以区分出来谁是谁，然后拿对应的Session数据。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Litener&Filter]]></title>
        <id>https://ysjhhhhhhh.github.io/post/Litener&amp;Filter</id>
        <link href="https://ysjhhhhhhh.github.io/post/Litener&amp;Filter">
        </link>
        <updated>2018-03-28T02:04:40.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="listener">Listener</h1>
<blockquote>
<p>监听器</p>
</blockquote>
<ul>
<li>能做什么事？</li>
</ul>
<blockquote>
<p>监听某一个事件的发生。 状态的改变。</p>
</blockquote>
<ul>
<li>监听器的内部机制</li>
</ul>
<blockquote>
<p>其实就是接口回调.</p>
</blockquote>
<h2 id="监听器实现原理观察者模式">监听器实现原理——观察者模式</h2>
<ul>
<li>需求：</li>
</ul>
<blockquote>
<p>A在执行循环，当循环到5的时候， 通知B。</p>
</blockquote>
<blockquote>
<p>事先先把一个对象传递给 A ， 当A 执行到5的时候，通过这个对象，来调用B中的方法。 但是注意，不是直接传递B的实例，而是传递一个接口的实例过去。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://ysjhhhhhhh.github.io/post-images/1576044349452.png" alt=""></figure>
<h2 id="web监听器介绍">Web监听器介绍</h2>
<p>在JavaWeb开发中监听器总共有8个</p>
<h3 id="按照使用方法来划分可以分为两类">按照使用方法来划分可以分为两类</h3>
<h4 id="第一类-实现接口然后通过注册生效">第一类 实现接口然后通过注册生效</h4>
<p>具体配置步骤</p>
<ol>
<li>实现对应的监听器接口</li>
<li>重写接口中的方法</li>
<li>然后在web.xml或者注解的方式注册到容器中来使用</li>
</ol>
<p>适用的监听器类型</p>
<p>ServletRequestListener、HttpSessionListener、ServletContextListener、ServletRequestAttributeListener、HttpSessionAttributeListener、SerlvetContextAttributeListener</p>
<h4 id="第二类-让需要监听session中的特定类型实现监听接口不需要注册生效">第二类  让需要监听Session中的特定类型实现监听接口，不需要注册生效</h4>
<p>具体配置步骤</p>
<ol>
<li>让需要监听Session中的特定类型，如UserInfo实现监听接口</li>
<li>实现接口中的方法</li>
</ol>
<p>适用的监听器类型</p>
<p>HttpSessionBindingListener、HttpSessionActivationListener</p>
<h3 id="按照监听器的作用可以划分为三类">按照监听器的作用可以划分为三类</h3>
<h4 id="监听三个作用域创建和销毁">监听三个作用域创建和销毁</h4>
<ul>
<li>request  ---HttpServletRequest</li>
<li>session  ---HttpSession</li>
<li>application  --- ServletContext</li>
</ul>
<h5 id="servletrequestlistener">ServletRequestListener</h5>
<ul>
<li>监听事件</li>
</ul>
<pre><code>request创建:

    访问服务器上的任意资源都会有请求出现。

    访问 html： 会
    访问 jsp:	会
    访问 servlet : 会 

request销毁：

	服务器已经对这次请求作出了响应。			
</code></pre>
<ul>
<li>实现示例</li>
</ul>
<ol>
<li>新建Java类，实现ServletRequestListener接口</li>
</ol>
<pre><code class="language-java">import javax.servlet.ServletRequestEvent;
import javax.servlet.ServletRequestListener;

public class RequestListener implements ServletRequestListener {

	@Override
	public void requestDestroyed(ServletRequestEvent sre) {
		System.out.println(&quot;request请求结束&quot;);
	}

	@Override
	public void requestInitialized(ServletRequestEvent sre) {
		System.out.println(&quot;request请求开始&quot;);
	}
}
</code></pre>
<ol start="2">
<li>在web.xml中注册监听器</li>
</ol>
<pre><code class="language-xml">&lt;listener&gt;
    &lt;listener-class&gt;com.lanou3g.demo.RequestListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<h5 id="httpsessionlistener">HttpSessionListener</h5>
<ul>
<li>监听事件</li>
</ul>
<pre><code>	session的创建
	    只要调用getSession
	
	    html:		不会
	    jsp:		会	  getSession();
	    servlet: 	会
	
	session的销毁
	    超时  30分钟
	    非正常关闭 销毁
	    正常关闭服务器(序列化)
</code></pre>
<ul>
<li>应用场景</li>
</ul>
<blockquote>
<p>统计在线人数.</p>
</blockquote>
<ul>
<li>实现示例</li>
</ul>
<ol>
<li>新建Java类，实现HttpSessionListener接口</li>
</ol>
<pre><code class="language-java">import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;

public class SessionLinsener implements HttpSessionListener {
	@Override
	public void sessionCreated(HttpSessionEvent se) {
		System.out.println(&quot;session被创建了&quot;);
	}

	@Override
	public void sessionDestroyed(HttpSessionEvent se) {
		System.out.println(&quot;session销毁了&quot;);
	}
}
</code></pre>
<ol start="2">
<li>在web.xml中注册监听器</li>
</ol>
<pre><code class="language-xml">&lt;listener&gt;
    &lt;listener-class&gt;com.lanou3g.demo.SessionLinsener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<h5 id="servletcontextlistener">ServletContextListener</h5>
<ul>
<li>
<p>监听事件</p>
<ul>
<li>
<p>ServletContext创建：启动服务器的时候</p>
</li>
<li>
<p>ServletContext销毁：关闭服务器. 从服务器移除项目</p>
</li>
</ul>
</li>
<li>
<p>应用场景</p>
</li>
</ul>
<blockquote>
<p>在servletcontext创建的时候，</p>
<ol>
<li>完成自己想要的初始化工作</li>
<li>执行自定义任务调度。 执行某一个任务。 Timer</li>
</ol>
</blockquote>
<ul>
<li>实现示例</li>
</ul>
<p>新建Java类，实现ServletContextListener接口</p>
<pre><code class="language-java">import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;

public class ContextListener implements ServletContextListener {
	@Override
	public void contextInitialized(ServletContextEvent sce) {
		System.out.println(&quot;ServletContext初始化&quot;);
	}
	@Override
	public void contextDestroyed(ServletContextEvent sce) {
		System.out.println(&quot;ServletContext销毁&quot;);
	}
}
</code></pre>
<p>在web.xml中注册监听器</p>
<pre><code class="language-xml">&lt;listener&gt;
    &lt;listener-class&gt;com.lanou3g.demo.ContextListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<h4 id="监听三个作用域属性状态变更">监听三个作用域属性状态变更</h4>
<blockquote>
<p>可以监听在作用域中值 添加  | 替换  | 移除的动作。</p>
</blockquote>
<h5 id="servletcontext-servletcontextattributelistener">servletContext --- ServletContextAttributeListener</h5>
<figure data-type="image" tabindex="2"><img src="https://ysjhhhhhhh.github.io/post-images/1576044425334.png" alt=""></figure>
<h5 id="request-servletrequestattributelistener">request --- ServletRequestAttributeListener</h5>
<figure data-type="image" tabindex="3"><img src="https://ysjhhhhhhh.github.io/post-images/1576044439138.png" alt=""></figure>
<h5 id="session-httpsessionattributelistener">session --- HttpSessionAttributeListener</h5>
<figure data-type="image" tabindex="4"><img src="https://ysjhhhhhhh.github.io/post-images/1576044413990.png" alt=""></figure>
<h4 id="监听httpsession里面存值的状态变更">监听httpSession里面存值的状态变更</h4>
<blockquote>
<p>这一类监听器不用注册。</p>
</blockquote>
<h5 id="httpsessionbindinglistener">HttpSessionBindingListener</h5>
<blockquote>
<p>监听特定类型对象与session 绑定和解除绑定 的动作，注意此监听器是让JavaBean实现监听接口，即表示当session中此类型的value状态发生变更时，此JavaBean会收到通知</p>
</blockquote>
<p><span style="color:red;font-weight:bold;">与HttpSessionAttributeListener监听器不同的是，该监听器只对Session中的某种特定类型的属性变化感兴趣</span></p>
<pre><code class="language-java">// 注意：是让JavaBean实现该接口，不需要添加任何注解或在web.xml中配置

import javax.servlet.http.HttpSessionBindingEvent;
import javax.servlet.http.HttpSessionBindingListener;

public class Man implements HttpSessionBindingListener {

	private String name;
	private String nickName;
	private int age;

	public Man() {
	}

	public Man(String name, String nickName, int age) {
		this.name = name;
		this.nickName = nickName;
		this.age = age;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getNickName() {
		return nickName;
	}

	public void setNickName(String nickName) {
		this.nickName = nickName;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	@Override
	public void valueBound(HttpSessionBindingEvent event) {
		Man man = (Man) event.getValue();
		System.out.println(&quot;man对象绑定到session中 name: &quot; + man.getName() + &quot;, value: &quot; + event.getValue());
	}

	@Override
	public void valueUnbound(HttpSessionBindingEvent event) {
		Man man = (Man) event.getValue();
		System.out.println(&quot;man对象从session中解绑 name: &quot; + man.getName() + &quot;, value: &quot; + event.getValue());
	}
}
</code></pre>
<h5 id="httpsessionactivationlistener">HttpSessionActivationListener</h5>
<blockquote>
<p>用于监听现在session的值 是 钝化 （序列化）还是活化 （反序列化）的动作</p>
</blockquote>
<ul>
<li>钝化 （序列化）</li>
</ul>
<blockquote>
<p>把内存中的数据 存储到硬盘上</p>
</blockquote>
<ul>
<li>活化 （反序列化）</li>
</ul>
<blockquote>
<p>把硬盘中的数据读取到内存中。</p>
</blockquote>
<ul>
<li>session的钝化活化的用意何在</li>
</ul>
<blockquote>
<p>session中的值可能会很多， 并且我们有很长一段时间不使用这个内存中的值， 那么可以考虑把session的值可以存储到硬盘上【钝化】，等下一次在使用的时候，在从硬盘上提取出来。 【活化】</p>
</blockquote>
<ul>
<li>如何让session的在一定时间内钝化.</li>
</ul>
<h6 id="钝化-活化监听需要修改tomcat配置">钝化、活化监听需要修改Tomcat配置</h6>
<p>修改的地方有三个可选，主要是作用范围不一样</p>
<pre><code>1. 在tomcat里面 conf/context.xml 里面配置

		对所有的运行在这个服务器的项目生效

2. 在conf/Catalina/localhost/context.xml 配置

		对 localhost生效。  localhost:8080

3. 在自己的web工程项目中的 META-INF/context.xml

		只对当前的工程生效。
</code></pre>
<p>修改方法：</p>
<pre><code class="language-xml">	&lt;!--
		参数说明：
		# maxIdleSwap ： 1分钟不用就钝化
		# directory ：  钝化后的那个文件存放的目录位置。 
	--&gt;
	&lt;Context&gt;
		&lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot; maxIdleSwap=&quot;1&quot;&gt;
			&lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;F:/temp&quot;/&gt;
		&lt;/Manager&gt;
	&lt;/Context&gt;
</code></pre>
<h6 id="监听器使用步骤">监听器使用步骤</h6>
<ol>
<li>与HttpSessionBindingListener类似， HttpSessionActivationListener也是针对特定类型监听的。那我们需要让需要监听钝化、活化状态的特定的JavaBean实现HttpSessionActivationListener接口</li>
<li>上面提到的几种配置方法，任选一种告诉Tomcat当Session不活跃、或者容器停止时Session钝化的策略</li>
</ol>
<p>做好上面两步，当Session中有监听的特定类型，并且Session钝化、活化时就能触发通知</p>
<h2 id="filter">Filter</h2>
<blockquote>
<p>过滤器 ， 其实就是对客户端发出来的请求进行过滤。 浏览器发出， 然后服务器派servlet处理。  在中间就可以过滤， 其实过滤器起到的是拦截的作用。</p>
</blockquote>
<ul>
<li>
<p>作用</p>
<ol>
<li>对一些敏感词汇进行过滤</li>
<li>统一设置编码</li>
<li>自动登录</li>
</ol>
<p>...</p>
</li>
</ul>
<h3 id="如何使用filter">如何使用Filter</h3>
<ol>
<li>定义一个类， 实现Filter</li>
</ol>
<pre><code class="language-java">public class FilterDemo implements Filter {	
    public void destroy() {
    }

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    System.out.println(&quot;来到过虑器了。。。&quot;);
    chain.doFilter(request, response);
    }

    public void init(FilterConfig fConfig) throws ServletException {
    }
}
</code></pre>
<ol start="2">
<li>注册过滤器</li>
</ol>
<blockquote>
<p>在web.xml里面注册，注册的手法与servlet基本一样。</p>
</blockquote>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;display-name&gt;FilterDemo&lt;/display-name&gt;
    &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt;
    &lt;filter-class&gt;com.itheima.filter.FilterDemo&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<blockquote>
<p>在Servlet3.0里可以通过 @WebFilter注解配置</p>
</blockquote>
<h3 id="filter的生命周期">Filter的生命周期</h3>
<ul>
<li>创建</li>
</ul>
<blockquote>
<p>在服务器启动的时候就创建。</p>
</blockquote>
<ul>
<li>销毁</li>
</ul>
<blockquote>
<p>服务器停止的时候。</p>
</blockquote>
<h3 id="filter执行顺序">Filter执行顺序</h3>
<ol>
<li>
<p>客户端发出请求，先经过过滤器， 如果过滤器放行，那么才能到servlet</p>
</li>
<li>
<p>如果有多个过滤器， 那么他们会按照注册的映射顺序 来 排队。 只要有一个过滤器， 不放行，那么后面排队的过滤器以及咱们的servlet都不会收到请求。</p>
</li>
</ol>
<h3 id="filter细节">Filter细节</h3>
<ol>
<li>
<p>init方法的参数 FilterConfig , 可以用于获取filter在注册的名字 以及初始化参数。  其实这里的设计的初衷与ServletConfig是一样的。</p>
</li>
<li>
<p>如果想放行，那么在doFilter 方法里面操作，使用参数 chain</p>
</li>
</ol>
<pre><code class="language-java">chain.doFilter(request, response); 放行， 让请求到达下一个目标。
</code></pre>
<ol start="3">
<li>
<p><url-pattern>/*</url-pattern> 写法格式与servlet一样。</p>
<ol>
<li>
<p>全路径匹配  以 /  开始</p>
<pre><code> /LoginServlet
</code></pre>
</li>
<li>
<p>以目录匹配 以 / 开始  以 * 结束</p>
<p>/demo01/*</p>
</li>
<li>
<p>以后缀名匹配  以 * 开始 以后缀名结束</p>
<p>*.jsp  *.html *.do</p>
</li>
</ol>
<blockquote>
<p>注意：*号只能代表一段目录或者文件名，不能代替单词中的部分字母</p>
</blockquote>
</li>
<li>
<p>针对 dispatcher 设置</p>
<pre><code> ​	REQUEST ： 只要是请求过来，都拦截，默认就是REQUEST 
</code></pre>
<p>​	FORWARD : 只要是转发都拦截。<br>
​	ERROR ： 页面出错发生跳转<br>
​	INCLUDE ： 包含页面的时候就拦截。<br>
​</p>
</li>
</ol>
<h3 id="案例一-实现自动登录">案例一 实现自动登录</h3>
<ul>
<li>
<p>需求分析</p>
<ol>
<li>用户正常登录过一次以后，只要session不失效，用户可以直接访问网站中的其他页面，而不用再次登录。</li>
<li>如果没有登录或者session失效了， 那直接访问其他页面重定向到登录页面</li>
</ol>
</li>
</ul>
<h4 id="1-搭建环境">1. 搭建环境</h4>
<ol>
<li>搭建数据库</li>
<li>搭建页面</li>
</ol>
<h4 id="2-部分后台代码">2. 部分后台代码</h4>
<p>登录servlet代码</p>
<pre><code class="language-java">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

	try {
		String userName = request.getParameter(&quot;username&quot;);
		String password = request.getParameter(&quot;password&quot;);
		String autoLogin = request.getParameter(&quot;auto_login&quot;);
		UserBean user = new UserBean();
		user.setUsername(userName);
		user.setPassword(password);
		
		UserDao dao = new UserDaoImpl();
		UserBean userBean = dao.login(user);
		
		if(userBean != null){
			//成功了，进入首页
			request.getSession().setAttribute(&quot;userBean&quot;, userBean);
			response.sendRedirect(&quot;index.jsp&quot;);
		}else{
			//不成功...
			request.getRequestDispatcher(&quot;login.jsp&quot;).forward(request, response);
		}
		
	} catch (SQLException e) {
		e.printStackTrace();
	}
}
</code></pre>
<p>过滤器代码</p>
<ul>
<li>实现思路</li>
</ul>
<ol>
<li>
<p>先判断session是否有效， 如果失效了，直接把请求重定向到登录页，让用户完成手动登录</p>
</li>
<li>
<p>如果session没有失效，那么就从session中获取用户登录信息和数据库中做对比，如果正确就可以正常登录。否则重定向到登录页，让用户手动登录。</p>
</li>
</ol>
<pre><code class="language-java">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		
		HttpServletRequest req = (HttpServletRequest) request;
		HttpServletResponse resp = (HttpServletResponse) response;
		HttpSession session = req.getSession();
		
		// 如果session里没有登录信息，无法自动登录，重定向到登录页，让用户手动登录
		if(session.getAttribute(&quot;username&quot;) == null) {
			resp.sendRedirect(&quot;login.jsp&quot;);
			return;
		}
		
		String username = (String) session.getAttribute(&quot;username&quot;);
		String password = (String) session.getAttribute(&quot;password&quot;);
		
		// 检查session中的登录信息是否正确
		if(checkValid(username, password)) {
			chain.doFilter(request, response);
		}
	}
</code></pre>
<h2 id="总结">总结</h2>
<h3 id="listener-2">Listener</h3>
<pre><code>8个 

三种类型  
	针对三个作用域的创建和销毁
	针对三个作用域的值改变 【添加 | 替换 | 移除】
	针对session中的值 【钝化 活化】 ， 【绑定  解绑】

钝化 ( 序列化 ) 
	内存中的对象存储到硬盘 

	超时失效。 session销毁了。 

非正常关闭服务器， 钝化  。 正常关闭服务器 销毁

设置了session钝化策略：context.xml

活化 (反序列化)
	从硬盘里面读取到内存
</code></pre>
<p>应用场景：</p>
<p>ServletContextListner  ： 应用被部署的时候， 服务器加载这个项目的时候，做一些初始化工作， 任务调度。<br>
HttpSessionBindingListener	： 统计在线人数<br>
HttpSessionActivationListener  ： 钝化活化处理</p>
<h3 id="filter-2">Filter</h3>
<blockquote>
<p>使用频率更高</p>
</blockquote>
<ul>
<li>如果要写一个过滤器。</li>
</ul>
<blockquote>
<ol>
<li>定义一个类，实现接口 Filter</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>注册 web.xml . 与servlet相似。</li>
</ol>
</blockquote>
<ul>
<li>过滤器放行。</li>
</ul>
<blockquote>
<p>chain.doFilter(request, response);</p>
</blockquote>
<ul>
<li>
<p>过滤器生命周期</p>
<p>创建： 服务器加载这个项目的时候创建实例</p>
<p>销毁： 关闭服务器或者从服务器中移除项目的时候。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JSP & EL & JSTL]]></title>
        <id>https://ysjhhhhhhh.github.io/post/jsp-and-el-and-jstl</id>
        <link href="https://ysjhhhhhhh.github.io/post/jsp-and-el-and-jstl">
        </link>
        <updated>2018-03-26T05:57:33.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="jsp基础知识">JSP基础知识</h2>
<blockquote>
<p>JSP全称Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servlet设计，它是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。</p>
</blockquote>
<ul>
<li>什么是jsp</li>
</ul>
<blockquote>
<p>从用户角度看待 ，就是是一个网页 ， 从程序员角度看待 ， 其实是一个java类， 它继承了servlet，所以可以直接说jsp 就是一个Servlet.</p>
</blockquote>
<ul>
<li>为什么会有jsp?</li>
</ul>
<blockquote>
<p>html 多数情况下用来显示静态内容 ， 一成不变的。 但是有时候我们需要在网页上显示一些动态数据， 比如： 查询所有的学生信息， 根据姓名去查询具体某个学生。  这些动作都需要去查询数据库，然后在网页上显示。 html是不支持写java代码  ， jsp里面可以写java代码。</p>
</blockquote>
<ul>
<li>动态网页</li>
</ul>
<blockquote>
<p>所谓的动态网页，是指跟静态网页相对的一种网页编程技术。静态网页，随着html代码的生成，页面的内容和显示效果就基本上不会发生变化了——除非你修改页面代码。而动态网页则不然，页面代码虽然没有变，但是显示的内容却是可以随着时间、环境或者数据库操作的结果而发生改变的。</p>
<p>不要将动态网页和页面内容是否有动感混为一谈。这里说的动态网页，与网页上的各种动画、滚动字幕等视觉上的动态效果没有直接关系，动态网页也可以是纯文字内容的，也可以是包含各种动画的内容，这些只是网页具体内容的表现形式，无论网页是否具有动态效果，只要是采用了动态网站技术生成的网页都可以称为动态网页。</p>
</blockquote>
<h3 id="页面结构">页面结构</h3>
<h3 id="jsp声明变量-方法">JSP声明变量、方法</h3>
<pre><code class="language-jsp">&lt;%! 

  private int age = 0;
	
	public void sayHello() {
     out.println(&quot;Hello World!&quot;);
  }
  
%&gt;
</code></pre>
<h3 id="jsp表达式">JSP表达式</h3>
<pre><code class="language-jsp">&lt;%=age %&gt;
</code></pre>
<h3 id="java代码片段">Java代码片段</h3>
<pre><code class="language-jsp">&lt;%

age = age + 10;
sayHello();

%&gt;
</code></pre>
<h3 id="jsp注释">JSP注释</h3>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>语法</strong></th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&lt;%-- 注释 --%&gt;</td>
<td style="text-align:left">JSP注释，注释内容不会被发送至浏览器甚至不会被编译</td>
</tr>
<tr>
<td style="text-align:left"><!-- 注释 --></td>
<td style="text-align:left">HTML注释，通过浏览器查看网页源代码时可以看见注释内容</td>
</tr>
<tr>
<td style="text-align:left">&lt;%</td>
<td style="text-align:left">代表静态 &lt;%常量</td>
</tr>
<tr>
<td style="text-align:left">%\&gt;</td>
<td style="text-align:left">代表静态 %&gt; 常量</td>
</tr>
<tr>
<td style="text-align:left">\'</td>
<td style="text-align:left">在属性中使用的单引号</td>
</tr>
<tr>
<td style="text-align:left">\&quot;</td>
<td style="text-align:left">在属性中使用的双引号</td>
</tr>
</tbody>
</table>
<h3 id="jsp生命周期">JSP生命周期</h3>
<figure data-type="image" tabindex="1"><img src="img/jsp_life_cycle.jpg" alt="JSP生命周期"></figure>
<ul>
<li>
<p>编译阶段</p>
<p>当浏览器请求JSP页面时，JSP引擎会首先去检查是否需要编译这个文件。如果这个文件没有被编译过，或者在上次编译后被更改过，则编译这个JSP文件。</p>
<ul>
<li>解析JSP文件</li>
<li>将JSP文件转为Servlet</li>
<li>编译Servlet文件</li>
</ul>
</li>
<li>
<p>初始化阶段</p>
<p>加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法</p>
<pre><code class="language-java">// 可以重写此方法，添加初始化逻辑
public void _jspInit() {
}
</code></pre>
</li>
<li>
<p>执行阶段</p>
<p>调用与JSP对应的servlet实例的服务方法</p>
<pre><code class="language-java">public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)throws java.io.IOException, javax.servlet.ServletException {
  // 分发请求
  // doGet
  // doPost
}
</code></pre>
</li>
<li>
<p>销毁阶段</p>
<p>调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例</p>
<pre><code class="language-java">// 可以重写此方法，添加销毁操作
public void _jspDestroy() {
}
</code></pre>
</li>
</ul>
<h2 id="三大jsp指令">三大JSP指令</h2>
<h3 id="指令写法">指令写法</h3>
<p>&lt;%@ 指令名字 属性名=&quot;属性值&quot; %&gt;</p>
<h3 id="page指令">page指令</h3>
<ul>
<li>language</li>
</ul>
<blockquote>
<p>表明jsp页面中可以写java代码</p>
</blockquote>
<ul>
<li>contentType</li>
</ul>
<blockquote>
<p>其实即使说这个文件是什么类型，告诉浏览器我是什么内容类型，以及使用什么编码</p>
</blockquote>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
</code></pre>
<ul>
<li>
<p>pageEncoding  jsp内容编码</p>
</li>
<li>
<p>extends 用于指定jsp翻译成java文件后，继承的父类是谁，一般不用改。</p>
</li>
<li>
<p>import 导包使用的，一般不用手写。</p>
</li>
<li>
<p>session</p>
</li>
</ul>
<blockquote>
<p>值可选的有true or false .</p>
</blockquote>
<blockquote>
<p>用于控制在这个jsp页面里面，能够直接使用session对象。</p>
</blockquote>
<blockquote>
<p>具体的区别是，请看翻译后的java文件   如果该值是true , 那么在代码里面会有getSession（）的调用，如果是false :  那么就不会有该方法调用，也就是没有session对象了。在页面上自然也就不能使用session了。</p>
</blockquote>
<ul>
<li>errorPage</li>
</ul>
<blockquote>
<p>指的是错误的页面， 值需要给错误的页面路径</p>
</blockquote>
<ul>
<li>isErrorPage</li>
</ul>
<blockquote>
<p>上面的errorPage 用于指定错误的时候跑到哪一个页面去。 那么这个isErroPage , 就是声明某一个页面到底是不是错误的页面。</p>
</blockquote>
<h3 id="include指令">include指令</h3>
<blockquote>
<p>包含另外一个jsp的内容进来。</p>
</blockquote>
<pre><code>	&lt;%@ include file=&quot;other02.jsp&quot;%&gt;
</code></pre>
<ul>
<li>背后细节:</li>
</ul>
<blockquote>
<p>把另外一个页面的所有内容拿过来一起输出。 所有的标签元素都包含进来。</p>
</blockquote>
<h3 id="taglib">taglib</h3>
<p>作用：用于引入标签库</p>
<p>语法：&lt;%@ taglib prefix=&quot;&quot;  uri=&quot;&quot;%&gt;</p>
<pre><code>uri: 标签库路径
prefix : 标签库的别名  
</code></pre>
<h2 id="七大jsp-动作标签">七大JSP 动作标签</h2>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdn.net/20160715152725431?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="七大动作标签"></figure>
<h3 id="jspinclude">jsp:include</h3>
<pre><code class="language-jsp">&lt;jsp:include page=&quot;other02.jsp&quot;&gt;&lt;/jsp:include&gt;
</code></pre>
<blockquote>
<p>包含指定的页面， 这里是动态包含。 也就是不把包含的页面所有元素标签全部拿过来输出，而是把它的运行结果拿过来。</p>
</blockquote>
<h3 id="jspforward">jsp:forward</h3>
<pre><code class="language-jsp">&lt;!-- 不带参数跳转 --&gt;
&lt;jsp:forward page=&quot;test.jsp&quot;&gt;&lt;/jsp:forward&gt;
&lt;jsp:forward page=&quot;test.jsp&quot; /&gt;

&lt;!-- 带参数跳转 --&gt;
&lt;!-- 中文参数会出现乱码，因为底层是通过URIEncoding来编码的，默认取的是request.getCharsetEncoding() , 要解决此乱码问题，我们需要再跳转前设置 request.setCharsetEncoding(&quot;UTF-8&quot;);
--&gt;
&lt;% request.setCharsetEncoding(&quot;UTF-8&quot;); %&gt;
&lt;jsp:forward page=&quot;test.jsp&quot;&gt;
	&lt;jsp:param name=&quot;sname&quot; value=&quot;zhangsan&quot; /&gt;
&lt;/jsp:forward&gt;

&lt;!-- 如果这样写，中间必须加上param子标签 --&gt;
&lt;jsp:forward page=&quot;test.jsp&quot;&gt;
&lt;/jsp:forward&gt;
</code></pre>
<blockquote>
<p>前往哪一个页面。</p>
</blockquote>
<h3 id="jspparam">jsp:param</h3>
<blockquote>
<p>意思是： 在包含某个页面的时候，或者在跳转某个页面的时候，加入这个参数。</p>
</blockquote>
<pre><code class="language-jsp">&lt;jsp:forward page=&quot;other02.jsp&quot;&gt;
  &lt;jsp:param value=&quot;beijing&quot; name=&quot;address&quot;/&gt;
&lt;/jsp:forward&gt;

在other02.jsp中获取参数

&lt;br&gt;收到的参数是：&lt;br&gt;

&lt;%= request.getParameter(&quot;address&quot;)%&gt;
</code></pre>
<h3 id="jspusebeanjspsetpropertyjspgetproperty">jsp:useBean&amp;jsp:setProperty&amp;jsp:getProperty</h3>
<p>这组动作标签用于实例化JavaBean，并且设置、获取属性</p>
<pre><code class="language-jsp">&lt;jsp:useBean id=&quot;stu&quot; class=&quot;com.lanou3g.demo.bean.Student&quot; /&gt;
&lt;jsp:setProperty name=&quot;stu&quot; property=&quot;sname&quot; value=&quot;张三&quot; /&gt;
&lt;jsp:getProperty property=&quot;sname&quot; name=&quot;stu&quot;/&gt;
</code></pre>
<h2 id="jsp九大内置对象">JSP九大内置对象</h2>
<blockquote>
<p>所谓内置对象，就是我们可以直接在jsp页面中使用这些对象。 不用创建。</p>
</blockquote>
<h3 id="pagecontext-javaxservletjsppagecontext">pageContext 【javax.servlet.jsp.PageContext】</h3>
<p>作用：为JSP页面包装页面的上下文。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>forward</td>
<td>重定向到另一页面或Servlet组件</td>
</tr>
<tr>
<td>getAttribute</td>
<td>获取某范围中指定名字的属性值</td>
</tr>
<tr>
<td>findAttribute</td>
<td>按范围搜索指定名字的属性</td>
</tr>
<tr>
<td>removeAttribute</td>
<td>删除某范围中指定名字的属性</td>
</tr>
<tr>
<td>setAttribute</td>
<td>设定某范围中指定名字的属性值</td>
</tr>
<tr>
<td>getException</td>
<td>返回当前异常对象</td>
</tr>
<tr>
<td>getRequest</td>
<td>返回当前请求对象</td>
</tr>
<tr>
<td>getResponse</td>
<td>返回当前响应对象</td>
</tr>
<tr>
<td>getServletConfig</td>
<td>返回当前页面的ServletConfig对象</td>
</tr>
<tr>
<td>getServletContext</td>
<td>返回所有页面共享的ServletContext对象</td>
</tr>
<tr>
<td>getSession</td>
<td>返回当前页面的会话对象</td>
</tr>
</tbody>
</table>
<h3 id="request-javaxservlethttphttpservletrequest">request   【javax.servlet.http.HttpServletRequest】</h3>
<p>作用：向服务端请求数据</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>isUserInRole</td>
<td>判断认证后的用户是否属于某一成员组</td>
</tr>
<tr>
<td>getAttribute</td>
<td>获取指定属性的值,如该属性值不存在返回Null</td>
</tr>
<tr>
<td>getAttributeNames</td>
<td>获取所有属性名的集合</td>
</tr>
<tr>
<td>getCookies</td>
<td>获取所有Cookie对象</td>
</tr>
<tr>
<td>getCharacterEncoding</td>
<td>获取请求的字符编码方式</td>
</tr>
<tr>
<td>getContentLength</td>
<td>返回请求正文的长度,如不确定返回-1</td>
</tr>
<tr>
<td>getHeader</td>
<td>获取指定名字报头值</td>
</tr>
<tr>
<td>getHeaders</td>
<td>获取指定名字报头的所有值,一个枚举</td>
</tr>
<tr>
<td>getHeaderNames</td>
<td>获取所有报头的名字,一个枚举</td>
</tr>
<tr>
<td>getInputStream</td>
<td>返回请求输入流,获取请求中的数据</td>
</tr>
<tr>
<td>getMethod</td>
<td>获取客户端向服务器端传送数据的方法</td>
</tr>
<tr>
<td>getParameter</td>
<td>获取指定名字参数值</td>
</tr>
<tr>
<td>getParameterNames</td>
<td>获取所有参数的名字,一个枚举</td>
</tr>
<tr>
<td>getParameterValues</td>
<td>获取指定名字参数的所有值</td>
</tr>
<tr>
<td>getProtocol</td>
<td>获取客户端向服务器端传送数据的协议名称</td>
</tr>
<tr>
<td>getQueryString</td>
<td>获取以get方法向服务器传送的查询字符串</td>
</tr>
<tr>
<td>getRequestURI</td>
<td>获取发出请求字符串的客户端地址</td>
</tr>
<tr>
<td>getRemoteAddr</td>
<td>获取客户端的IP地址</td>
</tr>
<tr>
<td>getRemoteHost</td>
<td>获取客户端的名字</td>
</tr>
<tr>
<td>getSession</td>
<td>获取和请求相关的会话</td>
</tr>
<tr>
<td>getServerName</td>
<td>获取服务器的名字</td>
</tr>
<tr>
<td>getServerPath</td>
<td>获取客户端请求文件的路径</td>
</tr>
<tr>
<td>getServerPort</td>
<td>获取服务器的端口号</td>
</tr>
<tr>
<td>removeAttribute</td>
<td>删除请求中的一个属性</td>
</tr>
<tr>
<td>setAttribute</td>
<td>设置指定名字参数值</td>
</tr>
</tbody>
</table>
<h3 id="session-javaxservlethttphttpsession">session   【javax.servlet.http.HttpSession】</h3>
<p>作用：用来保存每个用户的信息,以便跟踪每个用户的操作状态</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getAttribute</td>
<td>获取指定名字的属性</td>
</tr>
<tr>
<td>getAttributeNames</td>
<td>获取session中全部属性名字,一个枚举</td>
</tr>
<tr>
<td>getCreationTime</td>
<td>返回session的创建时间</td>
</tr>
<tr>
<td>getId</td>
<td>获取会话标识符</td>
</tr>
<tr>
<td>getLastAccessedTime</td>
<td>返回最后发送请求的时间</td>
</tr>
<tr>
<td>getMaxInactiveInterval</td>
<td>返回session对象的生存时间单位千分之一秒</td>
</tr>
<tr>
<td>invalidate</td>
<td>销毁session对象</td>
</tr>
<tr>
<td>isNew</td>
<td>每个请求是否会产生新的session对象</td>
</tr>
<tr>
<td>removeAttribute</td>
<td>删除指定名字的属性</td>
</tr>
<tr>
<td>setAttribute</td>
<td>设定指定名字的属性值</td>
</tr>
</tbody>
</table>
<h3 id="application-javaxservletservletcontext">application  【javax.servlet.ServletContext】</h3>
<p>作用：对应ServletContext对象， 在整个应用的生命周期内共享数据</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getAttribute</td>
<td>获取应用对象中指定名字的属性值</td>
</tr>
<tr>
<td>getAttributeNames</td>
<td>获取应用对象中所有属性的名字,一个枚举</td>
</tr>
<tr>
<td>getInitParameter</td>
<td>返回应用对象中指定名字的初始参数值</td>
</tr>
<tr>
<td>getServletInfo</td>
<td>返回Servlet编译器中当前版本信息</td>
</tr>
<tr>
<td>setAttribute</td>
<td>设置应用对象中指定名字的属性值</td>
</tr>
</tbody>
</table>
<h3 id="out-javaxservletjspjspwriter">out		 【javax.servlet.jsp.JspWriter】</h3>
<p>作用：向客户端输出数据</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>print或println</td>
<td>输出数据</td>
</tr>
<tr>
<td>newLine</td>
<td>输出换行字符</td>
</tr>
<tr>
<td>flush</td>
<td>输出缓冲区数据</td>
</tr>
<tr>
<td>close</td>
<td>关闭输出流</td>
</tr>
<tr>
<td>clear</td>
<td>清除缓冲区中数据,但不输出到客户端</td>
</tr>
<tr>
<td>clearBuffer</td>
<td>清除缓冲区中数据,输出到客户端</td>
</tr>
<tr>
<td>getBufferSize</td>
<td>获得缓冲区大小</td>
</tr>
<tr>
<td>getRemaining</td>
<td>获得缓冲区中没有被占用的空间</td>
</tr>
<tr>
<td>isAutoFlush</td>
<td>是否为自动输出</td>
</tr>
</tbody>
</table>
<h3 id="response-javaxservlethttphttpservletresponse">response  【javax.servlet.http.HttpServletResponse】</h3>
<p>作用：封装了jsp产生的响应,然后被发送到客户端以响应客户的请求</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>addCookie</td>
<td>添加一个Cookie对象</td>
</tr>
<tr>
<td>addHeader</td>
<td>添加Http文件指定名字头信息</td>
</tr>
<tr>
<td>containsHeader</td>
<td>判断指定名字Http文件头信息是否存在</td>
</tr>
<tr>
<td>encodeURL</td>
<td>使用sessionid封装URL</td>
</tr>
<tr>
<td>flushBuffer</td>
<td>强制把当前缓冲区内容发送到客户端</td>
</tr>
<tr>
<td>getBufferSize</td>
<td>返回缓冲区大小</td>
</tr>
<tr>
<td>getOutputStream</td>
<td>返回到客户端的输出流对象</td>
</tr>
<tr>
<td>sendError</td>
<td>向客户端发送错误信息</td>
</tr>
<tr>
<td>sendRedirect</td>
<td>把响应发送到另一个位置进行处理</td>
</tr>
<tr>
<td>setContentType</td>
<td>设置响应的MIME类型</td>
</tr>
<tr>
<td>setHeader</td>
<td>设置指定名字的Http文件头信息</td>
</tr>
</tbody>
</table>
<h3 id="exception-javalangthrowable">exception  【java.lang.Throwable】</h3>
<p>被调用的错误页面的结果,只有在错误页面中才可使用,</p>
<p>即在页面指令中设置:&lt;%@page isErrorPage=“true”%&gt;</p>
<h3 id="page-javalangobject">page	 【java.lang.Object】</h3>
<p>它代表JSP被编译成Servlet,可以使用它来调用Servlet类中所定义的方法</p>
<h3 id="config-javaxservletservletconfig">config 【javax.servlet.ServletConfig】</h3>
<p>作用：表示Servlet的配置,当一个Servlet初始化时,容器把某些信息通过此对象传递给这个Servlet</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getServletContext</td>
<td>返回所执行的Servlet的环境对象</td>
</tr>
<tr>
<td>getServletName</td>
<td>返回所执行的Servlet的名字</td>
</tr>
<tr>
<td>getInitParameter</td>
<td>返回指定名字的初始参数值</td>
</tr>
<tr>
<td>getInitParameterNames</td>
<td>返回该JSP中所有的初始参数名,一个枚举</td>
</tr>
</tbody>
</table>
<h2 id="四个作用域">四个作用域</h2>
<blockquote>
<p>表示这些对象可以存值，他们的取值范围有限定。  setAttribute   和  getAttribute</p>
</blockquote>
<h3 id="使用作用域来存储数据">使用作用域来存储数据</h3>
<pre><code class="language-jsp">&lt;%
pageContext.setAttribute(&quot;name&quot;, &quot;page&quot;);
request.setAttribute(&quot;name&quot;, &quot;request&quot;);
session.setAttribute(&quot;name&quot;, &quot;session&quot;);
application.setAttribute(&quot;name&quot;, &quot;application&quot;);
%&gt;
</code></pre>
<h3 id="取出四个作用域中的值">取出四个作用域中的值</h3>
<pre><code class="language-jsp">&lt;%=pageContext.getAttribute(&quot;name&quot;)%&gt;
&lt;%=request.getAttribute(&quot;name&quot;)%&gt;
&lt;%=session.getAttribute(&quot;name&quot;)%&gt;
&lt;%=application.getAttribute(&quot;name&quot;)%&gt;
</code></pre>
<p>作用域范围大小：</p>
<blockquote>
<p>pageContext -- request --- session -- application</p>
</blockquote>
<h3 id="四个作用域的区别">四个作用域的区别</h3>
<ul>
<li>pageContext 【PageContext】</li>
</ul>
<blockquote>
<p>作用域仅限于当前的页面。</p>
<p>除了可以存储数据， 还可以获取其他8个内置对象</p>
</blockquote>
<ul>
<li>request 【HttpServletRequest】</li>
</ul>
<blockquote>
<p>作用域仅限于一次请求， 只要服务器对该请求做出了响应。 这个域中存的值就没有了。</p>
</blockquote>
<ul>
<li>session 【HttpSession】</li>
</ul>
<blockquote>
<p>作用域限于一次会话（多次请求与响应） 当中。</p>
</blockquote>
<ul>
<li>application 【ServletContext】</li>
</ul>
<blockquote>
<p>整个工程都可以访问， 服务器关闭后就不能访问了。</p>
</blockquote>
<h2 id="el表达式">EL表达式</h2>
<blockquote>
<p>是为了简化咱们的jsp代码，具体一点就是为了简化在jsp里面写的那些java代码。</p>
</blockquote>
<ul>
<li>
<p>语法结构</p>
<p>${expression }</p>
</li>
<li>
<p>从指定的作用域取参数</p>
<p>${requestScope.表达式}</p>
</li>
</ul>
<blockquote>
<p>如果从作用域中取值，会先从小的作用域开始取，如果没有，就往下一个作用域取。  一直把四个作用域取完都没有， 就没有显示。</p>
</blockquote>
<h3 id="如何使用">如何使用</h3>
<ol>
<li>取出4个作用域中存放的值。</li>
</ol>
<pre><code class="language-jsp">&lt;%
pageContext.setAttribute(&quot;name&quot;, &quot;page&quot;);
request.setAttribute(&quot;name&quot;, &quot;request&quot;);
session.setAttribute(&quot;name&quot;, &quot;session&quot;);
application.setAttribute(&quot;name&quot;, &quot;application&quot;);
%&gt;

按普通手段取值&lt;br&gt;

&lt;%= pageContext.getAttribute(&quot;name&quot;)%&gt;
&lt;%= request.getAttribute(&quot;name&quot;)%&gt;
&lt;%= session.getAttribute(&quot;name&quot;)%&gt;
&lt;%= application.getAttribute(&quot;name&quot;)%&gt;

&lt;br&gt;使用EL表达式取出作用域中的值&lt;br&gt;

${ pageScope.name }
${ requestScope.name }
${ sessionScope.name }
${ applicationScope.name }
</code></pre>
<ol start="2">
<li>如果域中所存的是数组</li>
</ol>
<pre><code class="language-jsp">&lt;%
String [] a = {&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;};
pageContext.setAttribute(&quot;array&quot;, a);
%&gt;
      		
使用EL表达式取出作用域中数组的值&lt;br&gt;

${array[0] } , ${array[1] },${array[2] },${array[3] }
</code></pre>
<ol start="3">
<li>如果域中锁存的是集合</li>
</ol>
<pre><code class="language-jsp">&lt;%
List&lt;String&gt; list =  new ArrayList&lt;&gt;();
list.add(&quot;aa&quot;);
list.add(&quot;bb&quot;);
list.add(&quot;cc&quot;);
list.add(&quot;dd&quot;);

pageContext.setAttribute(&quot;li&quot;, list);
%&gt;
使用EL表达式取出作用域中集合的值&lt;br&gt;

${list[0] } , ${li[1] },${li[2] },${li[3] }

</code></pre>
<ol start="4">
<li>取出Map集合的值</li>
</ol>
<pre><code class="language-java">&lt;%
Map map = new HashMap();
map.put(&quot;name&quot;, &quot;zhangsna&quot;);
map.put(&quot;age&quot;,18);
map.put(&quot;address&quot;,&quot;北京..&quot;);

map.put(&quot;address.aa&quot;,&quot;深圳..&quot;);

pageContext.setAttribute(&quot;map&quot;, map);
%&gt;
使用EL表达式取出作用域中Map的值&lt;br&gt;

&lt;!-- map的key中有特殊字符时，我们必须用[]这种方式来获取值 --&gt;
${map.name } , ${map.age } , ${map.address }  , ${map[&quot;address.aa&quot;] }
</code></pre>
<h2 id="el表达式-的11个内置对象">EL表达式 的11个内置对象。</h2>
<p>${ 对象名.成员 }</p>
<ul>
<li>pageContext</li>
</ul>
<p>作用域相关对象</p>
<ul>
<li>pageScope</li>
<li>requestScope</li>
<li>sessionScope</li>
<li>applicationScope</li>
</ul>
<p>头信息相关对象</p>
<ul>
<li>header</li>
<li>headerValues</li>
</ul>
<p>参数信息相关对象</p>
<ul>
<li>
<p>param</p>
</li>
<li>
<p>paramValues</p>
</li>
<li>
<p>cookie</p>
</li>
</ul>
<p>全局初始化参数</p>
<ul>
<li>initParam</li>
</ul>
<h2 id="jstl">JSTL</h2>
<blockquote>
<p>全称 ： JSP Standard Tag Library  jsp标准标签库</p>
</blockquote>
<blockquote>
<p>简化jsp的代码编写。 替换 &lt;%%&gt; 写法。 一般与EL表达式配合</p>
</blockquote>
<h3 id="怎么使用">怎么使用</h3>
<ol>
<li>
<p>导入jar文件到工程的WebContent/Web-Inf/lib  jstl.jar standard.jar</p>
</li>
<li>
<p>在jsp页面上，使用taglib 指令，来引入标签库</p>
</li>
</ol>
<blockquote>
<p>比如引入JSTL核心标签库</p>
</blockquote>
<pre><code class="language-jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
</code></pre>
<ol start="3">
<li>注意： 如果想支持 EL表达式，那么引入的标签库必须选择1.1以上的版本，1.0的版本不支持EL表达式。</li>
</ol>
<h3 id="jstl标签分类">JSTL标签分类</h3>
<h4 id="核心标签最核心-最重用">核心标签(最核心、最重用)</h4>
<pre><code class="language-jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
</code></pre>
<ul>
<li>
<p>表达式控制标签</p>
<ul>
<li>out</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>输出值，如果是常量直接赋值， 如果是变量需要通过EL表达式取值</td>
<td>是</td>
</tr>
<tr>
<td>default</td>
<td>当value为null时， 输出default属性配置的值</td>
<td>否</td>
</tr>
<tr>
<td>escapeXml</td>
<td>是否转义XML特殊字符，取值true/false， 默认是true</td>
<td>否</td>
</tr>
</tbody>
</table>
<ul>
<li>set</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>搭配var属性使用，设置变量的值；搭配property和target使用，设置javabean属性的值</td>
<td>是</td>
</tr>
<tr>
<td>var</td>
<td>定义的变量名称</td>
<td>否</td>
</tr>
<tr>
<td>scope</td>
<td>变量保存到的作用域，默认是pageContext</td>
<td>否</td>
</tr>
<tr>
<td>target</td>
<td>给javabean设置属性，指定那个javabean。需配合&lt;jsp:useBean&gt;标签和property、value属性使用</td>
<td>否</td>
</tr>
<tr>
<td>property</td>
<td>设置javabean的哪个属性的值</td>
<td>否</td>
</tr>
</tbody>
</table>
<ul>
<li>remove</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>var</td>
<td>删除指定的变量，只能删除变量，不能删除javabean的属性</td>
<td>是</td>
</tr>
</tbody>
</table>
<ul>
<li>catch</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>var</td>
<td>存储错误信息</td>
<td>是</td>
</tr>
</tbody>
</table>
<pre><code class="language-jsp">&lt;%-- &lt;c:catch&gt;用于包裹其他容易出错的标签，比如 --%&gt;
&lt;c:catch var=&quot;error&quot;&gt;
  &lt;!-- aa为没有实例化的javabean --&gt;
	&lt;c:set target=&quot;aa&quot; property=&quot;name&quot; value=&quot;zhangsan&quot; /&gt;
&lt;/c:catch&gt;
&lt;c:out value=&quot;${error}&quot; /&gt;
</code></pre>
</li>
<li>
<p>流程控制标签</p>
<ul>
<li>if</li>
</ul>
<pre><code class="language-jsp">&lt;c:if test=&quot;${income &gt; 8000}&quot; var=&quot;ret&quot;&gt;  
  &lt;p&gt;My income is: &lt;c:out value=&quot;${income}&quot;/&gt;&lt;p&gt;  
&lt;/c:if&gt;
&lt;!-- var属性ret存储的是test运算的结果 --&gt;
${ret}
</code></pre>
<ul>
<li>choose&amp;when&amp;otherwise</li>
</ul>
<pre><code class="language-jsp">&lt;c:choose&gt;  
    &lt;c:when test=&quot;${income &lt;= 1000}&quot;&gt;  
       Income is not good.  
    &lt;/c:when&gt;  
    &lt;c:when test=&quot;${income &gt; 10000}&quot;&gt;  
        Income is very good.  
    &lt;/c:when&gt;  
    &lt;c:otherwise&gt;  
       Income is undetermined...  
    &lt;/c:otherwise&gt;  
&lt;/c:choose&gt;  
</code></pre>
<ul>
<li>forEach</li>
</ul>
<pre><code class="language-jsp">&lt;%
 List&lt;String&gt; students = new ArrayList&lt;&gt;();
 students.add(&quot;张三&quot;);
 students.add(&quot;李四&quot;);
 students.add(&quot;王五&quot;);
 students.add(&quot;赵六&quot;);
 
 request.setAttribute(&quot;stus&quot;, students);
%&gt;

&lt;!-- forEach遍历全部元素 --&gt;
&lt;c:forEach var=&quot;stu&quot; items=&quot;${stus}&quot;&gt;
	&lt;c:out value=&quot;${stu}&quot; /&gt; &lt;br /&gt;
&lt;/c:forEach&gt;

&lt;!-- forEach遍历部分元素 --&gt;
&lt;c:forEach var=&quot;stu&quot; items=&quot;${stus}&quot; begin=&quot;1&quot; end=&quot;3&quot;&gt;
	&lt;c:out value=&quot;${stu}&quot; /&gt; &lt;br /&gt;
&lt;/c:forEach&gt;

&lt;!-- forEach遍历部分元素，指定步长 --&gt;
&lt;c:forEach var=&quot;stu&quot; items=&quot;${stus}&quot; begin=&quot;1&quot; step=&quot;2&quot;&gt;
	&lt;c:out value=&quot;${stu}&quot; /&gt; &lt;br /&gt;
&lt;/c:forEach&gt;

&lt;!-- 用法四：部分遍历并带状态 --&gt;
&lt;c:forEach var=&quot;stu&quot; items=&quot;${stus}&quot; begin=&quot;1&quot; end=&quot;3&quot; varStatus=&quot;status&quot;&gt;
&lt;c:out value=&quot;${stu}——四个属性：&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value=&quot;index属性：${status.index}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value=&quot;count属性：${status.count}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value=&quot;first属性：${status.first}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value=&quot;last属性：${status.last}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value=&quot;----------&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;/c:forEach&gt;

&lt;!-- varStatus变量的几个属性：index从0开始；count从1开始；first是否第一个（boolean）；last是否最后一个（boolean）。  --&gt;

</code></pre>
<ul>
<li>forTokens</li>
</ul>
<pre><code class="language-jsp">&lt;c:forTokens items=&quot;zhangsan,lisi,wangwu&quot; delims=&quot;,&quot; var=&quot;item&quot;&gt;
	&lt;c:out value=&quot;${item}&quot; /&gt; &lt;br /&gt;
&lt;/c:forTokens&gt;

&lt;!-- 另外forTokens也支持begin、end、step、varStatus几个属性，用法和forEach一样 --&gt;
</code></pre>
</li>
<li>
<p>URL操作标签</p>
<ul>
<li>url</li>
</ul>
<pre><code class="language-jsp"> &lt;c:url value=&quot;http://localhost:8080/Test/index.jsp&quot; var=&quot;newUrl&quot; scope=&quot;session&quot;&gt;
 		&lt;c:param name=&quot;username&quot;&gt;zhangsan&lt;/c:param&gt;
  		&lt;c:param name=&quot;password&quot;&gt;a123456&lt;/c:param&gt;
 &lt;/c:url&gt;
	&lt;a href=&quot;${newUrl}&quot;&gt;New URL&lt;/a&gt;
</code></pre>
<ul>
<li>redirect</li>
</ul>
<pre><code class="language-jsp">  	&lt;c:redirect url=&quot;www.baidu.com&quot;&gt;
  		&lt;c:param name=&quot;username&quot;&gt;zhangsan&lt;/c:param&gt;
  		&lt;c:param name=&quot;password&quot;&gt;a123456&lt;/c:param&gt;
  	&lt;/c:redirect&gt;
</code></pre>
<ul>
<li>param</li>
</ul>
<p>一般作为其他标签的子标签使用，为其附加参数</p>
</li>
</ul>
<h4 id="格式化标签">格式化标签</h4>
<pre><code class="language-jsp">&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;
</code></pre>
<ul>
<li>格式化时间</li>
</ul>
<pre><code class="language-jsp">&lt;%
	Date date = new Date();
	pageContext.setAttribute(&quot;d&quot;, date);
%&gt;
&lt;fmt:formatDate value=&quot;${d }&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;
</code></pre>
<ul>
<li>格式化数字</li>
</ul>
<pre><code class="language-jsp">&lt;%
	double d1 = 3.5;
	double d2 = 4.4; 
	pageContext.setAttribute(&quot;d1&quot;, d1);
	pageContext.setAttribute(&quot;d2&quot;, d2);
%&gt;
&lt;fmt:formatNumber value=&quot;${d1 }&quot; pattern=&quot;0.00&quot;/&gt;&lt;br/&gt;
&lt;fmt:formatNumber value=&quot;${d2 }&quot; pattern=&quot;#.##&quot;/&gt;
</code></pre>
<h4 id="sql标签">SQL标签</h4>
<pre><code class="language-jsp">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/sql&quot; prefix=&quot;sql&quot;%&gt;  
</code></pre>
<ul>
<li>setDataSource</li>
</ul>
<pre><code class="language-jsp">&lt;sql:setDataSource var=&quot;db&quot; driver=&quot;com.mysql.jdbc.Driver&quot;  
     url=&quot;jdbc:mysql://localhost/test&quot;  
     user=&quot;root&quot;  password=&quot;1234&quot;/&gt;  
</code></pre>
<ul>
<li>query</li>
</ul>
<pre><code class="language-jsp">&lt;sql:query dataSource=&quot;${db}&quot; var=&quot;rs&quot;&gt;  
SELECT * from Students;  
&lt;/sql:query&gt;  
</code></pre>
<ul>
<li>update</li>
</ul>
<pre><code class="language-jsp">&lt;sql:update dataSource=&quot;${db}&quot; var=&quot;count&quot;&gt;  
INSERT INTO Students VALUES (154,'Nasreen', 'jaha', 25);  
&lt;/sql:update&gt;  
</code></pre>
<ul>
<li>param &amp; dateParam</li>
</ul>
<pre><code class="language-jsp">&lt;%
Date DoB = new Date(&quot;2000/10/16&quot;);
int studentId = 151;
%&gt;
&lt;sql:update dataSource=&quot;${db}&quot; var=&quot;count&quot;&gt;
   UPDATE Student SET dob = ? WHERE Id = ?
   &lt;sql:dateParam value=&quot;&lt;%=DoB%&gt;&quot; type=&quot;DATE&quot; /&gt;
   &lt;sql:param value=&quot;&lt;%=studentId%&gt;&quot; /&gt;
&lt;/sql:update&gt;

</code></pre>
<ul>
<li>transaction</li>
</ul>
<pre><code class="language-jsp">&lt;sql:transaction dataSource=&quot;${db}&quot;&gt;  
   &lt;sql:update var=&quot;count&quot;&gt;  
      UPDATE Student SET First_Name = 'Suraj' WHERE Id = 150  
   &lt;/sql:update&gt;  
   &lt;sql:update var=&quot;count&quot;&gt;  
      UPDATE Student SET Last_Name= 'Saifi' WHERE Id = 153  
   &lt;/sql:update&gt;  
   &lt;sql:update var=&quot;count&quot;&gt;  
     INSERT INTO Student   
     VALUES (154,'Supriya', 'Jaiswal', '1995/10/6');  
   &lt;/sql:update&gt;  
&lt;/sql:transaction&gt;  
</code></pre>
<h4 id="xml标签">XML标签</h4>
<p>用的不多，这里不在列举</p>
<p>ps: 更多详细内容，参见：<a href="https://www.javatpoint.com/jstl">https://www.javatpoint.com/jstl</a></p>
<h2 id="总结">总结：</h2>
<ul>
<li>
<p>JSP</p>
<p>三大指令</p>
<pre><code>  	page
  	include
  	taglib
  
  六个动作标签
  	&lt;jsp:include&gt;
  	&lt;jsp:forward&gt;
  	&lt;jsp:param&gt;
</code></pre>
<p>​		jsp:useBean</p>
<p>​		jsp:setProperty</p>
<p>​		jsp:getProperty</p>
<p>九个内置对象</p>
<pre><code>  四个作用域
  	pageContext
  	request
  	session
  	application

  out
  exception
  response
  page
  config
</code></pre>
</li>
</ul>
<p>​</p>
<ul>
<li>
<p>EL</p>
<p>${ 表达式 }</p>
<p>取4个作用域中的值</p>
<p>${ name }</p>
<p>有11个内置对象。</p>
<p>pageContext</p>
<p>pageScope<br>
requestScope<br>
sessionScope<br>
applicationScope</p>
<p>header<br>
headerValues</p>
<p>param<br>
paramValues</p>
<p>cookie<br>
initParam</p>
</li>
<li>
<p>JSTL</p>
</li>
</ul>
<blockquote>
<p>使用1.1的版本， 支持EL表达式， 1.0不支持EL表达式</p>
</blockquote>
<blockquote>
<p>拷贝jar包， 通过taglib 去引入标签库</p>
</blockquote>
<pre><code>&lt;c:set&gt;
&lt;c:if&gt;
&lt;c:forEach&gt;
</code></pre>
<p>​</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据分页]]></title>
        <id>https://ysjhhhhhhh.github.io/post/shu-ju-fen-ye</id>
        <link href="https://ysjhhhhhhh.github.io/post/shu-ju-fen-ye">
        </link>
        <updated>2018-03-25T12:35:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="核心参数">核心参数</h2>
<ul>
<li>总数据条数
<ul>
<li>来源： 后台自己从数据库中查询而来</li>
</ul>
</li>
<li>每页展示条数(pageSize)
<ul>
<li>来源：从前端页面传递过来</li>
</ul>
</li>
<li>总页数（计算得知）
<ul>
<li>来源： 根据总条数和每页展示数量计算得来</li>
</ul>
</li>
<li>当前展示的页码（currentPage)
<ul>
<li>来源：从前端页面传递过来</li>
</ul>
</li>
<li>每页要展示的数据本身
<ul>
<li>来源：后台自己从数据库中查询而来</li>
</ul>
</li>
</ul>
<h2 id="物理分页">物理分页</h2>
<h3 id="概述">概述</h3>
<p>所谓的物理分页其实就是直接通过数据库来实现返回一部分数据。每次只从数据库中查询一页的数据。与之相对应的还有逻辑分页。</p>
<h3 id="mysql中实现语句">Mysql中实现语句</h3>
<pre><code class="language-sql">    SELECT * FROM `shop` LIMIT (currentPage-1)*pageSize, pageSize;
</code></pre>
<h2 id="逻辑分页">逻辑分页</h2>
<p>所谓的逻辑分页其实就是通过内存来进行分页。具体来说，首次查询数据时，将所有数据都取出放到内存中，展示其他页的数据时，在内存中实现数据的截取，展示。</p>
<h2 id="两种分页的对比">两种分页的对比</h2>
<ol>
<li>物理分页节约内存空间，效率相比逻辑分页理论上效率低一些。试用场景：数据量大的时候。</li>
<li>逻辑分页占用空间大，理论上分页性能高一些。试用场景：数据量小，访问用户多。要处理缓存数据同步的问题。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Apache Tomcat下载、安装、配置]]></title>
        <id>https://ysjhhhhhhh.github.io/post/apache-tomcat-xia-zai-an-zhuang-pei-zhi</id>
        <link href="https://ysjhhhhhhh.github.io/post/apache-tomcat-xia-zai-an-zhuang-pei-zhi">
        </link>
        <updated>2018-03-21T02:32:15.000Z</updated>
        <content type="html"><![CDATA[<p>Apache Tomcat下载、安装、配置图文教程自我心得<br>
1、Tomcat下载<br>
（1）Tomcat官网：<a href="http://tomcat.apache.org/">Tomcat官方网址</a>，可以在此处下载Tomcat。<br>
（2）点击左侧Download下的对应版本。<br>
注意有zip和exe两种格式的，zip是免安装版的，exe是安装版。同时观察自己的电脑是64位系统还是32位系统。<br>
例如进入：<a href="http://tomcat.apache.org/download-90.cgi">Tomcat 9 版本下载页面</a>，下滑，到core处选择自己需要的版本，如图所示：<br>
<img src="https://img-blog.csdn.net/20170227190709370?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>我的电脑是64位，可以直接选择32-bit/64-bit Windows Service installer(pgp,md5,sha1)，点击即可选择下载位置，点击下载，此处选择下载的是exe安装版本。若想下载免安装版本的，选择下载64-bit Windows zip(pgp,md5,sha1)。<br>
2、Tomcat安装<br>
2.1 exe版本安装<br>
1、从下载位置双击下载的zip<br>
<img src="https://img-blog.csdn.net/20170227220255334?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>点击next；<br>
2、同意安装协议：即点击I Agree<br>
<img src="https://img-blog.csdn.net/20170227220536666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>3、点开Tomcat，选中Service，以后将可以在管理的服务中启动和关闭Tomcat（也可以默认，不改变配置），点击next<br>
<img src="https://img-blog.csdn.net/20170227220858858?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>4、出现管理提示框，要求输入端口和管理密码，保持默认设置就行。默认的端口号就是8080，这里一般不用设置。点击Next。<br>
<img src="https://img-blog.csdn.net/20170227221248471?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>5、点击Next后会出现下图，它会自动找到JRE位置，如果用户没有安装JRE，可以修改指向JDK目录（很多用户安装后无法编译JSP，就是这里没找到JRE，请务必先要安装JDK，并把这个目录正确指向JRE或者JDK的目录）。<br>
<img src="https://img-blog.csdn.net/20170227221856106?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>6、点击next，之后会出现Tomcat安装路径选择，一般默认安装到C盘，可以直接把C改成D，没有的文件夹会自动创建。修改完毕后点击Install。<br>
<img src="https://img-blog.csdn.net/20170227222133335?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>7、安装完毕，点击finish。<br>
<img src="https://img-blog.csdn.net/20170227222413424?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>8、打开浏览器 键入 <a href="http://localhost:8080/">http://localhost:8080</a> 进入如下页面则表示安装成功：<br>
<img src="https://img-blog.csdn.net/20170227222804476?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>2.2 zip版（免安装版本）<br>
直接解压缩，找到目录bin下的startup.bat，启动Tomcat；shutdown.bat：关闭Tomcat。<br>
3、Tomcat配置<br>
配置Tomcat之前要保证jdk已经配置完成。<br>
右击，计算机——属性——高级系统设置——打开环境变量的配置窗口，在系统环境变量一栏点击新建。变量名为TOMCAT_HOME，变量值为Tomcat安装目录，此处为：D:\Program Files (x86)\Apache Software Foundation\Tomcat 9.0。点击确定即可。<br>
在另外一篇博客中这样介绍Tomcat配置过程：<br>
Tomcat环境变量配置：<br>
如果你的Tomcat安装在C盘里，如：C:\Program Files\Apache Software Foundation\Tomcat 8.0（在这里切记一下，安装Tomcat时，在其字母周围一定不要存在空格，否则最后可能导致配置不成功）<br>
同样，在系统变量里点新建：<br>
变量名：CATALINA_BASE<br>
变量值：C:\Program Files\Apache Software Foundation\Tomcat 8.0;<br>
再次新建：<br>
变量名：CATALINA_HOME<br>
变量值：C:\Program Files\Apache Software Foundation\Tomcat 8.0;<br>
点击确定后在classpath中加入%CATALINA_HOME%\common\lib\servlet-api.jar;（注意加的时候在原变量值后加英文状态下的“；”）<br>
在path中加入%CATALINA_HOME%\bin;（注意加的时候在原变量值后加英文状态下的“；”）<br>
确定后你的Tomcat就配置好了，同样要验证是否配置成功，那就运行Tomcat,点击启动（或Start service）后，打开浏览器，敲入<a href="http://localhost:8080/">http://localhost:8080</a>,如果出现页面，那么配置成功。</p>
]]></content>
    </entry>
</feed>