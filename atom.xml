<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ysjhhhhhhh.github.io</id>
    <title>Gridea</title>
    <updated>2019-12-12T08:20:16.932Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ysjhhhhhhh.github.io"/>
    <link rel="self" href="https://ysjhhhhhhh.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://ysjhhhhhhh.github.io/images/avatar.png</logo>
    <icon>https://ysjhhhhhhh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[SpringMVC]]></title>
        <id>https://ysjhhhhhhh.github.io/post/springmvc</id>
        <link href="https://ysjhhhhhhh.github.io/post/springmvc">
        </link>
        <updated>2018-04-30T13:07:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="springmvc">SpringMVC</h1>
<h2 id="springmvc-2">SpringMVC</h2>
<h3 id="什么是springmvc">什么是SpringMVC</h3>
<blockquote>
<p>SpringMVC是一种基于Java的实现MVC设计模式的请求驱动类型的轻量级Web框架，使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发。</p>
</blockquote>
<h3 id="springmvc的优点">SpringMVC的优点</h3>
<blockquote>
<p>1.简单、容易上手；<br>
2.性能优异：jsp+servlet&gt;Struts=SpringMVC&gt;Struts2；<br>
3.灵活、易于扩展；<br>
4.易于和Spring容器整合；</p>
</blockquote>
<h3 id="springmvc依赖">SpringMVC依赖</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="springmvc配置文件">SpringMVC配置文件</h3>
<h4 id="servletwebapplicationcontextxml-和-rootwebapplicationcontextxml">ServletWebApplicationContext.xml 和 RootWebApplicationContext.xml</h4>
<figure data-type="image" tabindex="1"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/mvc-context-hierarchy.png" alt=""></figure>
<blockquote>
<p>dispatcher-servlet.xml 要比 applicationContext.xml后初始化，因此在dispatcher-servlet.xml中可以引用applicationContext.xml中配置的bean，反之不行</p>
</blockquote>
<h4 id="dispatcher-servlet">Dispatcher-servlet</h4>
<blockquote>
<p>DispatcherServlet是前置控制器，配置在web.xml文件中的。拦截匹配的请求，Servlet拦截匹配规则要自己定义，把拦截下来的请求，依据相应的规则分发到目标Controller来处理，是配置spring MVC的第一步。</p>
<p>DispatcherServlet是前端控制器设计模式的实现，提供Spring Web MVC的集中访问点，而且负责职责的分派，而且与Spring IoC容器无缝集成，从而可以获得Spring的所有好处。</p>
</blockquote>
<h3 id="springmvc中的组件">SpringMVC中的组件</h3>
<h4 id="视图解析器">视图解析器</h4>
<p>作用：将controller中方法的返回值解析成一个页面</p>
<p>配置视图解析器的方法：</p>
<p>(在dispatcher-servlet.xml中加入)</p>
<pre><code class="language-xml">&lt;mvc:view-resolvers&gt;
        &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
            &lt;!-- 将返回的字符串的前面拼上‘/’ --&gt;
            &lt;property name=&quot;prefix&quot; value=&quot;/&quot;/&gt;
            &lt;!-- 将返回的字符串的前面拼上‘.jsp’ --&gt;
            &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
        &lt;/bean&gt;
&lt;/mvc:view-resolvers&gt;
</code></pre>
<h4 id="参数传递">参数传递</h4>
<p>Controller中接收页面传递的数据通过：</p>
<blockquote>
<h5 id="requestparam请求参数">@RequestParam	请求参数</h5>
<h5 id="requestheader请求头参数">@RequestHeader	请求头参数</h5>
<h5 id="requestattributerequest作用域参数">@RequestAttribute	request作用域参数</h5>
<h5 id="sessionattributesession作用域参数">@SessionAttribute	session作用域参数</h5>
<h5 id="cookievaluecookie中的数据">@CookieValue	cookie中的数据</h5>
</blockquote>
<pre><code class="language-java">//自动绑定到对象上
    @RequestMapping(&quot;/student&quot;)
    public String tostu(Student student, Model model){
        model.addAttribute(&quot;student&quot;,student);
        return &quot;student&quot;;
    }

    //获取请求头中的参数
    @RequestMapping(&quot;/reqparam&quot;)
    public String toreqparam(@RequestHeader(&quot;user-agent&quot;) String userAgent, Model model){
        model.addAttribute(&quot;tou&quot;,userAgent);
        return &quot;reqparam&quot;;
    }

    //获取cookie中的数据
    @RequestMapping(&quot;/tocookie&quot;)
    public String tocookie(@CookieValue(&quot;JSESSIONID&quot;) String JSESSIONID, Model model){
        model.addAttribute(&quot;cookieinfo&quot;,JSESSIONID);
        return &quot;cookie&quot;;
    }
</code></pre>
<p>从controller中向页面传递数据</p>
<p>Model</p>
<pre><code class="language-java">//获取Model然后将参数添加进Model中传递到前端
    @RequestMapping(&quot;/reqparam&quot;)
    public String toreqparam(@RequestHeader(&quot;user-agent&quot;) String userAgent, Model model){
        model.addAttribute(&quot;tou&quot;,userAgent);
        return &quot;reqparam&quot;;
    }
</code></pre>
<p>ModelAndView</p>
<pre><code class="language-java">//使用ModelAndView，如：
@RequestMapping(&quot;/userLogin&quot;)
    public ModelAndView userLogin(@RequestParam String username, @RequestParam String password, ModelMap model, HttpSession session){

        ModelAndView mav;

        User user = userService.UserLogin(username, password);

        if (user==null){
            model.addAttribute(&quot;errorInfo&quot;,&quot;登录失败，账号或密码错误!&quot;);

            mav = new ModelAndView(&quot;forward:login.jsp&quot;,model);


            return mav;
        }else{
            UserAndRole userAndRole = userService.selectUserAndRoleById(user.getId());
            List&lt;Menu&gt; menuListByRoleName = userService.getMenuListByRoleName(userAndRole.getRoleName());
            session.setAttribute(&quot;userId&quot;,user.getId());
            session.setAttribute(&quot;userName&quot;,user.getUserName());
            session.setAttribute(&quot;roleName&quot;,userAndRole.getRoleName());
            session.setAttribute(&quot;menuList&quot;,menuListByRoleName);
            session.setAttribute(&quot;user&quot;,user);


            mav = new ModelAndView(&quot;index&quot;).addAllObjects(model);
        return mav;

        }

    }
</code></pre>
<h4 id="视图控制器">视图控制器</h4>
<p>作用：</p>
<blockquote>
<p>当在使用springmvc时，且想要进入某个页面不经过controller时，可以使用视图控制器来进行页面访问。</p>
</blockquote>
<p>用法</p>
<p>在dispatcher-servlet.xml中配置视图控制器</p>
<pre><code class="language-xml">&lt;!-- path是拦截的请求路径，view-name是进入的页面 --&gt;
&lt;mvc:view-controller path=&quot;&quot; view-name=&quot;&quot;/&gt;
</code></pre>
<h4 id="处理静态资源">处理静态资源</h4>
<p>由于dispatcher-servlet会拦截除jsp外的所有请求，因此对静态资源的访问也会被拦截，此时我们就需要配置静态资源放行，来放行对应的静态资源。放行静态资源的方法为：</p>
<pre><code class="language-xml">&lt;!--  在dispatcher-servlet.xml中配置以下标签放行静态资源 --&gt;
&lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/static/&quot;/&gt;
</code></pre>
<h4 id="springmvc中请求重定向和请求转发">SpringMVC中请求重定向和请求转发</h4>
<p>在controller中重定向的方法</p>
<pre><code class="language-java">@RequestMapping(&quot;/aaa&quot;)
    public String aaa(@RequestParam Integer userId, @RequestParam Integer permissionStatus, HttpServletResponse resp) throws IOException {

        //重定向
        return &quot;redirect:login.jsp&quot;

    }
</code></pre>
<p>在controller中请求转发的方法</p>
<pre><code class="language-java">@RequestMapping(&quot;/bbb&quot;)
    public String bbb(@RequestParam Integer userId, @RequestParam Integer permissionStatus, HttpServletResponse resp) throws IOException {

        //重定向
        return &quot;forward:login.jsp&quot;

    }
</code></pre>
<p>注意：</p>
<blockquote>
<p>通过加redirect 和 forward 请求转发和重定向 不会经过视图解析器 ，因此需要加入.jsp之类的后缀</p>
</blockquote>
<h3 id="处理springmvc中的乱码">处理SpringMVC中的乱码</h3>
<p>在web.xml中配置SpringMVC中带的处理字符乱码的filter</p>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;encoding&lt;/param-name&gt;
      &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
</code></pre>
<h3 id="高级请求映射">高级请求映射</h3>
<h4 id="匹配请求地址上的参数">匹配请求地址上的参数</h4>
<pre><code class="language-java">@RequestMapping(&quot;/hello/01/{info}&quot;)
    public String hello001(@PathVariable String info, Model model){

        model.addAttribute(&quot;info&quot;, info);

        return &quot;info&quot;;
    }
</code></pre>
<h4 id="匹配以helloaaa开头的可以匹配零个或多个字符">匹配以/hello/aaa/开头的(*可以匹配零个或多个字符)</h4>
<pre><code class="language-java">@RequestMapping(&quot;/hello/aaa/*&quot;)
    public String hello003(Model model){

        model.addAttribute(&quot;info&quot;, &quot;匹配到*的&quot;);

        return &quot;info&quot;;
    }
</code></pre>
<h4 id="匹配到以helloaaa开头的只能匹配一个字符">匹配到以/hello/aaa/开头的（？只能匹配一个字符）</h4>
<pre><code class="language-java">@RequestMapping(&quot;/hello/aaa/?&quot;)
    public String hello002(Model model){

        model.addAttribute(&quot;info&quot;, &quot;匹配到？的&quot;);

        return &quot;info&quot;;
    }
</code></pre>
<h4 id="匹配到以helloaaa开头的可以匹配多个路径">匹配到以/hello/aaa/开头的（**可以匹配多个路径）</h4>
<pre><code class="language-java">@RequestMapping(&quot;/hello/aaa/**&quot;)
    public String hello004(Model model){

        model.addAttribute(&quot;info&quot;, &quot;匹配到**的&quot;);

        return &quot;info&quot;;
    }
</code></pre>
<h4 id="根据正则表达式匹配并且可以获取其中的参数">根据正则表达式匹配，并且可以获取其中的参数</h4>
<pre><code class="language-java">@RequestMapping(&quot;/hello/aaa/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}&quot;)
public String hello005(@PathVariable String name,@PathVariable String version,@PathVariable String ext,Model model){    
    model.addAttribute(&quot;info&quot;, name+version+ext);    
    return &quot;info&quot;;
}
</code></pre>
<h3 id="文件上传">文件上传</h3>
<h4 id="25方式">2.5方式</h4>
<ol>
<li>导包</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
      &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
      &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
      &lt;version&gt;1.4&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;commons-io&lt;/groupId&gt;
      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
      &lt;version&gt;2.6&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>配置bean</li>
</ol>
<pre><code class="language-xml">&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;/&gt;
</code></pre>
<h4 id="30方式">3.0方式</h4>
<ol>
<li>
<p>配置bean</p>
<pre><code class="language-xml">&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.support.StandardServletMultipartResolver&quot;/&gt;
</code></pre>
</li>
<li>
<p>添加注解</p>
</li>
</ol>
<pre><code class="language-xml">&lt;servlet&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
      &lt;param-value&gt;/WEB-INF/dispatcher-servlet.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    
    
    &lt;!-- 相当于不使用springmvc时的文件上传添加注解的效果 --&gt;
    &lt;multipart-config/&gt;
    
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
<h4 id="使用">使用</h4>
<pre><code class="language-java">@RequestMapping(&quot;/upload&quot;)
    public String upload1(@RequestParam MultipartFile file, Model model, HttpServletRequest req){

        String filename= file.getOriginalFilename();

        String filePath = null;

                try {
                    filePath = WebUtils.getRealPath(req.getServletContext(),&quot;/upload/&quot;+filename);
//                    System.out.println(filePath);
                    if (filePath!= null){
                        file.transferTo(new File(filePath));
                    }
                }catch (Exception e){

                }

        model.addAttribute(&quot;filename&quot;,filename);
                model.addAttribute(&quot;filepath&quot;,&quot;http://localhost:8080/upload/&quot;+filename);
        return &quot;fileuploadsuccess&quot;;
    }
</code></pre>
<h3 id="restfull服务">RESTfull服务</h3>
<blockquote>
<p>我们可以通过以下两种方式提供RESTFull的服务</p>
<ul>
<li>用<code>@RestController</code>注解替换Controller类上的<code>@Controller</code>注解，这样该类里面所有的RequestMapping方法都会强制输出返回的内容本身给调用方</li>
<li>在需要提供RESTFull的RequestMapping方法上添加<code>@ResonpseBody</code>注解，这样会强制此方法输出返回的内容本身给调用方。</li>
</ul>
<p>此外，SpringMVC还给我们提供了专用的RESTFull相关注解<code>GetMapping</code>、<code>PostMapping</code>、<code>PutMapping</code>、<code>DeleteMapping</code>、<code>PatchMapping</code>用于简化<code>@RequestMapping</code>注解， 比如<code>@GetMapping</code>注解就相当于<code>@RequestMapping(method=RequestMethod.GET)</code></p>
</blockquote>
<h3 id="拦截器">拦截器</h3>
<p>使用拦截器步骤：</p>
<ol>
<li>
<p>新建拦截器类并实现HandlerInterceptor接口</p>
<pre><code class="language-java">package com.lanou3g.springmvc.interceptor;

import org.springframework.lang.Nullable;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * @author Administrator
 */
public class MyTestInterceptor implements HandlerInterceptor {

    //handler执行前
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(&quot;方法被拦截&quot;);
        return false;
    }

    //handler执行后
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {
    }

    
    //请求完成之后，返回到客户端之前
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {
    }
}
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mybatis]]></title>
        <id>https://ysjhhhhhhh.github.io/post/mybatis</id>
        <link href="https://ysjhhhhhhh.github.io/post/mybatis">
        </link>
        <updated>2018-04-21T05:12:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mybatis">Mybatis</h1>
<h2 id="mybatis简介">Mybatis简介</h2>
<p>了解mybatis前先了解一下ORM 和 JPA的概念</p>
<h3 id="orm">ORM</h3>
<p>ORM（Object-Relationship-Mapping）：是对象关系映射的意思，它是一种思想，是指将数据库中的每一行数据用对象的形式表现出来。</p>
<h3 id="jpa">JPA</h3>
<p>JPA（Java-Persistence-API）：是Java持久化接口的意思，它是JavaEE关于ORM思想的一套标准接口，仅仅是一套接口，不是具体的实现。</p>
<h3 id="什么是mybatis">什么是Mybatis?</h3>
<blockquote>
<p>MyBatis是一个实现了JPA规范的用来连接数据库并对其进行增删改查操作的开源框架 （就和传统的JDBC一样，就是个连接数据库的东西），其实，它底层就是一个JDBC封装的组件。MyBatis的前身是Ibatis，Ibatis创建与2002年最初为Apache下面的一个开源项目，2010迁移到google code下面并改名为MyBatis。</p>
<p>MyBatis虽然实现了JPA但是它并不是一个完完全全的ORM组件，而是一个基于SQL开发的半ORM组件。</p>
<p>而Hibernate是一个完完全全的ORM组件，它是完全基于对象来操作数据库中的记录，并不和MyBatis一样是一个假把式。</p>
</blockquote>
<h3 id="mybatis有什么优点">Mybatis有什么优点</h3>
<blockquote>
<p>简单易学，容易上手（相比于Hibernate） ---- 基于SQL编程<br>
消除了JDBC大量冗余的代码，不需要手动开关连接<br>
很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持，而JDB提供了可扩展性，所以只要这个数据库有针对Java的jar包就可以就可以与MyBatis兼容），开发人员不需要考虑数据库的差异性。<br>
提供了很多第三方插件（分页插件 / 逆向工程）<br>
能够与Spring很好的集成</p>
</blockquote>
<h2 id="mybatis环境搭建">MyBatis环境搭建</h2>
<h3 id="maven项目下">Maven项目下</h3>
<p>在pom.xml文件中添加依赖信息</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
      &lt;version&gt;x.x.x&lt;/version&gt;
    &lt;/dependency&gt;
&lt;!-- mybatis需要依赖jdbc --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;version&gt;5.1.47&lt;/version&gt;
    &lt;/dependency&gt;
&lt;!-- mybatis需要配置数据源，任选一种即可.如： --&gt;
&lt;dependency&gt;
      &lt;groupId&gt;com.mchange&lt;/groupId&gt;
      &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
      &lt;version&gt;0.9.5.4&lt;/version&gt;
    &lt;/dependency&gt;

</code></pre>
<h3 id="非maven项目下">非Maven项目下</h3>
<p>引入相应的jar包</p>
<blockquote>
<ul>
<li>mybatis-x.x.x.jar</li>
<li>mysql-connector-java-5.1.47.jar</li>
<li>c3p0-0.9.5.4.jar</li>
</ul>
</blockquote>
<h3 id="配置jdbcproperties文件">配置jdbc.properties文件</h3>
<pre><code class="language-properties">driverClass=com.mysql.jdbc.Driver
jdbcUrl=jdbc:mysql://127.0.0.1:3306/test
user=root
password=root
</code></pre>
<h2 id="深入了解mybatis">深入了解MyBatis</h2>
<h3 id="mybatis的配置文件和组件">MyBatis的配置文件和组件</h3>
<h4 id="mybatis-configxml文件的配置">mybatis-config.xml文件的配置</h4>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;

&lt;configuration&gt;
    
    &lt;!-- 引入外部配置文件 --&gt;
    &lt;properties resource=&quot;&quot;&gt;&lt;/properties&gt;
    
    &lt;!-- typeAliases因为MyBatis配置中使用的类名是全限定类名，类名较长，可以配置别名 --&gt;
    &lt;typeAliases&gt;
    &lt;/typeAliases&gt;
    
    &lt;!-- MyBatis的环境配置，可以配置具体的事务管理和数据源 --&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;${database.driver}&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;${database.url}&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;${database.username}&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;${database.password}&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    
    &lt;!-- 关联mapper映射 --&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;mybatis/mappers/StudentMapper.xml&quot;/&gt;
    &lt;/mappers&gt;

&lt;/configuration&gt;
</code></pre>
<h4 id="sqlsessionfactory">SqlSessionFactory</h4>
<p>SqlSessionFactory是MyBatis的关键对象,它是个单个数据库映射关系经过编译后的内存镜像.SqlSessionFactory对象的实例可以通过SqlSessionFactoryBuilder对象类获得,而SqlSessionFactoryBuilder则可以从XML配置文件或一个预先定制的Configuration的实例构建出SqlSessionFactory的实例.每一个MyBatis的应用程序都以一个SqlSessionFactory对象的实例为核心.同时SqlSessionFactory也是线程安全的,SqlSessionFactory一旦被创建,应该在应用执行期间都存在.在应用运行期间不要重复创建多次,建议使用单例模式.SqlSessionFactory是创建SqlSession的工厂.</p>
<h4 id="sqlsession">SqlSession</h4>
<p>SqlSession是MyBatis的关键对象,是执行持久化操作的独享,类似于JDBC中的Connection.它是应用程序与持久层之间执行交互操作的一个单线程对象,也是MyBatis执行持久化操作的关键对象.SqlSession对象完全包含以数据库为背景的所有执行SQL操作的方法,它的底层封装了JDBC连接,可以用SqlSession实例来直接执行被映射的SQL语句.每个线程都应该有它自己的SqlSession实例.SqlSession的实例不能被共享,同时SqlSession也是线程不安全的,绝对不能讲SqlSeesion实例的引用放在一个类的静态字段甚至是实例字段中.也绝不能将SqlSession实例的引用放在任何类型的管理范围中,比如Servlet当中的HttpSession对象中.使用完SqlSeesion之后关闭Session很重要,应该确保使用finally块来关闭它.</p>
<h4 id="mapper">Mapper</h4>
<p>Mapper接口和Mapper的xml文件是一一对应的。</p>
<p>具体的sql语句写在Mapper.xml中的insert delete select update标签内，只需做好相应的映射。Mybatis就会自动创建具体的接口实现类实现具体的方法供我们调用</p>
<p>绑定Mapper映射需要注意以下几点：</p>
<blockquote>
<ul>
<li>mapper.xml配置的namespace要是对应的接口的全限定接口名</li>
<li>mapper.xml配置的相应insert delete select update标签的id和接口中的方法名一一对应</li>
<li>select标签一定要设置resultType属性的值为要返回的查询结果的类型，或者指定对应的resultMap结果集映射</li>
</ul>
</blockquote>
<h3 id="具体的使用mybatis步骤">具体的使用Mybatis步骤</h3>
<h4 id="先创建实体bean">先创建实体bean</h4>
<h5 id="girl类">girl类</h5>
<pre><code class="language-java">package com.lanou3g.bean;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@ToString
public class Girl {
    private Integer id;
    private String name;
    private Integer king_id;
}

</code></pre>
<h5 id="queen类">queen类</h5>
<pre><code class="language-java">package com.lanou3g.bean;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@ToString
public class Queen {
    private Integer id;
    private String name;
    private Integer king_id;
}
</code></pre>
<h5 id="king类">king类</h5>
<pre><code class="language-java">package com.lanou3g.bean;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.util.List;

@Getter
@Setter
@ToString
public class King {
    private Integer id;
    private String name;
    private Queen queen;
    private List&lt;Girl&gt; girls;
}

</code></pre>
<h4 id="新建一个mybatis-configxml配置文件并进行相应的配置">新建一个mybatis-config.xml配置文件并进行相应的配置</h4>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
        &lt;!DOCTYPE configuration
                PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
                &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!-- 引入外部properties文件 --&gt;
&lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;
&lt;typeAliases&gt;
&lt;!-- 为指定包中的类起别名 --&gt;
    &lt;package name=&quot;com.lanou3g.bean&quot;/&gt;
&lt;/typeAliases&gt;
&lt;environments default=&quot;development&quot;&gt;
    &lt;environment id=&quot;development&quot;&gt;
        &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
        &lt;/dataSource&gt;
    &lt;/environment&gt;
&lt;/environments&gt;
    
&lt;!-- 关联mapper映射 --&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;mybatis/mappers/StudentMapper.xml&quot;/&gt;
&lt;/mappers&gt;

&lt;/configuration&gt;
</code></pre>
<h4 id="创建mapper接口">创建mapper接口</h4>
<pre><code class="language-java">package com.lanou3g.dao;

import com.lanou3g.bean.King;

public interface KingDao {
    King getKingById(Integer id);
}

</code></pre>
<h4 id="创建mapperxml">创建mapper.xml</h4>
<h5 id="mapperxml文件中resultmap">mapper.xml文件中resultMap</h5>
<p>为什么使用resultMap：当查询出来的字段名和对象中的属性名不一致的情况就没办法使用resultType来默认映射</p>
<blockquote>
<p>每个具体的标签的column属性代表在数据库中查到的字段，最后映射结果的时候会映射到实体类中名为property对应字符的属性中（如：一个国王有一个王后和多个妃子）</p>
<ul>
<li>id 子标签是对应数据库中主键且自增的字段</li>
<li>result 子标签对应普通字段</li>
<li>association 子标签用来处理一对一关系映射（用来处理王后）</li>
<li>collection 字标签用来处理一对多关系映射（用来处理妃子）</li>
</ul>
</blockquote>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.lanou3g.dao.KingDao&quot;&gt;

    &lt;resultMap id=&quot;kingMap&quot; type=&quot;king&quot;&gt;
        &lt;id column=&quot;kid&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;kname&quot; property=&quot;name&quot;/&gt;
        &lt;association property=&quot;queen&quot; javaType=&quot;queen&quot; columnPrefix=&quot;q_&quot;&gt;
            &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
            &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
            &lt;result column=&quot;king_id&quot; property=&quot;king_id&quot;/&gt;
        &lt;/association&gt;
        &lt;collection property=&quot;girls&quot; ofType=&quot;girl&quot; columnPrefix=&quot;g_&quot;&gt;
            &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
            &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
            &lt;result column=&quot;king_id&quot; property=&quot;king_id&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;

    &lt;!-- 通过此查询语句查询出king的信息以及king的queen的信息和众多girl的信息 --&gt;
    &lt;select id=&quot;getKingById&quot; resultMap=&quot;kingMap&quot;&gt;
        select
        king.id kid,
        king.name kname,
        q.id q_id,
        q.`name` q_name,
        q.king_id q_king_id,
        g.id g_id,
        g.`name` g_name,
        g.king_id g_king_id
        from king
        LEFT JOIN queen q ON king.id = q.king_id
        LEFT JOIN girl g on q.king_id = g.king_id
        where g.king_id = #{id}
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h4 id="获取mybatis文件的输入流">获取mybatis文件的输入流</h4>
<pre><code class="language-java">InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
</code></pre>
<h4 id="获取sqlsessionfactory对象">获取SqlSessionFactory对象</h4>
<pre><code class="language-java">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is)
</code></pre>
<h4 id="获取sqlsession对象">获取SqlSession对象</h4>
<pre><code class="language-java">//添加参数true设置事务自动提交，默认不会自动提交
SqlSession sqlSession = sqlSessionFactory.openSession(true);
</code></pre>
<h4 id="获取mybatis自动生成的接口的具体实现类并执行方法接收返回值">获取mybatis自动生成的接口的具体实现类并执行方法，接收返回值。</h4>
<pre><code class="language-java">King king = sqlSession.getMapper(KingDao.class).getKingById(1);
</code></pre>
<h3 id="和的作用和区别">#{}和${}的作用和区别</h3>
<h4 id="作用">作用</h4>
<p>通过#{}和${}取出调用方法时传入的参数，并将其应用在sql语句中</p>
<h4 id="区别">区别</h4>
<blockquote>
<p>#{}是预编译处理，${}是字符串替换。</p>
<p>（1）mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</p>
<p>（2）mybatis在处理<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow></mrow><mi mathvariant="normal">时</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">把</mi></mrow><annotation encoding="application/x-tex">{}时，就是把</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord"></span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">把</span></span></span></span>{}替换成变量的值。</p>
<p>（3）使用#{}可以有效的防止SQL注入，提高系统安全性。原因在于：预编译机制。</p>
<p>预编译是提前对SQL语句进行预编译，而其后注入的参数将不会再进行SQL编译。我们知道，SQL注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译成了恶意的执行操作。而预编译机制则可以很好的防止SQL注入。预编译完成之后，SQL的结构已经固定，即便用户输入非法参数，也不会对SQL的结构产生影响，从而避免了潜在的安全风险。</p>
</blockquote>
<h3 id="动态sql如何使用">动态sql如何使用</h3>
<h5 id="什么是动态sql">什么是动态sql</h5>
<blockquote>
<p>动态SQL是MyBatis的强大特性之一，MyBatis3采用了功能强大的基于OGNL的表达式来完成动态SQL。</p>
</blockquote>
<h5 id="动态sql的作用">动态sql的作用</h5>
<blockquote>
<p>MyBatis的动态SQL主要就是为了解决手动拼接SQL的麻烦。</p>
</blockquote>
<h5 id="动态sql有哪些标签">动态sql有哪些标签</h5>
<figure data-type="image" tabindex="1"><img src="https://images2017.cnblogs.com/blog/1240732/201711/1240732-20171101153219685-1084206827.png" alt=""></figure>
<h6 id="if标签的使用">if标签的使用</h6>
<pre><code class="language-xml">&lt;select id=&quot;queryStudentById&quot; resultType=&quot;com.lanou3g.bean.Student&quot; &gt;
        select * from stu 
        where name = #{name}
    	&lt;if test=&quot;sex!=null&quot;&gt;
            and sex = #{sex}
        &lt;/if&gt;
&lt;/select&gt;
</code></pre>
<h6 id="choose标签的使用">choose标签的使用</h6>
<pre><code class="language-xml">select * from stu where 1=1
      &lt;choose&gt;
           &lt;when test=&quot;name !=null and name !=''&quot;&gt;
                       and name = #{username}
           &lt;/when&gt;
           &lt;when test=&quot;sex !=null and sex !=''&quot;&gt;
                       and sex= #{sex}
           &lt;/when&gt;
           &lt;otherwise&gt;
                   
           &lt;/otherwise&gt;
      &lt;/choose&gt;
</code></pre>
<h6 id="where标签的使用">where标签的使用</h6>
<pre><code class="language-xml">select * from stu
&lt;where&gt;
     &lt;if test=&quot;name !=null and name !=''&quot;&gt;
           and username = #{username}
     &lt;/if&gt;
     &lt;if test=&quot;sex !=null and sex !=''&quot;&gt;
           and sex= #{sex}
     &lt;/if&gt;
&lt;/where&gt;
</code></pre>
<h6 id="foreach标签的使用">foreach标签的使用</h6>
<pre><code class="language-xml">select * from stu where id in
      &lt;foreach item=&quot;id&quot; index=&quot;index&quot; collection=&quot;list&quot; 
                      open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;
             #{id}
      &lt;/foreach&gt;
</code></pre>
<h3 id="批量插入">批量插入</h3>
<h4 id="通过foreach子标签">通过<foreach>子标签</h4>
<pre><code class="language-xml">&lt;!-- 传入的要是list --&gt;
&lt;insert id=&quot;insertStudentBatch1&quot;&gt;
        insert into student (sno,sname,ssex,sage)
        values
        &lt;foreach collection=&quot;list&quot; item=&quot;stu&quot; separator=&quot;,&quot;&gt;
            (#{stu.sno},#{stu.sname},#{stu.ssex},#{stu.sage})
        &lt;/foreach&gt;
    &lt;/insert&gt;
</code></pre>
<p>可能会出现sql语句过大插入失败的结果</p>
<h4 id="通过设置executortypebatch属性">通过设置ExecutorType.BATCH属性</h4>
<pre><code class="language-java">SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH, true);
</code></pre>
<p>每次只插入一条</p>
<pre><code class="language-xml">&lt;insert id=&quot;insertStudentBatch2&quot;&gt;
        insert into student (sno,sname,ssex,sage)
        value (#{sno},#{sname},#{ssex},#{sage})
&lt;/insert&gt;
</code></pre>
<p>循环插入</p>
<pre><code class="language-java">    private static void insert2() throws Exception{
        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);

        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();

        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);

//        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH, true);

        StudentDao mapper = sqlSession.getMapper(StudentDao.class);

        List&lt;Student&gt; stuList = App.getStuList();

        int total = 10;

        int count = 0 ;

        List&lt;BatchResult&gt; br = new ArrayList&lt;&gt;();

        for (Student student: stuList) {
            mapper.insertStudentBatch2(student);
            count++;
            System.out.println(&quot;count:&quot;+count);
            if (count%total==0){
                List&lt;BatchResult&gt; batchResults = sqlSession.flushStatements();
                br.addAll(batchResults);
            }
        }

        List&lt;BatchResult&gt; batchResults = sqlSession.flushStatements();
        br.addAll(batchResults);

        int a = 0;
        for (BatchResult b:br
             ) {
            System.out.println(222);
            int[] c = b.getUpdateCounts();
            for (int cc: c
            ) {
                System.out.println(cc);
                a+=cc;
            }
        }

        System.out.println(&quot;影响行数为：&quot; + a);
    }
</code></pre>
<p>可以通过sqlSession.flushStatements();刷新将数据插入到数据库</p>
<h3 id="缓存">缓存</h3>
<h4 id="一级缓存本地缓存">一级缓存（本地缓存）</h4>
<p>一级缓存默认开启，范围是同一个SqlSession</p>
<p>同一个SqlSession内执行同样一条查询语句时先访问缓存，如果命中缓存则不再去数据库中查询</p>
<p>关闭一级缓存，设置localCacheScope为STATEMENT就可以了</p>
<h4 id="二级缓存">二级缓存</h4>
<p>二级缓存可以跨SqlSession</p>
<p>开启二级缓存的方法</p>
<p>在mybatis配置文件中加入</p>
<pre><code class="language-xml">&lt;settings&gt; 
    &lt;!-- 开启全局二级缓存 --&gt;  
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 
&lt;/settings&gt; 
</code></pre>
<p>在mapper映射文件中加入</p>
<pre><code class="language-xml">&lt;mapper namespace=&quot;com.lanou3g.dao.KingDao&quot;&gt;
&lt;cache /&gt;
&lt;/mapper&gt;
</code></pre>
<p>关闭指定语句不适用二级缓存</p>
<pre><code class="language-xml">&lt;select id=&quot;queryStudentById&quot; resultType=&quot;com.lanou3g.bean.Student&quot; useCache=&quot;false&quot;&gt;
        select * from stu 
        where name = #{name}
&lt;/select&gt;
</code></pre>
<p>注意事项</p>
<p>因为缓存要做到持久化就必须存入物理硬盘，因此对应的类要实现可序列化接口</p>
<pre><code class="language-java">public class Student implements Serializable { }
</code></pre>
<h1 id="spring-和mybatis整合">Spring 和MyBatis整合</h1>
<h2 id="加入整合jar包">加入整合jar包</h2>
<pre><code class="language-xml">&lt;!-- mybatis-spring整合包 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;2.0.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Spring和数据源相关依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
</code></pre>
<h2 id="对应的applicationcontextxml配置">对应的applicationContext.xml配置</h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:mybatis=&quot;http://mybatis.org/schema/mybatis-spring&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd
      http://mybatis.org/schema/mybatis-spring
      http://mybatis.org/schema/mybatis-spring.xsd
      http://www.springframework.org/schema/aop
      https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;



    &lt;aop:aspectj-autoproxy  expose-proxy=&quot;true&quot; proxy-target-class=&quot;true&quot;/&gt;

    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;/&gt;

    &lt;bean id=&quot;sqlSessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;!-- 注入数据源 --&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
        &lt;!-- 设置mybatis核心配置文件路径（可选） --&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;mybatis-config.xml&quot; /&gt;
        &lt;!-- 配置mybatis xml映射文件位置（如果Mapper是用注解配置的，这里就不用设置此属性了） --&gt;
&lt;!--        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:/mabatis/mappers/*&quot; /&gt;--&gt;
    &lt;/bean&gt;
    
    &lt;mybatis:scan base-package=&quot;com.lanou3g.mapper&quot;/&gt;

    &lt;context:component-scan base-package=&quot;com.lanou3g&quot; resource-pattern=&quot;com.lanou3g.mapper&quot;/&gt;


&lt;/beans&gt;
</code></pre>
<h2 id="添加事务">添加事务</h2>
<pre><code class="language-xml">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;service&quot; class=&quot;com.lanou3g.service.MyService&quot;/&gt;

    &lt;tx:advice id=&quot;myadc&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;*&quot; rollback-for=&quot;Exception&quot; /&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;myCut&quot; expression=&quot;execution(* com.lanou3g.service.*.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;myadc&quot; pointcut-ref=&quot;myCut&quot;/&gt;
    &lt;/aop:config&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring框架]]></title>
        <id>https://ysjhhhhhhh.github.io/post/spring-kuang-jia</id>
        <link href="https://ysjhhhhhhh.github.io/post/spring-kuang-jia">
        </link>
        <updated>2018-04-12T07:38:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="spring">Spring</h1>
<ul>
<li>
<p>什么是spring</p>
<blockquote>
<p>Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson开发。</p>
<p>它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架</p>
<p>dao(JdbcTemplate)  service(spring控制事务)   web(springmvc)</p>
<p>Spring的核心是控制反转（IoC）和面向切面（AOP）。</p>
<p>简单来说，Spring是一个分层的JavaSE/EE full-stack 轻量级开源框架。  1）IoC  和DI  2）AOP</p>
<p>一句话描述spring：full-stack 轻量级开源框架</p>
</blockquote>
</li>
<li>
<p>spring核心</p>
<blockquote>
<p>Spring的核心是控制反转IOC和面向切面AOP</p>
</blockquote>
</li>
</ul>
<h2 id="ioc">IOC</h2>
<ul>
<li>
<p>IOC是什么</p>
<blockquote>
<p>**Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。**在Java开发中，<strong>Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</strong></p>
</blockquote>
</li>
<li>
<p>spring IOC容器初始化方式</p>
<pre><code class="language-java">//xml初始化
ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;classpath:/ioc.xml&quot;);

//注解类初始化
ApplicationContext acc = new AnnotationConfigApplicationContext(ApplicationContextTest.class);
</code></pre>
</li>
<li>
<p>通过xml方式配置容器</p>
<blockquote>
<p>bean标签代指容器中的一个对象</p>
<p>property标签使用在bean标签之中为bean对象属性赋值</p>
</blockquote>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;


    &lt;bean id=&quot;stu01&quot; class=&quot;com.lanou.bean.Student&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;28&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;stu02&quot; class=&quot;com.lanou.bean.Student&quot;&gt;
        &lt;constructor-arg value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;28&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;

    &lt;context:property-placeholder location=&quot;classpath:jdbcConfig.properties&quot;/&gt;

    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.jdbcUrl}&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;plane&quot; class=&quot;com.lanou.bean.plane&quot; autowire=&quot;constructor&quot;&gt;
        &lt;property name=&quot;hight&quot; value=&quot;#{3*12}&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;teacher&quot; class=&quot;com.lanou.bean.Teacher&quot; p:name=&quot;#{T(java.util.UUID).randomUUID().toString()}&quot; p:age=&quot;20&quot; p:sex=&quot;女&quot;&gt;&lt;/bean&gt;
&lt;!--    &lt;bean id=&quot;teacher2&quot; class=&quot;com.lanou.bean.Teacher&quot; p:name=&quot;李老师&quot; p:age=&quot;20&quot; p:sex=&quot;男&quot;&gt;&lt;/bean&gt;--&gt;

    &lt;bean id=&quot;banji&quot; class=&quot;com.lanou.bean.BanJi&quot; autowire=&quot;constructor&quot;&gt;
&lt;!--        &lt;property name=&quot;teacher&quot; value=&quot;#{teacher2}&quot;&gt;&lt;/property&gt;--&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;dog1&quot; class=&quot;com.lanou.bean.Dog&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;红狗&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;2&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;com.lanou.bean.Man&quot;&gt;

    &lt;/bean&gt;

    &lt;!-- 扫描通过注解配置的容器bean --&gt;
    &lt;context:component-scan base-package=&quot;com.lanou&quot;&gt;&lt;/context:component-scan&gt;
&lt;/beans&gt;
</code></pre>
<p>bean初始化方法：</p>
<p>1.普通方式</p>
<pre><code class="language-xml">&lt;bean class=&quot;com.lanou.bean.Man&quot;&gt;
</code></pre>
<p>2.静态工厂方式</p>
<pre><code class="language-xml">&lt;!-- 
	class：指定的是静态工厂类 factory-method: 指定的是工厂中的静态方法 
--&gt;
&lt;bean id=&quot;getMan&quot; class=&quot;com.test.ManFactory&quot; factory-method=&quot;getMan&quot; /&gt;
</code></pre>
<p>3.实例工厂方式</p>
<pre><code class="language-xml">&lt;!-- 工厂实例bean --&gt;
&lt;bean id=&quot;manFactory&quot; class=&quot;com.lanou.ManFactory&quot;&gt;&lt;/bean&gt;

&lt;bean id=&quot;getMan&quot; factory-bean=&quot;manFactory&quot; factory-method=&quot;getMan&quot;&gt;&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>通过注解的方式配置容器</p>
<pre><code class="language-java">package com.lanou3g;

import com.lanou3g.bean.Man;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.*;

import javax.annotation.Resource;

@Configuration //通过这个注解指定此类为IOC容器配置类
@ComponentScan(&quot;com.lanou3g&quot;)//次注解是指定容器初始化时扫描那些包下
@ImportResource({&quot;ioc.xml&quot;})//此注解表示在此配置类初始化时包含其他配置文件中的配置
@PropertySource(&quot;classpath:/manproperties.properties&quot;)//此注解表示在初始化容器时读取某properties文件中的配置信息
public class ApplicationContextTest {

    //此注解为属性赋值
    @Value(&quot;${name}&quot;)
    private String name;

    @Value(&quot;${age}&quot;)
    private Integer age;

    //此注解向容器中配置bean
    @Bean(&quot;man123&quot;)
    public Man aaa(){
        Man man = new Man();
        man.setName(&quot;哈哈&quot;);
        man.setAge(1);
        return man;
    }

    @Bean(&quot;manTest&quot;)
    public Man bbb(){
        Man man = new Man();
        man.setName(name);
        man.setAge(age);
        return man;
    }

}
</code></pre>
</li>
<li>
<p>bean的命名</p>
<blockquote>
<p>id是唯一标识，每个bean只能有一个id，且不同bean之间id也不能重复</p>
<p>name也是bean的标识，每个bean可以拥有多个name。name属性已久不能重复</p>
</blockquote>
</li>
<li>
<p>bean的作用域</p>
<blockquote>
<p>prototype:此属性表示此bean为多例，因此对象不会在容器初始化时创建</p>
<p>singleton(默认):单例bean会在容器初始化时创建bean对象</p>
</blockquote>
</li>
</ul>
<p>多例图解：</p>
<figure data-type="image" tabindex="1"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/prototype.png" alt=""></figure>
<p>单例图解：</p>
<figure data-type="image" tabindex="2"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/singleton.png" alt=""></figure>
<ul>
<li>
<p>bean懒加载：</p>
<p>lazy-init属性 默认是false</p>
<p>（懒加载主要是针对单例，可以让单例在容器初始化时不进行加载。在使用此bean是才去加载）</p>
</li>
</ul>
<h2 id="di">DI</h2>
<ul>
<li>
<p>DI-依赖注入</p>
<blockquote>
<p>创建对象的过程中Spring可以依据配置对对象的属性 进行设置，这个过程称之为依赖注入，即DI</p>
</blockquote>
</li>
<li>
<p>set方法注入</p>
<blockquote>
<p>通常javabean的属性都会私有化，而对外暴露setXx()getXx()方法，此时spring可以通过这样的setXx()方法将属性的值注入对象。</p>
<p>1)spring内置的可直接注入类型的注入</p>
<p>在<bean>标签下添加<property name="set方法名中set之后的单词(首字母小写)" value="要设置的属性的值"></p>
<p>2)非spring内置(即另外的实体类，比如定义一个Person类中有猫和狗两个属性，而猫和狗分别是两个实体类Cat和Dog的对象)的可以直接注入类型的注入</p>
<p>需要添加对应类的<bean>标签，在原始类中添加<property name="自定义名称(一般与类中的属性名称一致)" ref="非spring内置类配置的id值"></p>
</blockquote>
</li>
<li>
<p>基于构造方法的注入</p>
<blockquote>
<p>在<bean>标签下添加&lt;constructor-arg index=&quot;构造方法的第几个参数，下标从0开始&quot; name=&quot;为构造方法的哪个名字的参数ref:该构造方法参数的值,用来指定引用其他bean的值&gt;<br>
ps：index和name可以配置任何一个或同时配置，但要求一旦配置必须正确，推荐优先使用index方式配置，防止没有源码造成name无法匹配到对应的参数</p>
</blockquote>
</li>
<li>
<p>自动装配</p>
<blockquote>
<p>在Spring的set方式实现的注入过程中，支持自动装配机制。所谓自动装配机制，会根据要设置的javabean属性的名字或类型，到spring中自动寻找对应id或类型的<bean>进行设置，从而省去依次配置的过程，简化了配置。</p>
<p>自动装配的两种方式</p>
<p>1)为指定<bean>开启自动装配</p>
<p>在<bean>标签中添加autowire属性：<br>
byName：根据javabean（javabean简单的讲就是实体类，用来封装对象，这个类里面全部都是属性值和get、set方法）中需要注入的属性的名字，在spring容器中找对应id的<bean>，将该<bean>的对象赋值给当前的属性<br>
byType：根据javabean中需要注入的属性的类型，在Spring容器中找对应class类型的<bean>将该<bean>的对象赋值给当前的属性<br>
byType方式根据类型进行匹配，可能匹配到多个<bean>，此时会抛出异常，而byName是通过id来寻找<bean>，id没有重复，不会有这方面的问题，所以推荐使用byName方式<br>
总结：自动装配机制简化了set方法注入中的非Spring内置的可以直接注入类型的注入</p>
<p>2)为全局配置自动装配</p>
<p>在<beans>标签中添加default-autowire属性：<br>
byName与byType和第一点相同</p>
</blockquote>
</li>
</ul>
<h2 id="aop">AOP</h2>
<ul>
<li>
<p>什么是AOP</p>
<blockquote>
<p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方<br>
式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个<br>
热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑<br>
的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高<br>
了开发的效率。</p>
</blockquote>
</li>
<li>
<p>aop术语</p>
<blockquote>
<p>切面（Aspect）</p>
<p>简单来说，切面就是我们要往目标代码中插入进去的代码。</p>
<p>连接点（Join Pointer）</p>
<p>理论上所有可能会被切入的地方都可以称之为连接点</p>
<p>切入点(Pointcut)</p>
<p>选择某个连接点切入，将切面代码织入进去。这个连接点就叫做切入点。</p>
<p>织入(Weaving)</p>
<p>把切面代码糅合到目标代码中的过程就是织入。</p>
<p>通知(Advice)</p>
<p>通知决定了切面代码织入到目标代码中后，运行的时机(比如是在目标方法执行前，还是执行后)。</p>
</blockquote>
</li>
<li>
<p>在spring中使用aop</p>
<p>定义被切的类和方法</p>
<pre><code class="language-java">package com.lanou3g.bean;

import com.lanou3g.Calculator;
import org.springframework.stereotype.Component;

public class MyCalculator implements Calculator {
    @Override
    public int add(int a, int b) {
        return a+b;
    }

    @Override
    public int sub(int a, int b) {
        return a-b;
    }

    @Override
    public int mul(int a, int b) {
        return a*b;
    }

    @Override
    public int div(int a, int b) {
        return a/b;
    }
}

</code></pre>
<p>定义切面类</p>
<pre><code class="language-java">package com.lanou3g.log;


import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

import java.util.Arrays;

public class CalculatorLog {

//    public static void cutclass(){}

    public static void logStart(JoinPoint joinPoint){
        String methodname = joinPoint.getSignature().getName();
        System.out.println(methodname+&quot;方法前置切面方法启动，参数为:&quot;+ Arrays.asList(joinPoint.getArgs()));
    }



    public static void logThrowing(JoinPoint joinPoint,Exception e){
        String methodname = joinPoint.getSignature().getName();
        System.out.println(methodname+&quot;方法异常切面方法启动，错误信息为:&quot;+ e.getMessage());
    }

    public static void logEnd(JoinPoint joinPoint){
        String methodname = joinPoint.getSignature().getName();
        System.out.println(methodname+&quot;方法最终切面方法启动&quot;);
    }

    public static Object logAround(ProceedingJoinPoint pjp) throws Throwable {
        String methodname = pjp.getSignature().getName();
        Object[] args = pjp.getArgs();
        Object res = null;

        try {
            System.out.println(methodname+&quot;方法[环绕]前置切面方法启动，参数为:&quot;+ Arrays.asList(args));
            res = pjp.proceed(args);
            System.out.println(methodname+&quot;方法[环绕]返回切面方法启动，结果为:&quot;+ res);

        }catch (Exception e){
            System.out.println(methodname+&quot;方法[环绕]异常切面方法启动，异常信息为:&quot;+ e.getMessage());
        }finally {
            System.out.println(methodname+&quot;方法[环绕]最终切面方法启动&quot;);
        }

        return res;
    }
    public static void logReturning(JoinPoint joinPoint,Object res){
        String methodname = joinPoint.getSignature().getName();
        System.out.println(methodname+&quot;方法返回切面方法启动，结果为:&quot;+ res);
    }

}
</code></pre>
<blockquote>
<p>在xml文件中配置aop</p>
</blockquote>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;



    &lt;bean id=&quot;man&quot; class=&quot;com.lanou3g.bean.Man&quot; lazy-init=&quot;true&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;28&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;hobbys&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;王者&quot; value=&quot;最强王者&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;aop:aspectj-autoproxy  expose-proxy=&quot;true&quot;    proxy-target-class=&quot;true&quot;/&gt;

    &lt;bean id=&quot;myc&quot; class=&quot;com.lanou3g.bean.MyCalculator&quot; /&gt;

    &lt;bean id=&quot;callog&quot; class=&quot;com.lanou3g.log.CalculatorLog&quot; /&gt;

    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;mycutpoint&quot; expression=&quot;execution(* com.lanou3g.bean.MyCalculator.*(int,int))&quot;/&gt;

        &lt;aop:aspect ref=&quot;callog&quot;&gt;
            &lt;aop:before method=&quot;logStart&quot; pointcut-ref=&quot;mycutpoint&quot; /&gt;
            &lt;aop:after-returning method=&quot;logReturning&quot; pointcut-ref=&quot;mycutpoint&quot; returning=&quot;res&quot;/&gt;
            &lt;aop:after-throwing method=&quot;logThrowing&quot; pointcut-ref=&quot;mycutpoint&quot; throwing=&quot;e&quot;/&gt;
            &lt;aop:after method=&quot;logEnd&quot; pointcut-ref=&quot;mycutpoint&quot; /&gt;
            &lt;aop:around method=&quot;logAround&quot; pointcut-ref=&quot;mycutpoint&quot; /&gt;
        &lt;/aop:aspect&gt;

    &lt;/aop:config&gt;

    &lt;context:component-scan base-package=&quot;com.lanou3g&quot; resource-pattern=&quot;com.lanou3g.log.*&quot;/&gt;
   
&lt;/beans&gt;
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux常用命令大全]]></title>
        <id>https://ysjhhhhhhh.github.io/post/linux-chang-yong-ming-ling-da-quan</id>
        <link href="https://ysjhhhhhhh.github.io/post/linux-chang-yong-ming-ling-da-quan">
        </link>
        <updated>2018-04-06T02:28:57.000Z</updated>
        <content type="html"><![CDATA[<p>最近都在和Linux打交道，这方面基础比较薄弱的我只好买了本鸟哥的书看看，感觉还不错。我觉得Linux相比windows比较麻烦的就是很多东西都要用命令来控制，当然，这也是很多人喜欢linux的原因，比较短小但却功能强大。为了方便大家查找linux的相关命令，我就将我了解到的命令列举一下，仅供大家参考：</p>
<h2 id="系统信息">系统信息</h2>
<p>arch 显示机器的处理器架构(1)<br>
uname -m 显示机器的处理器架构(2)<br>
uname -r 显示正在使用的内核版本<br>
dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>
hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>
hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>
cat /proc/cpuinfo 显示CPU info的信息<br>
cat /proc/interrupts 显示中断<br>
cat /proc/meminfo 校验内存使用<br>
cat /proc/swaps 显示哪些swap被使用<br>
cat /proc/version 显示内核的版本<br>
cat /proc/net/dev 显示网络适配器及统计<br>
cat /proc/mounts 显示已加载的文件系统<br>
lspci -tv 罗列 PCI 设备<br>
lsusb -tv 显示 USB 设备<br>
date 显示系统日期<br>
cal 2007 显示2007年的日历表<br>
date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>
clock -w 将时间修改保存到 BIOS</p>
<h2 id="关机-系统的关机-重启以及登出">关机 (系统的关机、重启以及登出 )</h2>
<p>shutdown -h now 关闭系统(1)<br>
init 0 关闭系统(2)<br>
telinit 0 关闭系统(3)<br>
shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>
shutdown -c 取消按预定时间关闭系统<br>
shutdown -r now 重启(1)<br>
reboot 重启(2)<br>
logout 注销</p>
<h2 id="文件和目录">文件和目录</h2>
<p>cd /home 进入 '/ home' 目录'<br>
cd .. 返回上一级目录<br>
cd ../.. 返回上两级目录<br>
cd 进入个人的主目录<br>
cd ~user1 进入个人的主目录<br>
cd - 返回上次所在的目录<br>
pwd 显示工作路径<br>
ls 查看目录中的文件<br>
ls -F 查看目录中的文件<br>
ls -l 显示文件和目录的详细资料<br>
ls -a 显示隐藏文件<br>
ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>
tree 显示文件和目录由根目录开始的树形结构(1)<br>
lstree 显示文件和目录由根目录开始的树形结构(2)<br>
mkdir dir1 创建一个叫做 'dir1' 的目录'<br>
mkdir dir1 dir2 同时创建两个目录<br>
mkdir -p /tmp/dir1/dir2 创建一个目录树<br>
rm -f file1 删除一个叫做 'file1' 的文件'<br>
rmdir dir1 删除一个叫做 'dir1' 的目录'<br>
rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容<br>
rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>
mv dir1 new_dir 重命名/移动 一个目录<br>
cp file1 file2 复制一个文件<br>
cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>
cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>
cp -a dir1 dir2 复制一个目录<br>
ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>
ln file1 lnk1 创建一个指向文件或目录的物理链接<br>
touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>
file file1 outputs the mime type of the file as text<br>
iconv -l 列出已知的编码<br>
iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>
find . -maxdepth 1 -name *.jpg -print -exec convert &quot;{}&quot; -resize 80x60 &quot;thumbs/{}&quot; ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)</p>
<h2 id="文件搜索">文件搜索</h2>
<p>find / -name file1 从 '/' 开始进入根文件系统搜索文件和目录<br>
find / -user user1 搜索属于用户 'user1' 的文件和目录<br>
find /home/user1 -name *.bin 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件<br>
find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>
find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>
find / -name *.rpm -exec chmod 755 '{}' ; 搜索以 '.rpm' 结尾的文件并定义其权限<br>
find / -xdev -name *.rpm 搜索以 '.rpm' 结尾的文件，忽略光驱、捷盘等可移动设备<br>
locate *.ps 寻找以 '.ps' 结尾的文件 - 先运行 'updatedb' 命令<br>
whereis halt 显示一个二进制文件、源码或man的位置<br>
which halt 显示一个二进制文件或可执行文件的完整路径</p>
<h2 id="挂载一个文件系统">挂载一个文件系统</h2>
<p>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 '/ mnt/hda2' 已经存在<br>
umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 '/ mnt/hda2' 退出<br>
fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>
umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>
mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>
mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>
mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>
mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>
mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>
mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>
mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>
mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享</p>
<h2 id="磁盘空间">磁盘空间</h2>
<p>df -h 显示已经挂载的分区列表<br>
ls -lSr |more 以尺寸大小排列文件和目录<br>
du -sh dir1 估算目录 'dir1' 已经使用的磁盘空间'<br>
du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>
rpm -q -a --qf '%10{SIZE}t%{NAME}n' | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>
dpkg-query -W -f='<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>I</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>d</mi><mo>−</mo><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo separator="true">;</mo><mn>10</mn></mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">{Installed-Size;10}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span></span><span class="mord mathdefault">t</span></span></span></span>{Package}n' | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)</p>
<h2 id="用户和群组">用户和群组</h2>
<p>groupadd group_name 创建一个新用户组<br>
groupdel group_name 删除一个用户组<br>
groupmod -n new_group_name old_group_name 重命名一个用户组<br>
useradd -c &quot;Name Surname &quot; -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 &quot;admin&quot; 用户组的用户<br>
useradd user1 创建一个新用户<br>
userdel -r user1 删除一个用户 ( '-r' 排除主目录)<br>
usermod -c &quot;User FTP&quot; -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>
passwd 修改口令<br>
passwd user1 修改一个用户的口令 (只允许root执行)<br>
chage -E 2005-12-31 user1 设置用户口令的失效期限<br>
pwck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的用户<br>
grpck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的群组<br>
newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组</p>
<h2 id="文件的权限-使用-设置权限使用-用于取消">文件的权限 - 使用 &quot;+&quot; 设置权限，使用 &quot;-&quot; 用于取消</h2>
<p>ls -lh 显示权限<br>
ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>
chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>
chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>
chown user1 file1 改变一个文件的所有人属性<br>
chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>
chgrp group1 file1 改变文件的群组<br>
chown user1:group1 file1 改变一个文件的所有人和群组属性<br>
find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>
chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>
chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>
chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>
chmod g-s /home/public 禁用一个目录的 SGID 位<br>
chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>
chmod o-t /home/public 禁用一个目录的 STIKY 位</p>
<h2 id="文件的特殊属性-使用-设置权限使用-用于取消">文件的特殊属性 - 使用 &quot;+&quot; 设置权限，使用 &quot;-&quot; 用于取消</h2>
<p>chattr +a file1 只允许以追加方式读写文件<br>
chattr +c file1 允许这个文件能被内核自动压缩/解压<br>
chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>
chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>
chattr +s file1 允许一个文件被安全地删除<br>
chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>
chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>
lsattr 显示特殊的属性</p>
<h2 id="打包和压缩文件">打包和压缩文件</h2>
<p>bunzip2 file1.bz2 解压一个叫做 'file1.bz2'的文件<br>
bzip2 file1 压缩一个叫做 'file1' 的文件<br>
gunzip file1.gz 解压一个叫做 'file1.gz'的文件<br>
gzip file1 压缩一个叫做 'file1'的文件<br>
gzip -9 file1 最大程度压缩<br>
rar a file1.rar test_file 创建一个叫做 'file1.rar' 的包<br>
rar a file1.rar file1 file2 dir1 同时压缩 'file1', 'file2' 以及目录 'dir1'<br>
rar x file1.rar 解压rar包<br>
unrar x file1.rar 解压rar包<br>
tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>
tar -cvf archive.tar file1 file2 dir1 创建一个包含了 'file1', 'file2' 以及 'dir1'的档案文件<br>
tar -tf archive.tar 显示一个包中的内容<br>
tar -xvf archive.tar 释放一个包<br>
tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>
tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>
tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包<br>
tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>
tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包<br>
zip file1.zip file1 创建一个zip格式的压缩包<br>
zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>
unzip file1.zip 解压一个zip格式压缩包</p>
<h2 id="rpm-包-fedora-redhat及类似系统">RPM 包 - （Fedora, Redhat及类似系统）</h2>
<p>rpm -ivh package.rpm 安装一个rpm包<br>
rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>
rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>
rpm -F package.rpm 更新一个确定已经安装的rpm包<br>
rpm -e package_name.rpm 删除一个rpm包<br>
rpm -qa 显示系统中所有已经安装的rpm包<br>
rpm -qa | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的rpm包<br>
rpm -qi package_name 获取一个已安装包的特殊信息<br>
rpm -qg &quot;System Environment/Daemons&quot; 显示一个组件的rpm包<br>
rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>
rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>
rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表<br>
rpm -q package_name --whatprovides 显示一个rpm包所占的体积<br>
rpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l<br>
rpm -q package_name --changelog 显示一个rpm包的修改历史<br>
rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>
rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>
rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>
rpm --checksig package.rpm 确认一个rpm包的完整性<br>
rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>
rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>
rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>
rpm -Vp package.rpm 确认一个rpm包还未安装<br>
rpm2cpio package.rpm | cpio --extract --make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>
rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>
rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包</p>
<h2 id="yum-软件包升级器-fedora-redhat及类似系统">YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h2>
<p>yum install package_name 下载并安装一个rpm包<br>
yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>
yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>
yum update package_name 更新一个rpm包<br>
yum remove package_name 删除一个rpm包<br>
yum list 列出当前系统中安装的所有包<br>
yum search package_name 在rpm仓库中搜寻软件包<br>
yum clean packages 清理rpm缓存删除下载的包<br>
yum clean headers 删除所有头文件<br>
yum clean all 删除所有缓存的包和头文件</p>
<h2 id="deb-包-debian-ubuntu-以及类似系统">DEB 包 (Debian, Ubuntu 以及类似系统)</h2>
<p>dpkg -i package.deb 安装/更新一个 deb 包<br>
dpkg -r package_name 从系统删除一个 deb 包<br>
dpkg -l 显示系统中所有已经安装的 deb 包<br>
dpkg -l | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的deb包<br>
dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>
dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>
dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表<br>
dpkg -S /bin/ping 确认所给的文件由哪个deb包提供</p>
<h2 id="apt-软件工具-debian-ubuntu-以及类似系统">APT 软件工具 (Debian, Ubuntu 以及类似系统)</h2>
<p>apt-get install package_name 安装/更新一个 deb 包<br>
apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>
apt-get update 升级列表中的软件包<br>
apt-get upgrade 升级所有已安装的软件<br>
apt-get remove package_name 从系统删除一个deb包<br>
apt-get check 确认依赖的软件仓库正确<br>
apt-get clean 从下载的软件包中清理缓存<br>
apt-cache search searched-package 返回包含所要搜索字符串的软件包名称</p>
<h2 id="查看文件内容">查看文件内容</h2>
<p>cat file1 从第一个字节开始正向查看文件的内容<br>
tac file1 从最后一行开始反向查看一个文件的内容<br>
more file1 查看一个长文件的内容<br>
less file1 类似于 'more' 命令，但是它允许在文件中和正向操作一样的反向操作<br>
head -2 file1 查看一个文件的前两行<br>
tail -2 file1 查看一个文件的最后两行<br>
tail -f /var/log/messages 实时查看被添加到一个文件中的内容</p>
<h2 id="文本处理">文本处理</h2>
<p>cat file1 file2 ... | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>
cat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>
cat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>
grep Aug /var/log/messages 在文件 '/var/log/messages'中查找关键词&quot;Aug&quot;<br>
grep ^Aug /var/log/messages 在文件 '/var/log/messages'中查找以&quot;Aug&quot;开始的词汇<br>
grep [0-9] /var/log/messages 选择 '/var/log/messages' 文件中所有包含数字的行<br>
grep Aug -R /var/log/* 在目录 '/var/log' 及随后的目录中搜索字符串&quot;Aug&quot;<br>
sed 's/stringa1/stringa2/g' example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot;<br>
sed '/^<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 49: …所有空白行 
sed &#039;/ *#̲/d; /^'>/d&#039; example.txt 从example.txt文件中删除所有空白行 
sed &#039;/ *#/d; /^</span>/d' example.txt 从example.txt文件中删除所有注释和空白行<br>
echo 'esempio' | tr '[:lower:]' '[:upper:]' 合并上下单元格内容<br>
sed -e '1d' result.txt 从文件example.txt 中排除第一行<br>
sed -n '/stringa1/p' 查看只包含词汇 &quot;string1&quot;的行<br>
sed -e 's/ <em>$//' example.txt 删除每一行最后的空白字符<br>
sed -e 's/stringa1//g' example.txt 从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部<br>
sed -n '1,5p;5q' example.txt 查看从第一行到第5行内容<br>
sed -n '5p;5q' example.txt 查看第5行<br>
sed -e 's/00</em>/0/g' example.txt 用单个零替换多个零<br>
cat -n file1 标示文件的行数<br>
cat example.txt | awk 'NR%2==1' 删除example.txt文件中的所有偶数行<br>
echo a b c | awk '{print $1}' 查看一行第一栏<br>
echo a b c | awk '{print $1,$3}' 查看一行的第一和第三栏<br>
paste file1 file2 合并两个文件或两栏的内容<br>
paste -d '+' file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分<br>
sort file1 file2 排序两个文件的内容<br>
sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>
sort file1 file2 | uniq -u 删除交集，留下其他的行<br>
sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>
comm -1 file1 file2 比较两个文件的内容只删除 'file1' 所包含的内容<br>
comm -2 file1 file2 比较两个文件的内容只删除 'file2' 所包含的内容<br>
comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分</p>
<h2 id="字符设置和文件格式转换">字符设置和文件格式转换</h2>
<p>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>
unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>
recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>
recode -l | more 显示所有允许的转换格式</p>
<h2 id="文件系统分析">文件系统分析</h2>
<p>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块<br>
fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性<br>
fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>
e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>
e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>
fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>
fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性<br>
fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性<br>
dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性</p>
<h2 id="初始化一个文件系统">初始化一个文件系统</h2>
<p>mkfs /dev/hda1 在hda1分区创建一个文件系统<br>
mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统<br>
mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>
mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统<br>
fdformat -n /dev/fd0 格式化一个软盘<br>
mkswap /dev/hda3 创建一个swap文件系统</p>
<h2 id="swap文件系统">SWAP文件系统</h2>
<p>mkswap /dev/hda3 创建一个swap文件系统<br>
swapon /dev/hda3 启用一个新的swap文件系统<br>
swapon /dev/hda2 /dev/hdb3 启用两个swap分区</p>
<h2 id="备份">备份</h2>
<p>dump -0aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的完整备份<br>
dump -1aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的交互式备份<br>
restore -if /tmp/home0.bak 还原一个交互式备份<br>
rsync -rogpav --delete /home /tmp 同步两边的目录<br>
rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync<br>
rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录<br>
rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录<br>
dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of=hda.gz' 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>
dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件<br>
tar -Puf backup.tar /home/user 执行一次对 '/home/user' 目录的交互式备份操作<br>
( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr 'cd /home/share/ &amp;&amp; tar x -p' 通过ssh在远程目录中复制一个目录内容<br>
( tar c /home ) | ssh -C user@ip_addr 'cd /home/backup-home &amp;&amp; tar x -p' 通过ssh在远程目录中复制一个本地目录<br>
tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>
find /home/user1 -name '<em>.txt' | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 '.txt' 结尾的文件到另一个目录<br>
find /var/log -name '</em>.log' | tar cv --files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 '.log' 结尾的文件并做成一个bzip包<br>
dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>
dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容</p>
<h2 id="光盘">光盘</h2>
<p>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容<br>
mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>
mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>
mkisofs -J -allow-leading-dots -R -V &quot;Label CD&quot; -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件<br>
cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件<br>
gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件<br>
mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件<br>
cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>
cd-paranoia -- &quot;-3&quot; 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>
cdrecord --scanbus 扫描总线以识别scsi通道<br>
dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD</p>
<h2 id="网络-以太网和wifi无线">网络 - （以太网和WIFI无线）</h2>
<p>ifconfig eth0 显示一个以太网卡的配置<br>
ifup eth0 启用一个 'eth0' 网络设备<br>
ifdown eth0 禁用一个 'eth0' 网络设备<br>
ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>
ifconfig eth0 promisc 设置 'eth0' 成混杂模式以嗅探数据包 (sniffing)<br>
dhclient eth0 以dhcp模式启用 'eth0'<br>
route -n show routing table<br>
route add -net 0/0 gw IP_Gateway configura default gateway<br>
route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network '192.168.0.0/16'<br>
route del 0/0 gw IP_gateway remove static route<br>
echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward activate ip routing<br>
hostname show hostname of system<br>
host www.example.com lookup hostname to resolve name to ip address and viceversa(1)<br>
nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2)<br>
ip link show show link status of all interfaces<br>
mii-tool eth0 show link status of 'eth0'<br>
ethtool eth0 show statistics of network card 'eth0'<br>
netstat -tup show all active network connections and their PID<br>
netstat -tupl show all network services listening on the system and their PID<br>
tcpdump tcp port 80 show all HTTP traffic<br>
iwlist scan show wireless networks<br>
iwconfig eth1 show configuration of a wireless network card<br>
hostname show hostname<br>
host www.example.com lookup hostname to resolve name to ip address and viceversa<br>
nslookup www.example.com lookup hostname to resolve name to ip address and viceversa<br>
whois www.example.com lookup on Whois database</p>
<h2 id="go-top-index">GO TOP INDEX ^</h2>
<p>Microsoft Windows networks (SAMBA)<br>
nbtscan ip_addr netbios name resolution<br>
nmblookup -A ip_addr netbios name resolution<br>
smbclient -L ip_addr/hostname show remote shares of a windows host<br>
smbget -Rr smb://ip_addr/share like wget can download files from a host windows via smb<br>
mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share mount a windows network share</p>
<p>转发自：<a href="http://www.cnblogs.com/fnlingnzb-learner/p/5831284.html">原博客</a> 谢谢。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jdbc]]></title>
        <id>https://ysjhhhhhhh.github.io/post/jdbc</id>
        <link href="https://ysjhhhhhhh.github.io/post/jdbc">
        </link>
        <updated>2018-04-05T13:38:39.000Z</updated>
        <content type="html"><![CDATA[<p>一. JDBC编程概述</p>
<ol>
<li>
<p>什么JDBC<br>
  JDBC（Java Database Connection）：为多种关系数据库提供统一访问。它由一组用Java语言编写的类和接口组成。是Java访问数据库的标准和规范。</p>
</li>
<li>
<p>常见数据库介绍<br>
  Mysql：开源免费的数据库，小型的数据库。非常实用和受欢迎。已经被Oracle收购了.MySQL6.x版本也开始收费。<br>
  Oracle：收费的大型数据库，Oracle公司的产品。一般中大型公司会使用。Oracle收购了SUN公司，Mysql数据库。<br>
  DB2：IBM公司的收费数据库产品。常应用在银行系统和金融系统中.<br>
  SQLServer：MicroSoft 公司收费的中型的数据库。常常在C#、.net等语言中使用。<br>
  SyBase：提供了一个非常专业数据建模的工具PowerDesigner，但是数据库本身已经淡出历史舞台。<br>
  SQLite: 嵌入式的小型数据库，基本上用于移动端。<br>
  Java相关的数据库：MYSQL，Oracle。<br>
  数据库的设计和开发，sql语句的编写在这里不做详细的介绍。</p>
</li>
</ol>
<p>oracle.jpg<br>
3. JDBC开发原理<br>
  Java和数据库之间没有必然的联系，两者之间是如何连接的呢？虽然Java提供了各种数据库接口，但是我们并不知道各种数据库具体的实现原理，难以对接口进行具体的实现。<br>
  所以，数据库生产商提供了这些接口的实现类：驱动<br>
  Java提供访问数据库规范称为JDBC，而生产厂商提供规范的实现类称为驱动。</p>
<p>JDBC原理图.png</p>
<p>JDBC是接口，驱动是接口的实现，没有驱动将无法完成数据库连接，从而不能操作数据库。每个数据库厂商都需要提供自己的驱动，用来连接自己公司的数据库。<br>
二. JDBC开发步骤<br>
JDBC一般的开发步骤如下：<br>
首先要从官方网站上下载Mysql的驱动，并通过Eclipse导入驱动（jar包）<br>
导入驱动的方法.png</p>
<p>JDBC开发步骤如下：<br>
注册驱动（Driver）<br>
获得连接（Connection）<br>
获得语句执行平台（Statement）<br>
使用SQL语句进行处理<br>
释放资源，关闭链接<br>
数据库中创建示例：<br>
create table users(<br>
username varchar(10),<br>
pass varchar(10),<br>
nicheng varchar(30)<br>
);<br>
insert into users (username,pass,nicheng) values('wjy','wjykl22','凉凉夜色为你思念成河');<br>
select * from users;<br>
Java连接数据库<br>
1.注册驱动:<br>
官方API推荐方法：</p>
<p>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<br>
不推荐使用DriverManager.registerDriver(new com.mysql.jdbc.Driver());注册，以上代码有两点不足：</p>
<p>硬编码，后期不易维护<br>
驱动在源码中就被注册过，驱动会被两次注册<br>
Driver源码：<br>
public class Driver extends NonRegisteringDriver implements java.sql.Driver {<br>
static {<br>
try {<br>
java.sql.DriverManager.registerDriver(new Driver());<br>
} catch (SQLException E) {<br>
throw new RuntimeException(&quot;Can't register driver!&quot;);<br>
}<br>
}<br>
}<br>
2.获得连接:<br>
String url = &quot;jdbc:mysql://localhost:3306/jdbc&quot;;<br>
String username = &quot;root&quot;;<br>
String password = &quot;wjykl22&quot;;<br>
Connection con = DriverManager.getConnection(url, username, password);<br>
其中url：需要连接数据库的位置（网址）目前来说格式基本上固定。</p>
<p>第一部分：jdbc，这是固定的；<br>
第二部分：数据库名称，我们连接的是Mysql数据库，所以使用Mysql<br>
第三部分：由数据库厂商规定的，每个厂商都有各自的要求，分别由数据库服务器的IP地址（localhost）、端口号（3306），以及DATABASE名称(jdbc)组成。</p>
<p>username：数据库用户名。<br>
password：数据库密码。<br>
采用上述方法就可以获得数据库的链接。</p>
<p>3.获得执行平台并执行sql语句<br>
Statement stat = con.createStatement();<br>
int executeUpdate(String sql);//用于执行insert update delete语句.<br>
ResultSet executeQuery(String sql); //用于执行select语句.<br>
boolean execute(String sql); //用于执行select返回true 执行其他的语句返回false.<br>
4.结果集处理<br>
得到ResultSet结果集后，需要对其中的数据进行数据的提取，对于ResultSet结果集的处理方法：</p>
<p>Object getObject(int index) / Object getObject(String name) 获得任意对象<br>
String getString(int index) / Object getObject(String name) 获得字符串<br>
int getInt(int index) / Object getObject(String name) 获得整形<br>
double getDouble(int index) / Object getObject(String name) 获得双精度浮点型<br>
5.释放资源<br>
最后一步就是释放资源，与IO释放资源的方式如出一辙。</p>
<p>rs.close();<br>
stmt.close();<br>
con.close();<br>
总结<br>
完整的上述步骤如下：</p>
<p>public class JDBCDemo {<br>
public static void main(String args[]) {<br>
try {<br>
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<br>
String url = &quot;jdbc:mysql://localhost:3306/jdbc&quot;;<br>
String username = &quot;root&quot;;<br>
String password = &quot;wjykl22&quot;;<br>
Connection con = DriverManager.getConnection(url, username, password);<br>
Statement stat = con.createStatement();<br>
stat.executeUpdate(&quot;insert into users (username,pass,nicheng) values('wjy2','wjykl33','如水流央')&quot;);<br>
ResultSet rs = stat.executeQuery(&quot;select * from users&quot;);<br>
while(rs.next()) {<br>
System.out.println(rs.getString(&quot;username&quot;)<br>
+&quot;\t&quot;+rs.getString(&quot;pass&quot;)+&quot;\t&quot;+rs.getString(&quot;nicheng&quot;));<br>
}<br>
rs.close();<br>
stat.close();<br>
con.close();<br>
} catch (Exception e) {<br>
e.printStackTrace();<br>
}<br>
}<br>
}<br>
预处理对象方法<br>
  为了防止代码存在SQL注入漏洞，使得代码更加完善，我们一般采用预处理对象：PreparedStatement<br>
  每条sql语句所有的实际参数，都使用逗号分隔。</p>
<ol>
<li>预处理对象并执行sql语句<br>
String sql = &quot;insert into sort(sid,sname) values(?,?)&quot;;<br>
PreparedStatement psmt = conn.prepareStatement(sql)</li>
<li>设置实际参数<br>
void setXxx(int index, Xxx xx)<br>
完整的代码程序段如下：</li>
</ol>
<p>public class LoginDemo {<br>
/*<br>
* Java程序实现用户的登录，用户名和密码，数据库检查<br>
* 防止注入攻击<br>
* Statment有一个子接口PrepareStatment，表示预编译的SQL语句对象，可以高效的执行<br>
* 这个方法是Connection数据库连接的方法<br>
* 如何获取这个实现类呢？<br>
*/<br>
public static void main(String args[]) throws Exception {<br>
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<br>
String url = &quot;jdbc:mysql://localhost:3306/world&quot;;<br>
String username = &quot;root&quot;;<br>
String password = &quot;wjykl22&quot;;<br>
Connection con = DriverManager.getConnection(url,username,password);<br>
Scanner sc = new Scanner(System.in);<br>
String user = sc.nextLine();<br>
String pass = sc.nextLine();<br>
//执行sql语句，查询用户名和密码。<br>
//注意要写问号<br>
String sql = &quot;select * from users where username =? and pass =?&quot;;<br>
java.sql.PreparedStatement pst = con.prepareStatement(sql);<br>
//调用pst中的set方法<br>
pst.setObject(1, user);<br>
pst.setObject(2, pass);</p>
<pre><code>    System.out.println(sql);
    ResultSet rs = pst.executeQuery();
    while(rs.next()) {
        System.out.println(rs.getString(&quot;username&quot;) + &quot;    &quot; + rs.getString(&quot;pass&quot;));
    }
}
</code></pre>
<p>}<br>
三. 工具类撰写和使用<br>
  作为一名程序员最应该学会的事情就是偷懒。设想一下，如果我们要在多各程序中使用Mysql数据库，会有很多代码重复使用，我们可以创建一个工具类Utils，通过工具类来完成注册驱动，获得链接，获得执行平台以及释放资源的操作。<br>
  <br>
  代码如下：</p>
<p>public class JDBCUtils {<br>
public static final  String DRIVERNAME = &quot;com.mysql.jdbc.Driver&quot;;<br>
public static final  String URL = &quot;jdbc:mysql://localhost:3306/mydb&quot;;<br>
public static final  String USER = &quot;root&quot;;<br>
public static final  String PASSWORD = &quot;root&quot;;<br>
static {<br>
try {<br>
Class.forName(DRIVERNAME);<br>
} catch (ClassNotFoundException e) {<br>
System.out.println(&quot;数据库驱动注册失败！&quot;);<br>
}<br>
}<br>
public static Connection getConn() throws Exception {<br>
Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);<br>
return conn;<br>
}<br>
}<br>
通过调用Utils类中的各种静态方法来达到重复利用代码的效果。</p>
<p>四. properties配置文件<br>
  上述代码还是不太方便，如果要修改某个参数，需要修改源代码，有没有方法能够不修改源代码就能够完成配置的修改呢？<br>
  通常情况下，我们习惯使用properties文件来存储与数据库有关的配置文件。</p>
<p>文件位置：任意，建议src下<br>
文件名称：任意，扩展名为properties<br>
文件内容：一行一组数据，格式是“key=value”.<br>
3.1 key命名自定义，如果是多个单词，习惯使用点分隔。例如：jdbc.driver<br>
3.2 value值不支持中文，如果需要使用非英文字符，将进行unicode转换。<br>
例如：<br>
driver=com.mysql.jdbc.Driver<br>
url=jdbc:mysql://localhost:3306/jdbc<br>
user=root<br>
password=root</p>
<p>加载配置文件properties的方法：<br>
  对应properties文件处理，开发中也使用Properties对象进行。我们将采用加载properties文件获得流，然后使用Properties对象进行处理。</p>
<p>public class JDBCUtils {<br>
private static String driver;<br>
private static String url;<br>
private static String user;<br>
private static String password;<br>
static {<br>
try {<br>
// 1. 使用Properties处理流<br>
// 使用load()方法加载指定的流<br>
Properties props = new Properties();<br>
Reader is = new FileReader(&quot;db.properties&quot;);<br>
props.load(is);<br>
// 2. 使用getProperty(key)，通过key获得需要的值，<br>
driver = props.getProperty(&quot;driver&quot;);<br>
url = props.getProperty(&quot;url&quot;);<br>
user = props.getProperty(&quot;user&quot;);<br>
password = props.getProperty(&quot;password&quot;);<br>
} catch (Exception e) {<br>
throw new RuntimeException(e);<br>
}<br>
}</p>
<pre><code>/**
 * 获得连接
 */
public static Connection getConnection() {
    try {
        // 1 注册驱动
        Class.forName(driver);
        // 2 获得连接
        Connection conn = DriverManager.getConnection(url, user, password);
        return conn;
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS & EasyUI & LayUI]]></title>
        <id>https://ysjhhhhhhh.github.io/post/js-and-easyui-and-layui</id>
        <link href="https://ysjhhhhhhh.github.io/post/js-and-easyui-and-layui">
        </link>
        <updated>2018-04-03T11:55:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="javascript">JavaScript</h1>
<h2 id="1数据类型">1.数据类型</h2>
<p>​	JavaScript数据类型大体分为6个类型分别为：</p>
<p>​			Number数字	有BigInt可以保存精度更高的数字</p>
<p>​			String字符串</p>
<p>​			Boolean布尔</p>
<p>​			Object对象  包含:{&quot;Array&quot;,&quot;Function&quot;,&quot;RegExp&quot;,&quot;Date&quot;,&quot;JSON&quot;}</p>
<p>​			Undefined未定义</p>
<p>​			Null空</p>
<p>JavaScript中的变量和Java中一样，都需要先定义后使用。并且JavaScript中的变量都使用var进行修饰</p>
<h2 id="2对象">2.对象</h2>
<p>JavaScript中对象有两种，一种为内置对象，另一种为自定义对象</p>
<p>自定义对象的方法为</p>
<pre><code class="language-html">		&lt;script type=&quot;text/javascript&quot;&gt;
			//第一种方式
			var 名变量名 = {对象的属性};
			
			//第二种方式
			var 名变量名 = new function(){对象的属性};
		&lt;/script&gt;
</code></pre>
<p>内置对象有：</p>
<p>​		BOM即 浏览器对象模型(Browser Object Model)</p>
<p>​	浏览器对象包括</p>
<p>​	Window(当前窗口对象，可对窗口进行操作)</p>
<p>​		Navigator(浏览器对象，提供浏览器的相关信息)</p>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;
document.write(&quot;&lt;p&gt;浏览器产品名称：&quot;);
document.write(navigator.appName + &quot;&lt;/p&gt;&quot;);
 
document.write(&quot;&lt;p&gt;浏览器版本号：&quot;);
document.write(navigator.appVersion + &quot;&lt;/p&gt;&quot;);
 
document.write(&quot;&lt;p&gt;浏览器内部代码：&quot;);
document.write(navigator.appCodeName + &quot;&lt;/p&gt;&quot;);
 
document.write(&quot;&lt;p&gt;操作系统：&quot;);
document.write(navigator.platform + &quot;&lt;/p&gt;&quot;);
 
document.write(&quot;&lt;p&gt;是否启用Cookies：&quot;);
document.write(navigator.cookieEnabled + &quot;&lt;/p&gt;&quot;);
 
document.write(&quot;&lt;p&gt;浏览器的用户代理报头：&quot;);
document.write(navigator.userAgent + &quot;&lt;/p&gt;&quot;);
&lt;/script&gt;
</code></pre>
<p>​		Screen (客户端屏幕对象,对显示的区域进行操作)</p>
<pre><code class="language-html">&lt;html&gt;
&lt;body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
document.write(&quot;用户的屏幕分辨率: &quot;)
document.write(screen.width + &quot;*&quot; + screen.height)
document.write(&quot;&lt;br /&gt;&quot;)
document.write(&quot;可用区域大小: &quot;)
document.write(screen.availWidth + &quot;*&quot; + screen.availHeight)
document.write(&quot;&lt;br /&gt;&quot;)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>​		History(访问历史，浏览器左上角有个前进按钮和后退按钮，此对象可以对浏览历史进行操作)</p>
<pre><code class="language-html">&lt;script&gt;
function goBack()
  {
     history.back();
  }
&lt;/script&gt;
 
&lt;button onclick=&quot;goBack()&quot;&gt;返回&lt;/button&gt;
</code></pre>
<p>​		Location(浏览器地址对象，就是浏览器上方的地址栏，可以操作地址实现页面跳转)</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot; /&gt;
		&lt;title&gt;&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;跳转&quot; onclick=&quot;but()&quot;/&gt;
	&lt;/body&gt;
	&lt;script type=&quot;text/javascript&quot;&gt;
		function but(){
			location.href=&quot;http://www.baidu.com&quot;;	
		}
	&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>​		Document（正文对象，使用这个对象可以动态向页面中添加想添加的内容）</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot; /&gt;
		&lt;title&gt;&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;插入&quot; onclick=&quot;but()&quot;/&gt;
	&lt;/body&gt;
	&lt;script type=&quot;text/javascript&quot;&gt;
		function but(){
			document.write(&quot;&lt;h1&gt;这是插入的标题&lt;/h1&gt;&quot;)		
		}
	&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="3函数">3.函数</h2>
<p>定义一个函数的方法：</p>
<pre><code class="language-html">&lt;script&gt;
function print(此处防止函数需要的参数，参数可以为各种类型，如果不需要可以不填){
  document.write(&quot;这一句话是由一个自定义函数打印&quot;);
}
print();
&lt;/script&gt;
</code></pre>
<p>调用函数的方法：</p>
<pre><code class="language-html">&lt;script&gt;
//调用函数的方法
    函数名(参数);
&lt;/script&gt;
</code></pre>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;
    //自调用函数
		(
             function(){
			document.write(&quot;&lt;h1&gt;这是插入的标题&lt;/h1&gt;&quot;)
			}
        )();
		
	&lt;/script&gt;
</code></pre>
<h2 id="4jquery">4.jQuery</h2>
<p>什么是jQuery：jQuery是一个JavaScript类库，对原生的JS进行了全方面的封装。</p>
<p>jQuery的好处：jQuery的使用可以极大减少js的代码量，用更少的代码做更多的事。</p>
<p>引入jQuery</p>
<pre><code class="language-html">//引入方式一：下载jQuery包，将解压后的文件复制到项目文件中，在head中引入
&lt;head&gt;
&lt;script src=&quot;jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;

//引入方式二：通过 CDN（内容分发网络） 引用它。(百度CDN)
&lt;head&gt;
&lt;script src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;
&lt;/script&gt;
&lt;/head&gt;

//使用第二种方式可能会因为网络原因，或者无法获取远程jQuery文件导致jQuery引入失败
</code></pre>
<p>使用jQuery</p>
<pre><code class="language-html">&lt;script&gt;
	$(selector).action()

	$(selector)是选择器,其中selector代表特定的值，用来根据值选定元素如：(&quot;#id的值&quot;)

    action()代表方法，如attr()用来操作属性
&lt;/script&gt;
</code></pre>
<p>jQuery可以对HTML进行操作：</p>
<p>​		DOM操作</p>
<p>​		属性操作</p>
<p>​		内容操作</p>
<p>​		样式操作</p>
<p>jQuery事件</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">鼠标事件</td>
<td style="text-align:left">键盘事件</td>
<td style="text-align:left">表单事件</td>
<td style="text-align:left">文档/窗口事件</td>
</tr>
<tr>
<td style="text-align:left">click</td>
<td style="text-align:left">keypress</td>
<td style="text-align:left">submit</td>
<td style="text-align:left">load</td>
</tr>
<tr>
<td style="text-align:left">dblclick</td>
<td style="text-align:left">keydown</td>
<td style="text-align:left">change</td>
<td style="text-align:left">resize</td>
</tr>
<tr>
<td style="text-align:left">mouseenter</td>
<td style="text-align:left">keyup</td>
<td style="text-align:left">focus</td>
<td style="text-align:left">scroll</td>
</tr>
<tr>
<td style="text-align:left">mouseleave</td>
<td style="text-align:left"></td>
<td style="text-align:left">blur</td>
<td style="text-align:left">unload</td>
</tr>
<tr>
<td style="text-align:left">hover</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>jQuery也可以添加动画效果：</p>
<p>​		显示隐藏</p>
<p>​		淡出淡入</p>
<p>​		滑动</p>
<p>jQuery遍历也很方便</p>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;
		
		//遍历数组
		var list=[&quot;第一个元素&quot;,&quot;第二个元素&quot;,&quot;第三个元素&quot;,&quot;第四个元素&quot;];
		$.each(list,function(index,obj){
			console.log(&quot;下标&quot;+index+&quot;:&quot;+obj);
		})
		
&lt;/script&gt;
</code></pre>
<h1 id="easyui">EasyUI</h1>
<p>EasyUI 是一个基于 jQuery 的框架，集成了各种用户界面插件。</p>
<p>EasyUI 框架提供了创建网页所需的一切，帮助您轻松建立站点</p>
<p>EasyUI提供的组件：</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1567838112112.png" alt="1567838112112"></figure>
<p>利用EasyUI构建一个页面：</p>
<ol>
<li>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;UTF-8&quot;&gt;
		&lt;title&gt;Basic Tree - jQuery EasyUI Demo&lt;/title&gt;
		&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/themes/default/easyui.css&quot;&gt;
		&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/themes/icon.css&quot;&gt;
		&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/demo.css&quot;&gt;
		&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;
		&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.easyui.min.js&quot;&gt;&lt;/script&gt;

		&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/index.css&quot; /&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id=&quot;panel&quot; class=&quot;easyui-panel&quot; title=&quot;智能停车系统后台管理&quot; style=&quot;width:100%;height:800px;padding:0px;&quot;&gt;

			&lt;div style=&quot;margin-top: 5px;&quot;&gt;&lt;/div&gt;
			&lt;div id=&quot;layout&quot; class=&quot;easyui-layout&quot; style=&quot;width:100%;height:100%;&quot;&gt;
				&lt;div data-options=&quot;region:'west',iconCls:'icon-cut'&quot; title=&quot;导航&quot; style=&quot;width:30%;padding:0px&quot;&gt;

					&lt;div class=&quot;easyui-panel&quot; style=&quot;padding:5px&quot;&gt;
						&lt;ul class=&quot;easyui-tree&quot; data-options=&quot;lines:true&quot;&gt;&lt;/ul&gt;
					&lt;/div&gt;

				&lt;/div&gt;
				&lt;div id=&quot;center&quot; data-options=&quot;region:'center',headerCls:'center_css'&quot; title=&quot;Center&quot;&gt;
					&lt;div class=&quot;easyui-tabs&quot; style=&quot;width:100%;height:100%&quot;&gt;
						&lt;div title=&quot;起始页&quot; style=&quot;padding:10px&quot;&gt;
							&lt;ul class=&quot;easyui-tree&quot; data-options=&quot;url:'tree_data1.json',method:'get',animate:true&quot;&gt;&lt;/ul&gt;
						&lt;/div&gt;
						&lt;div title=&quot;添加停车区域&quot; data-options=&quot;iconCls:'icon-help',closable:true&quot; style=&quot;padding:10px&quot;&gt;
							This is the help content.
						&lt;/div&gt;
						&lt;div title=&quot;停车区域管理&quot; data-options=&quot;iconCls:'icon-help',closable:true&quot; style=&quot;padding:10px&quot;&gt;
							This is the help content.
						&lt;/div&gt;
						&lt;div title=&quot;用户管理&quot; data-options=&quot;iconCls:'icon-help',closable:true&quot; style=&quot;padding:10px&quot;&gt;
							&lt;div class=&quot;easyui-panel&quot; style=&quot;padding:5px;&quot;&gt;
								&lt;a href=&quot;#&quot; class=&quot;easyui-linkbutton&quot; data-options=&quot;plain:true&quot;&gt;修改&lt;/a&gt;
								&lt;a href=&quot;#&quot; class=&quot;easyui-menubutton&quot; data-options=&quot;menu:'#mm1',iconCls:'icon-edit'&quot;&gt;删除&lt;/a&gt;
								&lt;a href=&quot;#&quot; class=&quot;easyui-menubutton&quot; data-options=&quot;menu:'#mm2',iconCls:'icon-help'&quot;&gt;刷新&lt;/a&gt;
								&lt;a href=&quot;#&quot; class=&quot;easyui-menubutton&quot; data-options=&quot;menu:'#mm3'&quot;&gt;取消选中&lt;/a&gt;
								&lt;a href=&quot;#&quot; class=&quot;easyui-menubutton&quot; data-options=&quot;menu:'#mm3'&quot;&gt;导出到excel&lt;/a&gt;
							&lt;/div&gt;
							&lt;div id=&quot;mm1&quot; style=&quot;width:150px;&quot;&gt;
								&lt;div data-options=&quot;iconCls:'icon-undo'&quot;&gt;Undo&lt;/div&gt;
								&lt;div data-options=&quot;iconCls:'icon-redo'&quot;&gt;Redo&lt;/div&gt;
								&lt;div class=&quot;menu-sep&quot;&gt;&lt;/div&gt;
								&lt;div&gt;Cut&lt;/div&gt;
								&lt;div&gt;Copy&lt;/div&gt;
								&lt;div&gt;Paste&lt;/div&gt;
								&lt;div class=&quot;menu-sep&quot;&gt;&lt;/div&gt;
								&lt;div&gt;
									&lt;span&gt;Toolbar&lt;/span&gt;
									&lt;div&gt;
										&lt;div&gt;Address&lt;/div&gt;
										&lt;div&gt;Link&lt;/div&gt;
										&lt;div&gt;Navigation Toolbar&lt;/div&gt;
										&lt;div&gt;Bookmark Toolbar&lt;/div&gt;
										&lt;div class=&quot;menu-sep&quot;&gt;&lt;/div&gt;
										&lt;div&gt;New Toolbar...&lt;/div&gt;
									&lt;/div&gt;
								&lt;/div&gt;
								&lt;div data-options=&quot;iconCls:'icon-remove'&quot;&gt;Delete&lt;/div&gt;
								&lt;div&gt;Select All&lt;/div&gt;
							&lt;/div&gt;
							&lt;div id=&quot;mm2&quot; style=&quot;width:100px;&quot;&gt;
								&lt;div&gt;Help&lt;/div&gt;
								&lt;div&gt;Update&lt;/div&gt;
								&lt;div&gt;About&lt;/div&gt;
							&lt;/div&gt;
							&lt;div id=&quot;mm3&quot; class=&quot;menu-content&quot; style=&quot;background:#f0f0f0;padding:10px;text-align:left&quot;&gt;
								&lt;img src=&quot;http://www.jeasyui.com/images/logo1.png&quot; style=&quot;width:150px;height:50px&quot;&gt;
								&lt;p style=&quot;font-size:14px;color:#444;&quot;&gt;Try jQuery EasyUI to build your modern, interactive, javascript
									applications.&lt;/p&gt;
							&lt;/div&gt;
							&lt;form action=&quot;&quot; method=&quot;&quot; style=&quot;margin-top: 5px;&quot;&gt;
								用户名:
								&lt;input class=&quot;easyui-textbox&quot; style=&quot;width:150px;height:25px&quot;&gt;
								&amp;nbsp;
								姓名:
								&lt;input class=&quot;easyui-textbox&quot; style=&quot;width:150px;height:25px&quot;&gt;
								&amp;nbsp;
								出生日期:
								&lt;input class=&quot;easyui-textbox&quot; style=&quot;width:150px;height:25px&quot;&gt;
								&amp;nbsp;
								&lt;input type=&quot;button&quot; data-options=&quot;iconCls:'icon-search'&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;搜索&quot; /&gt;
							&lt;/form&gt;
							&lt;table class=&quot;easyui-datagrid&quot;&gt;
								&lt;thead&gt;
									&lt;tr&gt;
										&lt;th data-options=&quot;field:'nickname'&quot;&gt;用户名&lt;/th&gt;
										&lt;th data-options=&quot;field:'name'&quot;&gt;姓名&lt;/th&gt;
										&lt;th data-options=&quot;field:'sex'&quot;&gt;性别&lt;/th&gt;
										&lt;th data-options=&quot;field:'birthday'&quot;&gt;出生日期&lt;/th&gt;
										&lt;th data-options=&quot;field:'photo'&quot;&gt;用户照片&lt;/th&gt;
										&lt;th data-options=&quot;field:'phone'&quot;&gt;联系电话&lt;/th&gt;
									&lt;/tr&gt;
								&lt;/thead&gt;
								&lt;tbody&gt;
									&lt;tr&gt;
										&lt;td&gt;aaa&lt;/td&gt;
										&lt;td&gt;张三&lt;/td&gt;
										&lt;td&gt;男&lt;/td&gt;
										&lt;td&gt;1998，8，8&lt;/td&gt;
										&lt;td&gt;&lt;img src=&quot;1.jpg&quot;&gt;&lt;/td&gt;
										&lt;td&gt;18888888888&lt;/td&gt;

									&lt;/tr&gt;
								&lt;/tbody&gt;
							&lt;/table&gt;
						&lt;/div&gt;
						&lt;div title=&quot;修改密码&quot; data-options=&quot;iconCls:'icon-help',closable:true&quot; style=&quot;padding:10px&quot;&gt;
							This is the help content.
						&lt;/div&gt;
						&lt;div title=&quot;添加用户&quot; data-options=&quot;iconCls:'icon-help',closable:true&quot; style=&quot;padding:10px&quot;&gt;
							This is the help content.
						&lt;/div&gt;
					&lt;/div&gt;

				&lt;/div&gt;
			&lt;/div&gt;
		&lt;/div&gt;

	&lt;/body&gt;
	&lt;script type=&quot;text/javascript&quot; src=&quot;js/tree.js&quot;&gt;

	&lt;/script&gt;
	&lt;script type=&quot;text/javascript&quot; src=&quot;js/index.js&quot;&gt;&lt;/script&gt;
&lt;/html&gt;

</code></pre>
</li>
</ol>
<p>EasyUI的使用可以参考EasyUI官网：</p>
<p>https://www.jeasyui.com/</p>
<h1 id="layui">Layui</h1>
<p>layui（谐音：类UI) 是一款采用自身模块规范编写的前端 UI 框架，遵循原生 HTML/CSS/JS 的书写与组织形式，门槛极低，拿来即用。其外在极简，却又不失饱满的内在，体积轻盈，组件丰盈，从核心代码到 API 的每一处细节都经过精心雕琢，非常适合界面的快速开发。layui 首个版本发布于2016年金秋，她区别于那些基于 MVVM 底层的 UI 框架，却并非逆道而行，而是信奉返璞归真之道。准确地说，她更多是为服务端程序员量身定做，你无需涉足各种前端工具的复杂配置，只需面对浏览器本身，让一切你所需要的元素与交互，从这里信手拈来。</p>
<p>Layui的扁平化风格相比EasyUI更加美观</p>
<p>Layui提供的组件:</p>
<figure data-type="image" tabindex="2"><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1567838515702.png" alt="1567838515702"></figure>
<p>LayUI具体使用：</p>
<p>html代码：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot; /&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;layui/css/layui.css&quot; /&gt;
		&lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;
		&lt;script type=&quot;text/javascript&quot; src=&quot;layui/layui.js&quot;&gt;&lt;/script&gt;
		&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/main.css&quot; /&gt;
	&lt;/head&gt;
	&lt;body&gt;

		&lt;div class=&quot;out_div&quot;&gt;
			&lt;ul class=&quot;layui-nav top_bgc&quot;&gt;
				&lt;li class=&quot;layui-nav-item&quot;&gt;
					&lt;span style=&quot;color: #009688;font-size: 22px;&quot;&gt;SMS聊天室&lt;/span&gt;
				&lt;/li&gt;
				&lt;li class=&quot;layui-nav-item float_li&quot;&gt;
					&lt;a href=&quot;&quot;&gt;退出&lt;/a&gt;
				&lt;/li&gt;
				&lt;li class=&quot;layui-nav-item float_li&quot;&gt;
					&lt;a href=&quot;&quot;&gt;&lt;img src=&quot;//t.cn/RCzsdCq&quot; class=&quot;layui-nav-img&quot;&gt;用户名&lt;/a&gt;
					&lt;dl class=&quot;layui-nav-child&quot;&gt;
						&lt;dd&gt;&lt;a href=&quot;modify.html&quot;&gt;修改信息&lt;/a&gt;&lt;/dd&gt;
						&lt;dd&gt;&lt;a href=&quot;javascript:;&quot;&gt;安全管理&lt;/a&gt;&lt;/dd&gt;
						&lt;dd&gt;&lt;a href=&quot;javascript:;&quot;&gt;退了&lt;/a&gt;&lt;/dd&gt;
					&lt;/dl&gt;
				&lt;/li&gt;
			&lt;/ul&gt;

			&lt;div class=&quot;layui-row&quot; style=&quot;height:94%;&quot;&gt;
				&lt;div class=&quot;layui-col-md2 layout_west layoutAll&quot;&gt;
					&lt;ul class=&quot;layui-nav layui-nav-tree&quot; lay-filter=&quot;test&quot; style=&quot;width: 100%;&quot;&gt;
						&lt;!-- 侧边导航: &lt;ul class=&quot;layui-nav layui-nav-tree layui-nav-side&quot;&gt; --&gt;
						&lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt;
							&lt;a href=&quot;javascript:;&quot;&gt;消息管理&lt;/a&gt;
							&lt;dl class=&quot;layui-nav-child&quot;&gt;
								&lt;dd&gt;&lt;a href=&quot;msgall.html&quot;&gt;收件箱（原生js生成）&lt;/a&gt;&lt;/dd&gt;
								&lt;dd&gt;&lt;a href=&quot;javascript:;&quot;&gt;收件箱（LayUI表格）&lt;/a&gt;&lt;/dd&gt;
								&lt;dd&gt;&lt;a href=&quot;readmsg.html&quot;&gt;发件箱&lt;/a&gt;&lt;/dd&gt;
								&lt;dd&gt;&lt;a href=&quot;newmsg.html&quot;&gt;写消息&lt;/a&gt;&lt;/dd&gt;
							&lt;/dl&gt;
						&lt;/li&gt;
						&lt;li class=&quot;layui-nav-item&quot;&gt;
							&lt;a href=&quot;javascript:;&quot;&gt;账户管理&lt;/a&gt;
							&lt;dl class=&quot;layui-nav-child&quot;&gt;
								&lt;dd&gt;&lt;a href=&quot;javascript:;&quot;&gt;收件箱（原生js生成）&lt;/a&gt;&lt;/dd&gt;
								&lt;dd&gt;&lt;a href=&quot;javascript:;&quot;&gt;收件箱（LayUI表格）&lt;/a&gt;&lt;/dd&gt;
								&lt;dd&gt;&lt;a href=&quot;&quot;&gt;发件箱&lt;/a&gt;&lt;/dd&gt;
								&lt;dd&gt;&lt;a href=&quot;&quot;&gt;写消息&lt;/a&gt;&lt;/dd&gt;
							&lt;/dl&gt;
						&lt;/li&gt;
					&lt;/ul&gt;
				&lt;/div&gt;
				&lt;div id=&quot;content&quot; class=&quot;layui-col-md10 layout_east layoutAll content&quot;&gt;

					&lt;br&gt;
					&lt;br&gt;
					&lt;p&gt;首页&amp;nbsp;/&amp;nbsp;消息管理&amp;nbsp;/&amp;nbsp;收件箱&lt;/p&gt;
					&lt;table id=&quot;msgtab&quot; class=&quot;layui-table&quot; lay-filter=&quot;msgEvent&quot;&gt;&lt;/table&gt;
				&lt;/div&gt;
			&lt;/div&gt;
		&lt;/div&gt;

	&lt;/body&gt;
	&lt;script type=&quot;text/html&quot; id=&quot;barDemo&quot;&gt;
		&lt;a class=&quot;layui-btn layui-btn-xs&quot; lay-event=&quot;edit&quot;&gt;回复&lt;/a&gt;
		&lt;a class=&quot;layui-btn layui-btn-danger layui-btn-xs&quot; lay-event=&quot;del&quot;&gt;删除&lt;/a&gt;
	&lt;/script&gt;
	&lt;script type=&quot;text/html&quot; id=&quot;status_Tpl&quot;&gt;
		{{#  if(d.status === 1){ }}
    &lt;img src=&quot;img/sms_readed.png&quot; &gt;
  {{#  } else { }}
    &lt;img src=&quot;img/sms_unReaded.png&quot; &gt;
  {{#  } }}
&lt;/script&gt;
&lt;script src=&quot;js/msgall.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/general.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/html&gt;

</code></pre>
<p>添加依赖的js(这里有点多，有些没用上，可以根据自己所需要进行添加)：</p>
<pre><code class="language-js">//Demo
layui.use('form', function(){
  var form = layui.form;
  
  //监听提交
  form.on('submit(formDemo)', function(data){
    layer.msg(JSON.stringify(data.field));
    return false;
  });
});

layui.use('layedit', function(){
  var layedit = layui.layedit;
  layedit.build('textarea_new'); //建立编辑器
});


layui.use('upload', function(){
  var upload = layui.upload;
   
  //执行实例
  var uploadInst = upload.render({
    elem: '#test1' //绑定元素
    ,url: '/upload/' //上传接口
    ,done: function(res){
      //上传完毕回调
    }
    ,error: function(){
      //请求异常回调
    }
  });
});

//注意：导航 依赖 element 模块，否则无法进行功能性操作
layui.use('element', function() {
	var element = layui.element;
});



layui.use('upload', function(){
  var $ = layui.jquery
  ,upload = layui.upload;
  
  //普通图片上传
  var uploadInst = upload.render({
    elem: '#test1'
    ,url: '/upload/'
    ,before: function(obj){
      //预读本地文件示例，不支持ie8
      obj.preview(function(index, file, result){
        $('#demo1').attr('src', result); //图片链接（base64）
      });
    }
    ,done: function(res){
      //如果上传失败
      if(res.code &gt; 0){
        return layer.msg('上传失败');
      }
      //上传成功
    }
    ,error: function(){
      //演示失败状态，并实现重传
      var demoText = $('#demoText');
      demoText.html('&lt;span style=&quot;color: #FF5722;&quot;&gt;上传失败&lt;/span&gt; &lt;a class=&quot;layui-btn layui-btn-xs demo-reload&quot;&gt;重试&lt;/a&gt;');
      demoText.find('.demo-reload').on('click', function(){
        uploadInst.upload();
      });
    }
  });
  
  //多图片上传
  upload.render({
    elem: '#test2'
    ,url: '/upload/'
    ,multiple: true
    ,before: function(obj){
      //预读本地文件示例，不支持ie8
      obj.preview(function(index, file, result){
        $('#demo2').append('&lt;img src=&quot;'+ result +'&quot; alt=&quot;'+ file.name +'&quot; class=&quot;layui-upload-img&quot;&gt;')
      });
    }
    ,done: function(res){
      //上传完毕
    }
  });
  
  //指定允许上传的文件类型
  upload.render({
    elem: '#test3'
    ,url: '/upload/'
    ,accept: 'file' //普通文件
    ,done: function(res){
      console.log(res)
    }
  });
  upload.render({ //允许上传的文件后缀
    elem: '#test4'
    ,url: '/upload/'
    ,accept: 'file' //普通文件
    ,exts: 'zip|rar|7z' //只允许上传压缩文件
    ,done: function(res){
      console.log(res)
    }
  });
  upload.render({
    elem: '#test5'
    ,url: '/upload/'
    ,accept: 'video' //视频
    ,done: function(res){
      console.log(res)
    }
  });
  upload.render({
    elem: '#test6'
    ,url: '/upload/'
    ,accept: 'audio' //音频
    ,done: function(res){
      console.log(res)
    }
  });
  
  //设定文件大小限制
  upload.render({
    elem: '#test7'
    ,url: '/upload/'
    ,size: 60 //限制文件大小，单位 KB
    ,done: function(res){
      console.log(res)
    }
  });
  
  //同时绑定多个元素，并将属性设定在元素上
  upload.render({
    elem: '.demoMore'
    ,before: function(){
      layer.tips('接口地址：'+ this.url, this.item, {tips: 1});
    }
    ,done: function(res, index, upload){
      var item = this.item;
      console.log(item); //获取当前触发上传的元素，layui 2.1.0 新增
    }
  })
  
  //选完文件后不自动上传
  upload.render({
    elem: '#test8'
    ,url: '/upload/'
    ,auto: false
    //,multiple: true
    ,bindAction: '#test9'
    ,done: function(res){
      console.log(res)
    }
  });
  
  //拖拽上传
  upload.render({
    elem: '#test10'
    ,url: '/upload/'
    ,done: function(res){
      console.log(res)
    }
  });
  
  //多文件列表示例
  var demoListView = $('#demoList')
  ,uploadListIns = upload.render({
    elem: '#testList'
    ,url: '/upload/'
    ,accept: 'file'
    ,multiple: true
    ,auto: false
    ,bindAction: '#testListAction'
    ,choose: function(obj){   
      var files = this.files = obj.pushFile(); //将每次选择的文件追加到文件队列
      //读取本地文件
      obj.preview(function(index, file, result){
        var tr = $(['&lt;tr id=&quot;upload-'+ index +'&quot;&gt;'
          ,'&lt;td&gt;'+ file.name +'&lt;/td&gt;'
          ,'&lt;td&gt;'+ (file.size/1014).toFixed(1) +'kb&lt;/td&gt;'
          ,'&lt;td&gt;等待上传&lt;/td&gt;'
          ,'&lt;td&gt;'
            ,'&lt;button class=&quot;layui-btn layui-btn-xs demo-reload layui-hide&quot;&gt;重传&lt;/button&gt;'
            ,'&lt;button class=&quot;layui-btn layui-btn-xs layui-btn-danger demo-delete&quot;&gt;删除&lt;/button&gt;'
          ,'&lt;/td&gt;'
        ,'&lt;/tr&gt;'].join(''));
        
        //单个重传
        tr.find('.demo-reload').on('click', function(){
          obj.upload(index, file);
        });
        
        //删除
        tr.find('.demo-delete').on('click', function(){
          delete files[index]; //删除对应的文件
          tr.remove();
          uploadListIns.config.elem.next()[0].value = ''; //清空 input file 值，以免删除后出现同名文件不可选
        });
        
        demoListView.append(tr);
      });
    }
    ,done: function(res, index, upload){
      if(res.code == 0){ //上传成功
        var tr = demoListView.find('tr#upload-'+ index)
        ,tds = tr.children();
        tds.eq(2).html('&lt;span style=&quot;color: #5FB878;&quot;&gt;上传成功&lt;/span&gt;');
        tds.eq(3).html(''); //清空操作
        return delete this.files[index]; //删除文件队列已经上传成功的文件
      }
      this.error(index, upload);
    }
    ,error: function(index, upload){
      var tr = demoListView.find('tr#upload-'+ index)
      ,tds = tr.children();
      tds.eq(2).html('&lt;span style=&quot;color: #FF5722;&quot;&gt;上传失败&lt;/span&gt;');
      tds.eq(3).find('.demo-reload').removeClass('layui-hide'); //显示重传
    }
  });
  
  //绑定原始文件域
  upload.render({
    elem: '#test20'
    ,url: '/upload/'
    ,done: function(res){
      console.log(res)
    }
  });
  
});

</code></pre>
<p>json数据：</p>
<pre><code class="language-json">{
  &quot;code&quot;: 0,
  &quot;message&quot;: &quot;&quot;, 
  &quot;count&quot;: 100, 
  &quot;data&quot;: 
  [
	  {&quot;id&quot;:1,&quot;status&quot;:1,&quot;title&quot;:&quot;题目一&quot;,&quot;time&quot;:&quot;2019.09.06&quot;},
	  {&quot;id&quot;:2,&quot;status&quot;:0,&quot;title&quot;:&quot;题目一&quot;,&quot;time&quot;:&quot;2019.09.06&quot;},
	  {&quot;id&quot;:3,&quot;status&quot;:1,&quot;title&quot;:&quot;题目一&quot;,&quot;time&quot;:&quot;2019.09.06&quot;},
	  {&quot;id&quot;:4,&quot;status&quot;:0,&quot;title&quot;:&quot;题目一&quot;,&quot;time&quot;:&quot;2019.09.06&quot;},
	  {&quot;id&quot;:5,&quot;status&quot;:0,&quot;title&quot;:&quot;题目一&quot;,&quot;time&quot;:&quot;2019.09.06&quot;},
	  {&quot;id&quot;:6,&quot;status&quot;:0,&quot;title&quot;:&quot;题目一&quot;,&quot;time&quot;:&quot;2019.09.06&quot;},
	  {&quot;id&quot;:7,&quot;status&quot;:0,&quot;title&quot;:&quot;题目一&quot;,&quot;time&quot;:&quot;2019.09.06&quot;},
	  {&quot;id&quot;:8,&quot;status&quot;:1,&quot;title&quot;:&quot;题目一&quot;,&quot;time&quot;:&quot;2019.09.06&quot;},
	  {&quot;id&quot;:9,&quot;status&quot;:1,&quot;title&quot;:&quot;题目一&quot;,&quot;time&quot;:&quot;2019.09.06&quot;},
	  {&quot;id&quot;:10,&quot;status&quot;:0,&quot;title&quot;:&quot;题目一&quot;,&quot;time&quot;:&quot;2019.09.06&quot;}
  ]
}
</code></pre>
<p>js代码：</p>
<pre><code class="language-javascript">layui.use('table', function() {
	var table = layui.table;

	//第一个实例
	table.render({
		elem: '#msgtab',
		height: 512,
		url: 'data/msg.json' //数据接口
			,
		page: true //开启分页
			,
		cols: [
			[ //表头
				{
					field: 'id',
					width: 80,
					title: 'ID',
					sort: true
				}, {
					field: 'status',
					width: 100,
					title: '状态',
					templet: '#status_Tpl'
				}, {
					field: 'title',
					width: 600,
					title: '标题',
					event: 'inmsg',
					sort: true
				}, {
					field: 'operation',
					width: 150,
					toolbar: '#barDemo',
					title: '操作'
				}, {
					field: 'time',
					title: '时间',
					minWidth: 150
				}
			]
		]
	});

});


layui.use('table', function() {
	var table = layui.table;
	//监听单元格事件
	table.on('tool(msgEvent)', function(obj) {
		var data = obj.data;
		if (obj.event === 'inmsg') {
			alert(data.id);
			//ajax向服务器发送请求
			// var ajax=XMLHttpRequest();
		}
		if (obj.event === 'del') {
			layer.confirm('真的删除行么', function(index) {
				obj.del();
				layer.close(index);
			});
		} else if (obj.event === 'edit') {
			
		}
	});
	
});



</code></pre>
<p>Layui官方（官方教程有很详细的使用教程）：</p>
<p>https://www.layui.com/</p>
<p>本周的总结就到这里</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ajax]]></title>
        <id>https://ysjhhhhhhh.github.io/post/ajax</id>
        <link href="https://ysjhhhhhhh.github.io/post/ajax">
        </link>
        <updated>2018-03-31T09:38:57.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="ajax">Ajax</h2>
<ul>
<li>是什么?</li>
</ul>
<blockquote>
<p>“Asynchronous Javascript And XML”（异步JavaScript和XML），</p>
</blockquote>
<blockquote>
<p>并不是新的技术，只是把原有的技术，整合到一起而已。</p>
</blockquote>
<pre><code>1.使用CSS和XHTML来表示。
2.使用DOM模型来交互和动态显示。
3.使用XMLHttpRequest来和服务器进行异步通信。
4.使用javascript来绑定和调用。
</code></pre>
<ul>
<li>有什么用?</li>
</ul>
<blockquote>
<p>咱们的网页如果想要刷新局部内容。 那么需要重新载入整个网页。用户体验不是很好。  就是为了解决局部刷新的问题。 保持其他部分不动，只刷新某些地方。</p>
</blockquote>
<h3 id="数据请求-get">数据请求 Get</h3>
<h4 id="创建ajax请求对象">创建ajax请求对象</h4>
<pre><code class="language-javascript">function  ajaxFunction(){
	    var xmlHttp;
	    try{ // Firefox, Chrome, Opera 8.0+, Safari
	        xmlHttp=new XMLHttpRequest();
	    }
	    catch (e){
	        try{// Internet Explorer（高版本）
	            xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
	        }
	        catch (e){
	            try{// Internet Explorer（低版本）
	                xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
	            }
	            catch (e){}
	        }
	    }
	    return xmlHttp;
	}
</code></pre>
<h4 id="发送请求">发送请求</h4>
<pre><code class="language-javascript">//执行get请求
function get() {

    //1. 创建xmlhttprequest 对象
    var request = ajaxFunction();

    //2. 发送请求。
    /*	
	 *	参数一： 请求类型  GET or  POST
	 *	参数二： 请求的路径
	 *	参数三： 是否异步， true  or false
	 */
    request.open(&quot;GET&quot; ,&quot;TestServlet&quot; ,true );
    request.send();
}



// 如果发送请求的同时，还想获取数据，那么代码如下

//执行get请求
function get() {

    //1. 创建xmlhttprequest 对象
    var request = ajaxFunction();

    //2. 设置请求参数
    request.open(&quot;GET&quot; ,&quot;TestServlet?name=aa&amp;age=18&quot; ,true );

    //3. 获取响应数据 注册监听的意思。  一会准备的状态发生了改变，那么就执行 = 号右边的方法
    request.onreadystatechange = function(){
        // readyState的值一共有5个状态，参见下表
        // readyState == 4 表示请求已经完成， 再判断状态码是否是200，200表示服务端正常响应(没有报错)
        if(request.readyState == 4 &amp;&amp; request.status == 200){
            //弹出响应的信息
            alert(request.responseText);
        }
    }
    
    // 4. 发送请求
    request.send();
}
</code></pre>
<h3 id="xmlhttprequest-readystate状态表">XMLHttpRequest readyState状态表</h3>
<table>
<thead>
<tr>
<th>值</th>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td><code>UNSENT</code></td>
<td>代理被创建，但尚未调用 open() 方法。</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>OPENED</code></td>
<td><code>open()</code> 方法已经被调用。</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>HEADERS_RECEIVED</code></td>
<td><code>send()</code> 方法已经被调用，并且头部和状态已经可获得。</td>
</tr>
<tr>
<td><code>3</code></td>
<td><code>LOADING</code></td>
<td>请求中； <code>responseText</code> 属性已经包含部分数据。</td>
</tr>
<tr>
<td><code>4</code></td>
<td><code>DONE</code></td>
<td>请求完成。</td>
</tr>
</tbody>
</table>
<h3 id="数据请求-post">数据请求 Post</h3>
<pre><code class="language-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
	//1. 创建对象
	// 和get请求一样
	
	function post() {
		//1. 创建请求对象
		var request = ajaxFunction();
		
		// 2. 设置请求地址、参数、类型(post、get)
		request.open(&quot;post&quot;, &quot;StudentServlet&quot;, true);
		
		//3. 获取响应数据 注册监听的意思。  一会准备的状态发生了改变，那么就执行 = 号右边的方法
	    request.onreadystatechange = function(){
	        //前半段表示 已经能够正常处理。  再判断状态码是否是200
	        if(request.readyState == 4 &amp;&amp; request.status == 200){
	            //弹出响应的信息
	            console.log(&quot;请求完成&quot;);
	            var h1 = document.getElementById(&quot;h1&quot;);
	        	h1.innerHTML = request.responseText;
	        }
	    }
		
	 	// 4. 如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据
		request.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
		
		// 5. 发送请求
    	// 如果是GET请求，参数写在这里是无效的
		request.send(&quot;id=555&quot;);
	}

&lt;/script&gt;
</code></pre>
<h2 id="jquery-ajax">JQuery Ajax</h2>
<h3 id="底层ajax写法">底层ajax写法</h3>
<pre><code class="language-javascript">// 语法：$.ajax(url, [settings]);

$.ajax(&quot;TestServlet&quot;, {
    type: &quot;GET&quot;,
    data: {
        action: &quot;json&quot;,
        uname: &quot;zhangsan&quot;
    },
    dataType: &quot;json&quot;,
    success: function(data, status_text){
        console.log(data);
        console.log(&quot;status_text: &quot; + status_text);
    },
    error: function(xhr, textStatus, errorThrow) {
        console.log(&quot;请求失败&quot;);
    }
});
</code></pre>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>a</mi><mi>j</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">所</mi><mi mathvariant="normal">有</mi><mi>a</mi><mi>j</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">相</mi><mi mathvariant="normal">关</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">底</mi><mi mathvariant="normal">层</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">现</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">都</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">基</mi><mi mathvariant="normal">础</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">给</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">封</mi><mi mathvariant="normal">装</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">更</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">便</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">关</mi><mi mathvariant="normal">于</mi></mrow><annotation encoding="application/x-tex">.ajax方法是其他所有ajax相关方法的底层实现，其他方法都是在它的基础上给我们封装的更方便使用的方法。 关于</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">有</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">相</span><span class="mord cjk_fallback">关</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">底</span><span class="mord cjk_fallback">层</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">现</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">都</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">基</span><span class="mord cjk_fallback">础</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">给</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">封</span><span class="mord cjk_fallback">装</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">更</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">便</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">关</span><span class="mord cjk_fallback">于</span></span></span></span>.ajax的详细介绍参见 <a href="http://jquery.cuishifeng.cn/jQuery.Ajax.html">http://jquery.cuishifeng.cn/jQuery.Ajax.html</a></p>
</blockquote>
<h3 id="get请求">get请求</h3>
<pre><code class="language-javascript">/*
 * 参数：
 *  url: 请求地址
 *  data: 待发送 Key/value 参数
 *  fn: 请求成功后回调函数
 *  type: 返回内容格式，xml, html, script, json, text, _default
 */

$.get( &quot;url&quot;,{pid:pid} ,function(data,status_text){
    console.log(data);
    console.log(&quot;status_text: &quot; + status_text);
},&quot;json&quot; );	// 指定请求返回的格式是json，jquery会帮我们把服务端返回的json字符串转换成js的json对象
</code></pre>
<h3 id="post请求">post请求</h3>
<pre><code class="language-javascript">/*
 * 参数：
 *  url: 请求地址
 *  data: 待发送 Key/value 参数
 *  fn: 请求成功后回调函数
 *  type: 返回内容格式，xml, html, script, json, text, _default
 */

$.post( &quot;url&quot;,{pid:pid} ,function(data,status){
    console.log(data);
    console.log(&quot;status_text: &quot; + status_text);
},&quot;json&quot; );	// 指定请求返回的格式是json，jquery会帮我们把服务端返回的json字符串转换成js的json对象
</code></pre>
<h3 id="获取json数据专用方法">获取JSON数据专用方法</h3>
<pre><code class="language-javascript">$.getJSON(&quot;url&quot;, {id:1, name: &quot;zhangsan&quot;} function(json){
  console.log(json);
});
</code></pre>
<h2 id="服务器和客户端数据传输的方式">服务器和客户端数据传输的方式</h2>
<h3 id="xml">xml</h3>
<p>因为无效数据占比太大，阅读困难。基本已经被json格式淘汰掉了</p>
<pre><code class="language-xml">  	&lt;list&gt;
        &lt;city&gt;
        &lt;id&gt;1&lt;id&gt;
        &lt;pid&gt;1&lt;/pid&gt;
        &lt;cname&gt;深圳&lt;/cname&gt;
        &lt;/city&gt;
        &lt;city &gt;
        &lt;id&gt;2&lt;id&gt;
        &lt;pid&gt;1&lt;/pid&gt;
        &lt;cname&gt;东莞&lt;/cname&gt;
        &lt;/city&gt;
    &lt;/list&gt;
</code></pre>
<h3 id="json">json</h3>
<p>阅读性更好 、 占用空间更小。</p>
<pre><code class="language-json">[{city:{id:1, pid:1, cname:&quot;深圳&quot;}}, {city:{id:2, pid:1, cname:&quot;东莞&quot;}}]
</code></pre>
<h4 id="前端json操作">前端json操作</h4>
<pre><code class="language-js">JSON.parse(jsonStr); // 将JSON字符串转成js对象
JSON.stringify(obj);  // 将js对象转成JSON字符串
</code></pre>
<h4 id="后台json操作库">后台json操作库</h4>
<ul>
<li>
<p>fastjson库</p>
<p>JSON.toJSONString();	// 将JavaBean encode成 json string<br>
JSON.parseObject();		// 将json对象decode成javabean<br>
JSON.parseArray();		// 将json数组decode成java List或 JSONArray类型</p>
</li>
<li>
<p>Gson库</p>
</li>
<li>
<p>Jackson库</p>
</li>
<li>
<p>...</p>
</li>
</ul>
<h2 id="总结">总结</h2>
<h3 id="ajax-2">Ajax</h3>
<ul>
<li>创建异步请求对象的方法</li>
<li>发起异步GET请求的步骤</li>
<li>发起异步POST请求的步骤</li>
<li>异步POST请求与GET请求的对比</li>
</ul>
<h3 id="jquery">JQuery</h3>
<ul>
<li>$.ajax()</li>
<li>$.get()</li>
<li>$.post()</li>
<li>$.getJSON()</li>
<li>jQuery中各个ajax方法之间的区别和联系</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cookie&Session]]></title>
        <id>https://ysjhhhhhhh.github.io/post/Cookie&amp;Session</id>
        <link href="https://ysjhhhhhhh.github.io/post/Cookie&amp;Session">
        </link>
        <updated>2018-03-30T12:48:19.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="cookie">Cookie</h1>
<blockquote>
<p>饼干. 其实是一份小数据， 是服务器给客户端，并且存储在客户端上的一份小数据</p>
</blockquote>
<h2 id="应用场景">应用场景</h2>
<blockquote>
<p>自动登录、浏览记录、购物车。</p>
</blockquote>
<h2 id="为什么要有这个cookie">为什么要有这个Cookie</h2>
<blockquote>
<p>http的请求是无状态。 客户端与服务器在通讯的时候，是无状态的，其实就是客户端在第二次来访的时候，服务器根本就不知道这个客户端以前有没有来访问过。 为了更好的用户体验，更好的交互 [自动登录]，其实从公司层面讲，就是为了更好的收集用户习惯[大数据]</p>
</blockquote>
<h2 id="cookie怎么用">Cookie怎么用</h2>
<h3 id="添加cookie给客户端">添加Cookie给客户端</h3>
<ol>
<li>在响应的时候，添加cookie</li>
</ol>
<pre><code class="language-java">	Cookie cookie = new Cookie(&quot;aa&quot;, &quot;bb&quot;);	
	//给响应，添加一个cookie
	response.addCookie(cookie);
</code></pre>
<ol start="2">
<li>客户端收到的信息里面，响应头中多了一个字段 Set-Cookie<br>
<img src="https://ysjhhhhhhh.github.io/post-images/1576045567472.png" alt=""></li>
</ol>
<h3 id="获取客户端带过来的cookie">获取客户端带过来的Cookie</h3>
<pre><code class="language-java">//获取客户端带过来的cookie
Cookie[] cookies = request.getCookies();
if(cookies != null){
    for (Cookie c : cookies) {
        String cookieName = c.getName();
        String cookieValue = c.getValue();
        System.out.println(cookieName + &quot; = &quot;+ cookieValue);
    }
}
</code></pre>
<h3 id="清除cookie">清除Cookie</h3>
<blockquote>
<p>Cookie没有提供delete方法，我们要删除需要设置maxAge 为0 。</p>
</blockquote>
<pre><code>Cookie cookie = new Cookie(&quot;history&quot;,&quot;&quot;);
cookie.setMaxAge(0); //设置立即删除
cookie.setPath(&quot;/CookieDemo02&quot;);
response.addCookie(cookie);
</code></pre>
<h3 id="其他常用方法">其他常用方法</h3>
<pre><code class="language-java">//关闭浏览器后，cookie就没有了。 ---&gt; 针对没有设置cookie的有效期。
//	expiry： 有效 以秒计算。
//正值 ： 表示 在这个数字过后，cookie将会失效。
//负值： 关闭浏览器，那么cookie就失效， 默认值是 -1
cookie.setMaxAge(60 * 60 * 24 * 7);

//赋值新的值
//cookie.setValue(newValue);

//用于指定只有请求了指定的域名，才会带上该cookie
cookie.setDomain(&quot;.itheima.com&quot;);

//只有访问该域名下的cookieDemo的这个路径地址才会带cookie
cookie.setPath(&quot;/CookieDemo&quot;);
</code></pre>
<h2 id="cookie示例-实现记住密码功能">Cookie示例 实现记住密码功能</h2>
<ol>
<li>用户打开网站后，自动读取Cookie中存储的用户名、密码</li>
<li>如果存在，自动填充到表单中</li>
<li>如果不存在，说明是第一次登录，需要登录后在后台将用户名、密码写入Cookie中，以便下次登录时自动填充</li>
</ol>
<h3 id="主要实现代码">主要实现代码</h3>
<h4 id="前端登录页">前端登录页</h4>
<pre><code class="language-jsp">&lt;body&gt;
	&lt;form action=&quot;LoginServlet&quot; method=&quot;post&quot;&gt;
		用户名： &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;userName&quot; onblur=&quot;inputPwd()&quot; &gt;
		&lt;br /&gt;
		密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码：
		&lt;input id=&quot;pwd&quot; type=&quot;password&quot; name=&quot;password&quot;&gt;
		&lt;br /&gt;
		&lt;input type=&quot;checkbox&quot; name=&quot;remeber_me&quot; value=&quot;true&quot; /&gt; 记住密码 
		&lt;br /&gt;
		&lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
	&lt;/form&gt;
&lt;/body&gt;
&lt;!-- 引入js操作Cookie的第三方库，也可以使用原生js API --&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
	
	// 从cookies里面按照用户输入的username去查找对应的password,
	// 如果找到，说明用户已经登录成功过，并且已经记录到cookie里。
	// 我们直接把对应的密码从cookie中拿出来，设置password密码框里
	
	// my_cookies其实就是一个map， 存储了所有的cookie键值对
	var my_cookies = Cookies.get();
	console.log(my_cookies);
	
	var pwdInput = document.getElementById(&quot;pwd&quot;);
	var username = document.getElementById(&quot;username&quot;);
	
	// 当输入完用户名，文本框失去焦点时，去cookie中找对应的密码，
	// 如果找到，直接填充到密码框里
	function inputPwd() {
		var userName = username.value;
		var cookieKey = &quot;username-&quot; + userName;
		console.log(cookieKey);
		var cookiePwd = my_cookies[cookieKey];
		console.log(cookiePwd);
		if(cookiePwd) {
			pwdInput.value = cookiePwd;
		}
	}
&lt;/script&gt;
</code></pre>
<h4 id="后台处理代码">后台处理代码</h4>
<pre><code class="language-java">protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		request.setCharacterEncoding(&quot;UTF-8&quot;);
		
		// 获取前台表单提交的用户名、密码
		String userName = request.getParameter(&quot;userName&quot;);
		String password = request.getParameter(&quot;password&quot;);
		
		// 获取前台是否勾上了记住密码
		String sRemeber = request.getParameter(&quot;remeber_me&quot;);
		boolean remeber = false;
		try {
			remeber = Boolean.parseBoolean(sRemeber);
		} catch (Exception e) {
		}
		
		
		// 设置响应格式和编码
		response.setContentType(&quot;text/html;charset=UTF-8&quot;);
		
		PrintWriter out = response.getWriter();
		if(isBlank(userName) || isBlank(password)) {
			out.println(&quot;&lt;script&gt;alert('用户名或密码不能为空!'); window.location.href='login.jsp';&lt;/script&gt;&quot;);
			return;
		}
		
		if(!userAccountData.containsKey(userName)) {
			out.println(&quot;&lt;script&gt;alert('不好意思，您还没有注册！'); window.location.href='login.jsp';&lt;/script&gt;&quot;);
			return;
		}
		
		String orginPassword = userAccountData.get(userName);
		if(password.startsWith(&quot;pwd-&quot;)) {
			password = password.substring(4);
		}
		
		if(orginPassword.equals(password)) {
			out.println(&quot;登录成功！&quot;);
			if(remeber) {
				Cookie cookie = new Cookie(&quot;username-&quot; + userName, &quot;pwd-&quot; + password);
				cookie.setMaxAge(120);
				response.addCookie(cookie);
			}
			return;
		} else {
			out.println(&quot;&lt;script&gt;alert('用户名或密码不正确，请重新输入！'); window.location.href='login.jsp';&lt;/script&gt;&quot;);
			return;
		}
	}
</code></pre>
<h2 id="cookie总结">Cookie总结</h2>
<ol>
<li>
<p>服务器给客户端发送过来的一小份数据，并且存放在客户端上。</p>
</li>
<li>
<p>创建Cookie:</p>
<p>使用new来创建Cookie对象</p>
<pre><code class="language-java">Cookie cookie = new Cookie(&quot;xxx&quot;, &quot;wangzhenongyao&quot;);
</code></pre>
</li>
<li>
<p>添加cookie</p>
<p>添加cookie通过响应对象的addCookie方法</p>
<pre><code class="language-java">// 底层实现原理其实是在响应头中添加了一个： Set-Cookie: password=qiaoshouyuan; Max-Age=60; Expires=Fri, 20-Sep-2019 08:41:19 GMT; HttpOnly
response.addCookie();
</code></pre>
</li>
<li>
<p>获取cookie</p>
<pre><code class="language-java">Cookie[] cookies = request.getCookies();
</code></pre>
</li>
<li>
<p>Cookie有效时间</p>
<ol>
<li>
<p>会话Cookie</p>
<p>默认情况下，关闭了浏览器，那么cookie就会消失。</p>
<blockquote>
<p>这是默认的行为，但是大部分现代的浏览器都不会这么做，比如chrome浏览器，默认打开时会恢复上次关闭时的状态，所有关闭浏览器cookie并不会失效。 我们可以设置浏览器打开时不恢复上次状态，改为打开新的标签页即可。</p>
</blockquote>
</li>
<li>
<p>持久Cookie</p>
<p>通过设置MaxAge指定存活时间，在存活时间内，都有效，并且会保存在客户端上。</p>
</li>
</ol>
<pre><code>cookie.setMaxAge(0); //设置立即删除  
cookie.setMaxAge(100); //100 秒
</code></pre>
</li>
<li>
<p>Cookie的安全问题。</p>
<blockquote>
<p>由于Cookie会保存在客户端上，所以有安全隐患问题。  还有一个问题， Cookie的大小与个数有限制。 为了解决这个问题 ---&gt; Session .</p>
</blockquote>
</li>
<li>
<p>Cookie不能直接存储中文，需要做转码</p>
</li>
</ol>
<h1 id="session">Session</h1>
<blockquote>
<p>会话 ， Session是基于Cookie的一种会话机制。 Cookie是服务器返回一小份数据给客户端，并且存放在客户端上。 Session是，数据存放在服务器端。</p>
</blockquote>
<h2 id="常用api">常用API</h2>
<pre><code class="language-java">//得到会话ID
String id = session.getId();

//存值
session.setAttribute(name, value);

//取值
session.getAttribute(name);

//移除值
session.removeAttribute(name);
</code></pre>
<h2 id="session创建和销毁">Session创建和销毁</h2>
<h3 id="创建">创建</h3>
<blockquote>
<p>在调用所有可以获取session的页面中(如：JSP、Servlet)，就会创建Session，并且浏览器Cookie中也会生成JSESSIONID</p>
</blockquote>
<h3 id="获取session">获取Session</h3>
<pre><code>request.getSession();
</code></pre>
<h3 id="销毁">销毁</h3>
<blockquote>
<p>session 是存放在服务器的内存中的一份数据。</p>
</blockquote>
<blockquote>
<ol>
<li>关闭服务器</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>session会话时间过期。 有效期过了，默认有效期： 30分钟。</li>
</ol>
</blockquote>
<h3 id="移除session中的元素">移除Session中的元素</h3>
<pre><code>//强制干掉会话，里面存放的任何数据就都没有了。
session.invalidate();

//从session中移除某一个数据
//session.removeAttribute(&quot;cart&quot;);
</code></pre>
<h1 id="总结">总结：</h1>
<h2 id="cookie-2">Cookie</h2>
<p>服务器给客户端发送一小份数据， 存放在客户端上。</p>
<h3 id="基本用法">基本用法：</h3>
<pre><code>添加cookie

获取cookie。
</code></pre>
<h3 id="什么时候有cookie">什么时候有cookie</h3>
<p>response.addCookie(new Cookie())</p>
<h3 id="cookie-分类">Cookie 分类</h3>
<ul>
<li>
<p>会话Cookie</p>
<pre><code>  关闭浏览器，就失效
</code></pre>
</li>
<li>
<p>持久cookie</p>
<p>存放在客户端上。 在指定的期限内有效。</p>
<pre><code>	setMaxAge();
</code></pre>
</li>
</ul>
<h2 id="session-2">Session</h2>
<p>也是基于cookie的一种会话技术，  数据存放存放在服务器端，会在cookie里面添加一个字段 JSESSIONID . 是tomcat服务器生成。</p>
<h3 id="常用api-2">常用API</h3>
<pre><code>
setAttribute 存数据
 
getAttribute 取数据

removeAttribute  移除数据

req.getRequestedSessionId();  获取会话id
session.getId();  获取会话id

invalidate() 强制让会话失效。
</code></pre>
<h3 id="创建和销毁">创建和销毁</h3>
<ul>
<li>创建： 首次访问所有可以调用request.getSession方法的页面时，session创建，同时JSESSIONID也会生成</li>
<li>销毁：
<ul>
<li>关闭浏览器</li>
<li>会话超时（默认是30分钟）</li>
<li>服务端调用invalidate</li>
</ul>
</li>
</ul>
<h2 id="cookie和session的区别">Cookie和Session的区别</h2>
<ol>
<li>Cookie数据存放到客户端（浏览器），Session存放在服务端；</li>
<li>Cookie存放的数据大小有限制，不能超过4k；很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>Cookie由于存放在客户端硬盘上，所以相较于Session来说安全性低一点；</li>
<li>cookie失效时间是通过setMaxAge来设置，session是通过setInactiveInterval方法设置</li>
<li>Cookie中只能存储字符串的值，而且还不能中文。而Session中可以存储任意语言的字符串，或者Java中的所有类型。</li>
<li>Cookie是由程序员在业务代码中自己创建的，而Session是由容器创建的。</li>
</ol>
<h2 id="cookie和session的关系">Cookie和Session的关系</h2>
<p>HTTP协议本身是无状态的，也就是说服务端无法通过一个请求判断出谁是谁，而Session作为服务端跟踪用户状态的一项技术，在整个容器中存在很多份数据。如何知道一个请求进来应该拿哪份Session数据这是个问题。那么要解决这个问题，我们需要在请求中添加一个标识，Cookie技术就解决了这个问题。具体来说，Tomcat会在浏览器第一次访问JSP、Servlet时分配一个独一无二的Cookie标识(JSESSIONID)，写到浏览器端。后续每次请求时，浏览器会携带这个标识，进而服务端就可以区分出来谁是谁，然后拿对应的Session数据。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Litener&Filter]]></title>
        <id>https://ysjhhhhhhh.github.io/post/Litener&amp;Filter</id>
        <link href="https://ysjhhhhhhh.github.io/post/Litener&amp;Filter">
        </link>
        <updated>2018-03-28T02:04:40.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="listener">Listener</h1>
<blockquote>
<p>监听器</p>
</blockquote>
<ul>
<li>能做什么事？</li>
</ul>
<blockquote>
<p>监听某一个事件的发生。 状态的改变。</p>
</blockquote>
<ul>
<li>监听器的内部机制</li>
</ul>
<blockquote>
<p>其实就是接口回调.</p>
</blockquote>
<h2 id="监听器实现原理观察者模式">监听器实现原理——观察者模式</h2>
<ul>
<li>需求：</li>
</ul>
<blockquote>
<p>A在执行循环，当循环到5的时候， 通知B。</p>
</blockquote>
<blockquote>
<p>事先先把一个对象传递给 A ， 当A 执行到5的时候，通过这个对象，来调用B中的方法。 但是注意，不是直接传递B的实例，而是传递一个接口的实例过去。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://ysjhhhhhhh.github.io/post-images/1576044349452.png" alt=""></figure>
<h2 id="web监听器介绍">Web监听器介绍</h2>
<p>在JavaWeb开发中监听器总共有8个</p>
<h3 id="按照使用方法来划分可以分为两类">按照使用方法来划分可以分为两类</h3>
<h4 id="第一类-实现接口然后通过注册生效">第一类 实现接口然后通过注册生效</h4>
<p>具体配置步骤</p>
<ol>
<li>实现对应的监听器接口</li>
<li>重写接口中的方法</li>
<li>然后在web.xml或者注解的方式注册到容器中来使用</li>
</ol>
<p>适用的监听器类型</p>
<p>ServletRequestListener、HttpSessionListener、ServletContextListener、ServletRequestAttributeListener、HttpSessionAttributeListener、SerlvetContextAttributeListener</p>
<h4 id="第二类-让需要监听session中的特定类型实现监听接口不需要注册生效">第二类  让需要监听Session中的特定类型实现监听接口，不需要注册生效</h4>
<p>具体配置步骤</p>
<ol>
<li>让需要监听Session中的特定类型，如UserInfo实现监听接口</li>
<li>实现接口中的方法</li>
</ol>
<p>适用的监听器类型</p>
<p>HttpSessionBindingListener、HttpSessionActivationListener</p>
<h3 id="按照监听器的作用可以划分为三类">按照监听器的作用可以划分为三类</h3>
<h4 id="监听三个作用域创建和销毁">监听三个作用域创建和销毁</h4>
<ul>
<li>request  ---HttpServletRequest</li>
<li>session  ---HttpSession</li>
<li>application  --- ServletContext</li>
</ul>
<h5 id="servletrequestlistener">ServletRequestListener</h5>
<ul>
<li>监听事件</li>
</ul>
<pre><code>request创建:

    访问服务器上的任意资源都会有请求出现。

    访问 html： 会
    访问 jsp:	会
    访问 servlet : 会 

request销毁：

	服务器已经对这次请求作出了响应。			
</code></pre>
<ul>
<li>实现示例</li>
</ul>
<ol>
<li>新建Java类，实现ServletRequestListener接口</li>
</ol>
<pre><code class="language-java">import javax.servlet.ServletRequestEvent;
import javax.servlet.ServletRequestListener;

public class RequestListener implements ServletRequestListener {

	@Override
	public void requestDestroyed(ServletRequestEvent sre) {
		System.out.println(&quot;request请求结束&quot;);
	}

	@Override
	public void requestInitialized(ServletRequestEvent sre) {
		System.out.println(&quot;request请求开始&quot;);
	}
}
</code></pre>
<ol start="2">
<li>在web.xml中注册监听器</li>
</ol>
<pre><code class="language-xml">&lt;listener&gt;
    &lt;listener-class&gt;com.lanou3g.demo.RequestListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<h5 id="httpsessionlistener">HttpSessionListener</h5>
<ul>
<li>监听事件</li>
</ul>
<pre><code>	session的创建
	    只要调用getSession
	
	    html:		不会
	    jsp:		会	  getSession();
	    servlet: 	会
	
	session的销毁
	    超时  30分钟
	    非正常关闭 销毁
	    正常关闭服务器(序列化)
</code></pre>
<ul>
<li>应用场景</li>
</ul>
<blockquote>
<p>统计在线人数.</p>
</blockquote>
<ul>
<li>实现示例</li>
</ul>
<ol>
<li>新建Java类，实现HttpSessionListener接口</li>
</ol>
<pre><code class="language-java">import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;

public class SessionLinsener implements HttpSessionListener {
	@Override
	public void sessionCreated(HttpSessionEvent se) {
		System.out.println(&quot;session被创建了&quot;);
	}

	@Override
	public void sessionDestroyed(HttpSessionEvent se) {
		System.out.println(&quot;session销毁了&quot;);
	}
}
</code></pre>
<ol start="2">
<li>在web.xml中注册监听器</li>
</ol>
<pre><code class="language-xml">&lt;listener&gt;
    &lt;listener-class&gt;com.lanou3g.demo.SessionLinsener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<h5 id="servletcontextlistener">ServletContextListener</h5>
<ul>
<li>
<p>监听事件</p>
<ul>
<li>
<p>ServletContext创建：启动服务器的时候</p>
</li>
<li>
<p>ServletContext销毁：关闭服务器. 从服务器移除项目</p>
</li>
</ul>
</li>
<li>
<p>应用场景</p>
</li>
</ul>
<blockquote>
<p>在servletcontext创建的时候，</p>
<ol>
<li>完成自己想要的初始化工作</li>
<li>执行自定义任务调度。 执行某一个任务。 Timer</li>
</ol>
</blockquote>
<ul>
<li>实现示例</li>
</ul>
<p>新建Java类，实现ServletContextListener接口</p>
<pre><code class="language-java">import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;

public class ContextListener implements ServletContextListener {
	@Override
	public void contextInitialized(ServletContextEvent sce) {
		System.out.println(&quot;ServletContext初始化&quot;);
	}
	@Override
	public void contextDestroyed(ServletContextEvent sce) {
		System.out.println(&quot;ServletContext销毁&quot;);
	}
}
</code></pre>
<p>在web.xml中注册监听器</p>
<pre><code class="language-xml">&lt;listener&gt;
    &lt;listener-class&gt;com.lanou3g.demo.ContextListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<h4 id="监听三个作用域属性状态变更">监听三个作用域属性状态变更</h4>
<blockquote>
<p>可以监听在作用域中值 添加  | 替换  | 移除的动作。</p>
</blockquote>
<h5 id="servletcontext-servletcontextattributelistener">servletContext --- ServletContextAttributeListener</h5>
<figure data-type="image" tabindex="2"><img src="https://ysjhhhhhhh.github.io/post-images/1576044425334.png" alt=""></figure>
<h5 id="request-servletrequestattributelistener">request --- ServletRequestAttributeListener</h5>
<figure data-type="image" tabindex="3"><img src="https://ysjhhhhhhh.github.io/post-images/1576044439138.png" alt=""></figure>
<h5 id="session-httpsessionattributelistener">session --- HttpSessionAttributeListener</h5>
<figure data-type="image" tabindex="4"><img src="https://ysjhhhhhhh.github.io/post-images/1576044413990.png" alt=""></figure>
<h4 id="监听httpsession里面存值的状态变更">监听httpSession里面存值的状态变更</h4>
<blockquote>
<p>这一类监听器不用注册。</p>
</blockquote>
<h5 id="httpsessionbindinglistener">HttpSessionBindingListener</h5>
<blockquote>
<p>监听特定类型对象与session 绑定和解除绑定 的动作，注意此监听器是让JavaBean实现监听接口，即表示当session中此类型的value状态发生变更时，此JavaBean会收到通知</p>
</blockquote>
<p><span style="color:red;font-weight:bold;">与HttpSessionAttributeListener监听器不同的是，该监听器只对Session中的某种特定类型的属性变化感兴趣</span></p>
<pre><code class="language-java">// 注意：是让JavaBean实现该接口，不需要添加任何注解或在web.xml中配置

import javax.servlet.http.HttpSessionBindingEvent;
import javax.servlet.http.HttpSessionBindingListener;

public class Man implements HttpSessionBindingListener {

	private String name;
	private String nickName;
	private int age;

	public Man() {
	}

	public Man(String name, String nickName, int age) {
		this.name = name;
		this.nickName = nickName;
		this.age = age;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getNickName() {
		return nickName;
	}

	public void setNickName(String nickName) {
		this.nickName = nickName;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	@Override
	public void valueBound(HttpSessionBindingEvent event) {
		Man man = (Man) event.getValue();
		System.out.println(&quot;man对象绑定到session中 name: &quot; + man.getName() + &quot;, value: &quot; + event.getValue());
	}

	@Override
	public void valueUnbound(HttpSessionBindingEvent event) {
		Man man = (Man) event.getValue();
		System.out.println(&quot;man对象从session中解绑 name: &quot; + man.getName() + &quot;, value: &quot; + event.getValue());
	}
}
</code></pre>
<h5 id="httpsessionactivationlistener">HttpSessionActivationListener</h5>
<blockquote>
<p>用于监听现在session的值 是 钝化 （序列化）还是活化 （反序列化）的动作</p>
</blockquote>
<ul>
<li>钝化 （序列化）</li>
</ul>
<blockquote>
<p>把内存中的数据 存储到硬盘上</p>
</blockquote>
<ul>
<li>活化 （反序列化）</li>
</ul>
<blockquote>
<p>把硬盘中的数据读取到内存中。</p>
</blockquote>
<ul>
<li>session的钝化活化的用意何在</li>
</ul>
<blockquote>
<p>session中的值可能会很多， 并且我们有很长一段时间不使用这个内存中的值， 那么可以考虑把session的值可以存储到硬盘上【钝化】，等下一次在使用的时候，在从硬盘上提取出来。 【活化】</p>
</blockquote>
<ul>
<li>如何让session的在一定时间内钝化.</li>
</ul>
<h6 id="钝化-活化监听需要修改tomcat配置">钝化、活化监听需要修改Tomcat配置</h6>
<p>修改的地方有三个可选，主要是作用范围不一样</p>
<pre><code>1. 在tomcat里面 conf/context.xml 里面配置

		对所有的运行在这个服务器的项目生效

2. 在conf/Catalina/localhost/context.xml 配置

		对 localhost生效。  localhost:8080

3. 在自己的web工程项目中的 META-INF/context.xml

		只对当前的工程生效。
</code></pre>
<p>修改方法：</p>
<pre><code class="language-xml">	&lt;!--
		参数说明：
		# maxIdleSwap ： 1分钟不用就钝化
		# directory ：  钝化后的那个文件存放的目录位置。 
	--&gt;
	&lt;Context&gt;
		&lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot; maxIdleSwap=&quot;1&quot;&gt;
			&lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;F:/temp&quot;/&gt;
		&lt;/Manager&gt;
	&lt;/Context&gt;
</code></pre>
<h6 id="监听器使用步骤">监听器使用步骤</h6>
<ol>
<li>与HttpSessionBindingListener类似， HttpSessionActivationListener也是针对特定类型监听的。那我们需要让需要监听钝化、活化状态的特定的JavaBean实现HttpSessionActivationListener接口</li>
<li>上面提到的几种配置方法，任选一种告诉Tomcat当Session不活跃、或者容器停止时Session钝化的策略</li>
</ol>
<p>做好上面两步，当Session中有监听的特定类型，并且Session钝化、活化时就能触发通知</p>
<h2 id="filter">Filter</h2>
<blockquote>
<p>过滤器 ， 其实就是对客户端发出来的请求进行过滤。 浏览器发出， 然后服务器派servlet处理。  在中间就可以过滤， 其实过滤器起到的是拦截的作用。</p>
</blockquote>
<ul>
<li>
<p>作用</p>
<ol>
<li>对一些敏感词汇进行过滤</li>
<li>统一设置编码</li>
<li>自动登录</li>
</ol>
<p>...</p>
</li>
</ul>
<h3 id="如何使用filter">如何使用Filter</h3>
<ol>
<li>定义一个类， 实现Filter</li>
</ol>
<pre><code class="language-java">public class FilterDemo implements Filter {	
    public void destroy() {
    }

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    System.out.println(&quot;来到过虑器了。。。&quot;);
    chain.doFilter(request, response);
    }

    public void init(FilterConfig fConfig) throws ServletException {
    }
}
</code></pre>
<ol start="2">
<li>注册过滤器</li>
</ol>
<blockquote>
<p>在web.xml里面注册，注册的手法与servlet基本一样。</p>
</blockquote>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;display-name&gt;FilterDemo&lt;/display-name&gt;
    &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt;
    &lt;filter-class&gt;com.itheima.filter.FilterDemo&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<blockquote>
<p>在Servlet3.0里可以通过 @WebFilter注解配置</p>
</blockquote>
<h3 id="filter的生命周期">Filter的生命周期</h3>
<ul>
<li>创建</li>
</ul>
<blockquote>
<p>在服务器启动的时候就创建。</p>
</blockquote>
<ul>
<li>销毁</li>
</ul>
<blockquote>
<p>服务器停止的时候。</p>
</blockquote>
<h3 id="filter执行顺序">Filter执行顺序</h3>
<ol>
<li>
<p>客户端发出请求，先经过过滤器， 如果过滤器放行，那么才能到servlet</p>
</li>
<li>
<p>如果有多个过滤器， 那么他们会按照注册的映射顺序 来 排队。 只要有一个过滤器， 不放行，那么后面排队的过滤器以及咱们的servlet都不会收到请求。</p>
</li>
</ol>
<h3 id="filter细节">Filter细节</h3>
<ol>
<li>
<p>init方法的参数 FilterConfig , 可以用于获取filter在注册的名字 以及初始化参数。  其实这里的设计的初衷与ServletConfig是一样的。</p>
</li>
<li>
<p>如果想放行，那么在doFilter 方法里面操作，使用参数 chain</p>
</li>
</ol>
<pre><code class="language-java">chain.doFilter(request, response); 放行， 让请求到达下一个目标。
</code></pre>
<ol start="3">
<li>
<p><url-pattern>/*</url-pattern> 写法格式与servlet一样。</p>
<ol>
<li>
<p>全路径匹配  以 /  开始</p>
<pre><code> /LoginServlet
</code></pre>
</li>
<li>
<p>以目录匹配 以 / 开始  以 * 结束</p>
<p>/demo01/*</p>
</li>
<li>
<p>以后缀名匹配  以 * 开始 以后缀名结束</p>
<p>*.jsp  *.html *.do</p>
</li>
</ol>
<blockquote>
<p>注意：*号只能代表一段目录或者文件名，不能代替单词中的部分字母</p>
</blockquote>
</li>
<li>
<p>针对 dispatcher 设置</p>
<pre><code> ​	REQUEST ： 只要是请求过来，都拦截，默认就是REQUEST 
</code></pre>
<p>​	FORWARD : 只要是转发都拦截。<br>
​	ERROR ： 页面出错发生跳转<br>
​	INCLUDE ： 包含页面的时候就拦截。<br>
​</p>
</li>
</ol>
<h3 id="案例一-实现自动登录">案例一 实现自动登录</h3>
<ul>
<li>
<p>需求分析</p>
<ol>
<li>用户正常登录过一次以后，只要session不失效，用户可以直接访问网站中的其他页面，而不用再次登录。</li>
<li>如果没有登录或者session失效了， 那直接访问其他页面重定向到登录页面</li>
</ol>
</li>
</ul>
<h4 id="1-搭建环境">1. 搭建环境</h4>
<ol>
<li>搭建数据库</li>
<li>搭建页面</li>
</ol>
<h4 id="2-部分后台代码">2. 部分后台代码</h4>
<p>登录servlet代码</p>
<pre><code class="language-java">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

	try {
		String userName = request.getParameter(&quot;username&quot;);
		String password = request.getParameter(&quot;password&quot;);
		String autoLogin = request.getParameter(&quot;auto_login&quot;);
		UserBean user = new UserBean();
		user.setUsername(userName);
		user.setPassword(password);
		
		UserDao dao = new UserDaoImpl();
		UserBean userBean = dao.login(user);
		
		if(userBean != null){
			//成功了，进入首页
			request.getSession().setAttribute(&quot;userBean&quot;, userBean);
			response.sendRedirect(&quot;index.jsp&quot;);
		}else{
			//不成功...
			request.getRequestDispatcher(&quot;login.jsp&quot;).forward(request, response);
		}
		
	} catch (SQLException e) {
		e.printStackTrace();
	}
}
</code></pre>
<p>过滤器代码</p>
<ul>
<li>实现思路</li>
</ul>
<ol>
<li>
<p>先判断session是否有效， 如果失效了，直接把请求重定向到登录页，让用户完成手动登录</p>
</li>
<li>
<p>如果session没有失效，那么就从session中获取用户登录信息和数据库中做对比，如果正确就可以正常登录。否则重定向到登录页，让用户手动登录。</p>
</li>
</ol>
<pre><code class="language-java">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		
		HttpServletRequest req = (HttpServletRequest) request;
		HttpServletResponse resp = (HttpServletResponse) response;
		HttpSession session = req.getSession();
		
		// 如果session里没有登录信息，无法自动登录，重定向到登录页，让用户手动登录
		if(session.getAttribute(&quot;username&quot;) == null) {
			resp.sendRedirect(&quot;login.jsp&quot;);
			return;
		}
		
		String username = (String) session.getAttribute(&quot;username&quot;);
		String password = (String) session.getAttribute(&quot;password&quot;);
		
		// 检查session中的登录信息是否正确
		if(checkValid(username, password)) {
			chain.doFilter(request, response);
		}
	}
</code></pre>
<h2 id="总结">总结</h2>
<h3 id="listener-2">Listener</h3>
<pre><code>8个 

三种类型  
	针对三个作用域的创建和销毁
	针对三个作用域的值改变 【添加 | 替换 | 移除】
	针对session中的值 【钝化 活化】 ， 【绑定  解绑】

钝化 ( 序列化 ) 
	内存中的对象存储到硬盘 

	超时失效。 session销毁了。 

非正常关闭服务器， 钝化  。 正常关闭服务器 销毁

设置了session钝化策略：context.xml

活化 (反序列化)
	从硬盘里面读取到内存
</code></pre>
<p>应用场景：</p>
<p>ServletContextListner  ： 应用被部署的时候， 服务器加载这个项目的时候，做一些初始化工作， 任务调度。<br>
HttpSessionBindingListener	： 统计在线人数<br>
HttpSessionActivationListener  ： 钝化活化处理</p>
<h3 id="filter-2">Filter</h3>
<blockquote>
<p>使用频率更高</p>
</blockquote>
<ul>
<li>如果要写一个过滤器。</li>
</ul>
<blockquote>
<ol>
<li>定义一个类，实现接口 Filter</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>注册 web.xml . 与servlet相似。</li>
</ol>
</blockquote>
<ul>
<li>过滤器放行。</li>
</ul>
<blockquote>
<p>chain.doFilter(request, response);</p>
</blockquote>
<ul>
<li>
<p>过滤器生命周期</p>
<p>创建： 服务器加载这个项目的时候创建实例</p>
<p>销毁： 关闭服务器或者从服务器中移除项目的时候。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文件上传]]></title>
        <id>https://ysjhhhhhhh.github.io/post/wen-jian-shang-chuan</id>
        <link href="https://ysjhhhhhhh.github.io/post/wen-jian-shang-chuan">
        </link>
        <updated>2018-03-27T11:44:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前端页面">前端页面</h2>
<h3 id="必要条件">必要条件</h3>
<ol>
<li>需要有一个form表单</li>
<li>form表单需要设置以下几个属性：
<ol>
<li>action:  提交数据的目的地</li>
<li>method: 设置post</li>
<li>enctype: 设置成multipart/form-data</li>
</ol>
</li>
<li>form里需要至少有一个file域： &lt;input type=&quot;file&quot; name=&quot;xxx&quot; /&gt;</li>
</ol>
<h2 id="后端技术">后端技术</h2>
<p>所谓文件上传其实就是用流的方式，将文件从客户的电脑上通过网页中的表单， 以二进制流的方式，流到服务器的过程。</p>
<p>文件下载就是反过来， 将文件从服务器上通过二进制流的方式流到客户电脑上。</p>
<h3 id="servlet30上传方式">Servlet3.0上传方式</h3>
<h4 id="servlet30上传的核心-一个注解-一个接口">Servlet3.0上传的核心： 一个注解、一个接口</h4>
<p>注解：</p>
<p>@MultipartConfig： 开启Servlet文件上传功能</p>
<p>接口：</p>
<p>javax.servlet.http.Part：  封装了上传的文件相关的所有信息</p>
<h4 id="具体操作步骤">具体操作步骤</h4>
<ol>
<li>新建处理文件上传的Servlet，然后重写doPost方法</li>
<li>给Servlet添加@MultipartConfig注解，开启文件上传功能</li>
<li>Part part = request.getPart(&quot;input type='type' name的值&quot;);</li>
<li>part对象有两个作用：
<ol>
<li>可以获取到上传文件的所有信息，比如：文件名、大小、类型、文件流数据</li>
<li>可以直接将文件写到服务器   part.write(&quot;文件保存的路径&quot;);</li>
</ol>
</li>
</ol>
<h3 id="apache-commons-fileupload-上传方式">Apache Commons Fileupload 上传方式</h3>
<h4 id="用fileupload上传的核心就是一个接口-两个类">用fileupload上传的核心就是：一个接口、两个类</h4>
<p>接口： FileItem</p>
<p>封装了我们表单中的每个域的数据（可能是普通文本数据，也可能是上传的文件）</p>
<p>类：</p>
<p>DiskFileItemFactory：  用于创建文件上传对象的工厂</p>
<p>ServletFileupload： 文件上传对象</p>
<h4 id="具体操作步骤-2">具体操作步骤</h4>
<ol>
<li>
<p>需要添加依赖： commons-fileupload.jar、commons-io.jar</p>
</li>
<li>
<p>新建处理文件上传的Servlet，然后重写doPost方法</p>
</li>
<li>
<p>调用ServletFileupload对象的静态方法，判断请求是否是一个文件上传请求</p>
<pre><code class="language-java">if(!ServletFileupload.isMultipartContent(request)) {
    // 如果不是multipart请求，代表不是一个有效的文件上传请求， 下面的步骤都可以省略了
}
</code></pre>
</li>
<li>
<p>创建文件上传工厂对象：</p>
<pre><code class="language-java">DiskFileItemFactory factory = new DiskFileItemFactory();
// factory.set.... 可以设置相关参数
</code></pre>
</li>
<li>
<p>创建文件上传对象</p>
<pre><code class="language-java">ServletFileupload upload = new ServletFileupload(factory);
// upload.set.... 可以设置相关参数
</code></pre>
</li>
<li>
<p>用文件上传对象解析请求对象，然后获取解析后的所有FileItem</p>
<pre><code class="language-java">List&lt;FileItem&gt; fileItems = upload.parseRequest(request);
</code></pre>
</li>
<li>
<p>迭代处理每个FileItem</p>
<ol>
<li>文本信息的FileItem获取后进行相关的业务操作</li>
<li>文件类型的FileItem获取后，调用FileItem.write将文件写到服务器某个目录下。</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
</feed>