<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ysjhhhhhhh.github.io</id>
    <title>Gridea</title>
    <updated>2019-12-11T12:42:21.821Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ysjhhhhhhh.github.io"/>
    <link rel="self" href="https://ysjhhhhhhh.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://ysjhhhhhhh.github.io/images/avatar.png</logo>
    <icon>https://ysjhhhhhhh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[jdbc]]></title>
        <id>https://ysjhhhhhhh.github.io/post/jdbc</id>
        <link href="https://ysjhhhhhhh.github.io/post/jdbc">
        </link>
        <updated>2018-04-05T13:38:39.000Z</updated>
        <content type="html"><![CDATA[<p>一. JDBC编程概述</p>
<ol>
<li>
<p>什么JDBC<br>
  JDBC（Java Database Connection）：为多种关系数据库提供统一访问。它由一组用Java语言编写的类和接口组成。是Java访问数据库的标准和规范。</p>
</li>
<li>
<p>常见数据库介绍<br>
  Mysql：开源免费的数据库，小型的数据库。非常实用和受欢迎。已经被Oracle收购了.MySQL6.x版本也开始收费。<br>
  Oracle：收费的大型数据库，Oracle公司的产品。一般中大型公司会使用。Oracle收购了SUN公司，Mysql数据库。<br>
  DB2：IBM公司的收费数据库产品。常应用在银行系统和金融系统中.<br>
  SQLServer：MicroSoft 公司收费的中型的数据库。常常在C#、.net等语言中使用。<br>
  SyBase：提供了一个非常专业数据建模的工具PowerDesigner，但是数据库本身已经淡出历史舞台。<br>
  SQLite: 嵌入式的小型数据库，基本上用于移动端。<br>
  Java相关的数据库：MYSQL，Oracle。<br>
  数据库的设计和开发，sql语句的编写在这里不做详细的介绍。</p>
</li>
</ol>
<p>oracle.jpg<br>
3. JDBC开发原理<br>
  Java和数据库之间没有必然的联系，两者之间是如何连接的呢？虽然Java提供了各种数据库接口，但是我们并不知道各种数据库具体的实现原理，难以对接口进行具体的实现。<br>
  所以，数据库生产商提供了这些接口的实现类：驱动<br>
  Java提供访问数据库规范称为JDBC，而生产厂商提供规范的实现类称为驱动。</p>
<p>JDBC原理图.png</p>
<p>JDBC是接口，驱动是接口的实现，没有驱动将无法完成数据库连接，从而不能操作数据库。每个数据库厂商都需要提供自己的驱动，用来连接自己公司的数据库。<br>
二. JDBC开发步骤<br>
JDBC一般的开发步骤如下：<br>
首先要从官方网站上下载Mysql的驱动，并通过Eclipse导入驱动（jar包）<br>
导入驱动的方法.png</p>
<p>JDBC开发步骤如下：<br>
注册驱动（Driver）<br>
获得连接（Connection）<br>
获得语句执行平台（Statement）<br>
使用SQL语句进行处理<br>
释放资源，关闭链接<br>
数据库中创建示例：<br>
create table users(<br>
username varchar(10),<br>
pass varchar(10),<br>
nicheng varchar(30)<br>
);<br>
insert into users (username,pass,nicheng) values('wjy','wjykl22','凉凉夜色为你思念成河');<br>
select * from users;<br>
Java连接数据库<br>
1.注册驱动:<br>
官方API推荐方法：</p>
<p>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<br>
不推荐使用DriverManager.registerDriver(new com.mysql.jdbc.Driver());注册，以上代码有两点不足：</p>
<p>硬编码，后期不易维护<br>
驱动在源码中就被注册过，驱动会被两次注册<br>
Driver源码：<br>
public class Driver extends NonRegisteringDriver implements java.sql.Driver {<br>
static {<br>
try {<br>
java.sql.DriverManager.registerDriver(new Driver());<br>
} catch (SQLException E) {<br>
throw new RuntimeException(&quot;Can't register driver!&quot;);<br>
}<br>
}<br>
}<br>
2.获得连接:<br>
String url = &quot;jdbc:mysql://localhost:3306/jdbc&quot;;<br>
String username = &quot;root&quot;;<br>
String password = &quot;wjykl22&quot;;<br>
Connection con = DriverManager.getConnection(url, username, password);<br>
其中url：需要连接数据库的位置（网址）目前来说格式基本上固定。</p>
<p>第一部分：jdbc，这是固定的；<br>
第二部分：数据库名称，我们连接的是Mysql数据库，所以使用Mysql<br>
第三部分：由数据库厂商规定的，每个厂商都有各自的要求，分别由数据库服务器的IP地址（localhost）、端口号（3306），以及DATABASE名称(jdbc)组成。</p>
<p>username：数据库用户名。<br>
password：数据库密码。<br>
采用上述方法就可以获得数据库的链接。</p>
<p>3.获得执行平台并执行sql语句<br>
Statement stat = con.createStatement();<br>
int executeUpdate(String sql);//用于执行insert update delete语句.<br>
ResultSet executeQuery(String sql); //用于执行select语句.<br>
boolean execute(String sql); //用于执行select返回true 执行其他的语句返回false.<br>
4.结果集处理<br>
得到ResultSet结果集后，需要对其中的数据进行数据的提取，对于ResultSet结果集的处理方法：</p>
<p>Object getObject(int index) / Object getObject(String name) 获得任意对象<br>
String getString(int index) / Object getObject(String name) 获得字符串<br>
int getInt(int index) / Object getObject(String name) 获得整形<br>
double getDouble(int index) / Object getObject(String name) 获得双精度浮点型<br>
5.释放资源<br>
最后一步就是释放资源，与IO释放资源的方式如出一辙。</p>
<p>rs.close();<br>
stmt.close();<br>
con.close();<br>
总结<br>
完整的上述步骤如下：</p>
<p>public class JDBCDemo {<br>
public static void main(String args[]) {<br>
try {<br>
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<br>
String url = &quot;jdbc:mysql://localhost:3306/jdbc&quot;;<br>
String username = &quot;root&quot;;<br>
String password = &quot;wjykl22&quot;;<br>
Connection con = DriverManager.getConnection(url, username, password);<br>
Statement stat = con.createStatement();<br>
stat.executeUpdate(&quot;insert into users (username,pass,nicheng) values('wjy2','wjykl33','如水流央')&quot;);<br>
ResultSet rs = stat.executeQuery(&quot;select * from users&quot;);<br>
while(rs.next()) {<br>
System.out.println(rs.getString(&quot;username&quot;)<br>
+&quot;\t&quot;+rs.getString(&quot;pass&quot;)+&quot;\t&quot;+rs.getString(&quot;nicheng&quot;));<br>
}<br>
rs.close();<br>
stat.close();<br>
con.close();<br>
} catch (Exception e) {<br>
e.printStackTrace();<br>
}<br>
}<br>
}<br>
预处理对象方法<br>
  为了防止代码存在SQL注入漏洞，使得代码更加完善，我们一般采用预处理对象：PreparedStatement<br>
  每条sql语句所有的实际参数，都使用逗号分隔。</p>
<ol>
<li>预处理对象并执行sql语句<br>
String sql = &quot;insert into sort(sid,sname) values(?,?)&quot;;<br>
PreparedStatement psmt = conn.prepareStatement(sql)</li>
<li>设置实际参数<br>
void setXxx(int index, Xxx xx)<br>
完整的代码程序段如下：</li>
</ol>
<p>public class LoginDemo {<br>
/*<br>
* Java程序实现用户的登录，用户名和密码，数据库检查<br>
* 防止注入攻击<br>
* Statment有一个子接口PrepareStatment，表示预编译的SQL语句对象，可以高效的执行<br>
* 这个方法是Connection数据库连接的方法<br>
* 如何获取这个实现类呢？<br>
*/<br>
public static void main(String args[]) throws Exception {<br>
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<br>
String url = &quot;jdbc:mysql://localhost:3306/world&quot;;<br>
String username = &quot;root&quot;;<br>
String password = &quot;wjykl22&quot;;<br>
Connection con = DriverManager.getConnection(url,username,password);<br>
Scanner sc = new Scanner(System.in);<br>
String user = sc.nextLine();<br>
String pass = sc.nextLine();<br>
//执行sql语句，查询用户名和密码。<br>
//注意要写问号<br>
String sql = &quot;select * from users where username =? and pass =?&quot;;<br>
java.sql.PreparedStatement pst = con.prepareStatement(sql);<br>
//调用pst中的set方法<br>
pst.setObject(1, user);<br>
pst.setObject(2, pass);</p>
<pre><code>    System.out.println(sql);
    ResultSet rs = pst.executeQuery();
    while(rs.next()) {
        System.out.println(rs.getString(&quot;username&quot;) + &quot;    &quot; + rs.getString(&quot;pass&quot;));
    }
}
</code></pre>
<p>}<br>
三. 工具类撰写和使用<br>
  作为一名程序员最应该学会的事情就是偷懒。设想一下，如果我们要在多各程序中使用Mysql数据库，会有很多代码重复使用，我们可以创建一个工具类Utils，通过工具类来完成注册驱动，获得链接，获得执行平台以及释放资源的操作。<br>
  <br>
  代码如下：</p>
<p>public class JDBCUtils {<br>
public static final  String DRIVERNAME = &quot;com.mysql.jdbc.Driver&quot;;<br>
public static final  String URL = &quot;jdbc:mysql://localhost:3306/mydb&quot;;<br>
public static final  String USER = &quot;root&quot;;<br>
public static final  String PASSWORD = &quot;root&quot;;<br>
static {<br>
try {<br>
Class.forName(DRIVERNAME);<br>
} catch (ClassNotFoundException e) {<br>
System.out.println(&quot;数据库驱动注册失败！&quot;);<br>
}<br>
}<br>
public static Connection getConn() throws Exception {<br>
Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);<br>
return conn;<br>
}<br>
}<br>
通过调用Utils类中的各种静态方法来达到重复利用代码的效果。</p>
<p>四. properties配置文件<br>
  上述代码还是不太方便，如果要修改某个参数，需要修改源代码，有没有方法能够不修改源代码就能够完成配置的修改呢？<br>
  通常情况下，我们习惯使用properties文件来存储与数据库有关的配置文件。</p>
<p>文件位置：任意，建议src下<br>
文件名称：任意，扩展名为properties<br>
文件内容：一行一组数据，格式是“key=value”.<br>
3.1 key命名自定义，如果是多个单词，习惯使用点分隔。例如：jdbc.driver<br>
3.2 value值不支持中文，如果需要使用非英文字符，将进行unicode转换。<br>
例如：<br>
driver=com.mysql.jdbc.Driver<br>
url=jdbc:mysql://localhost:3306/jdbc<br>
user=root<br>
password=root</p>
<p>加载配置文件properties的方法：<br>
  对应properties文件处理，开发中也使用Properties对象进行。我们将采用加载properties文件获得流，然后使用Properties对象进行处理。</p>
<p>public class JDBCUtils {<br>
private static String driver;<br>
private static String url;<br>
private static String user;<br>
private static String password;<br>
static {<br>
try {<br>
// 1. 使用Properties处理流<br>
// 使用load()方法加载指定的流<br>
Properties props = new Properties();<br>
Reader is = new FileReader(&quot;db.properties&quot;);<br>
props.load(is);<br>
// 2. 使用getProperty(key)，通过key获得需要的值，<br>
driver = props.getProperty(&quot;driver&quot;);<br>
url = props.getProperty(&quot;url&quot;);<br>
user = props.getProperty(&quot;user&quot;);<br>
password = props.getProperty(&quot;password&quot;);<br>
} catch (Exception e) {<br>
throw new RuntimeException(e);<br>
}<br>
}</p>
<pre><code>/**
 * 获得连接
 */
public static Connection getConnection() {
    try {
        // 1 注册驱动
        Class.forName(driver);
        // 2 获得连接
        Connection conn = DriverManager.getConnection(url, user, password);
        return conn;
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ajax]]></title>
        <id>https://ysjhhhhhhh.github.io/post/ajax</id>
        <link href="https://ysjhhhhhhh.github.io/post/ajax">
        </link>
        <updated>2018-03-31T09:38:57.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="ajax">Ajax</h2>
<ul>
<li>是什么?</li>
</ul>
<blockquote>
<p>“Asynchronous Javascript And XML”（异步JavaScript和XML），</p>
</blockquote>
<blockquote>
<p>并不是新的技术，只是把原有的技术，整合到一起而已。</p>
</blockquote>
<pre><code>1.使用CSS和XHTML来表示。
2.使用DOM模型来交互和动态显示。
3.使用XMLHttpRequest来和服务器进行异步通信。
4.使用javascript来绑定和调用。
</code></pre>
<ul>
<li>有什么用?</li>
</ul>
<blockquote>
<p>咱们的网页如果想要刷新局部内容。 那么需要重新载入整个网页。用户体验不是很好。  就是为了解决局部刷新的问题。 保持其他部分不动，只刷新某些地方。</p>
</blockquote>
<h3 id="数据请求-get">数据请求 Get</h3>
<h4 id="创建ajax请求对象">创建ajax请求对象</h4>
<pre><code class="language-javascript">function  ajaxFunction(){
	    var xmlHttp;
	    try{ // Firefox, Chrome, Opera 8.0+, Safari
	        xmlHttp=new XMLHttpRequest();
	    }
	    catch (e){
	        try{// Internet Explorer（高版本）
	            xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
	        }
	        catch (e){
	            try{// Internet Explorer（低版本）
	                xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
	            }
	            catch (e){}
	        }
	    }
	    return xmlHttp;
	}
</code></pre>
<h4 id="发送请求">发送请求</h4>
<pre><code class="language-javascript">//执行get请求
function get() {

    //1. 创建xmlhttprequest 对象
    var request = ajaxFunction();

    //2. 发送请求。
    /*	
	 *	参数一： 请求类型  GET or  POST
	 *	参数二： 请求的路径
	 *	参数三： 是否异步， true  or false
	 */
    request.open(&quot;GET&quot; ,&quot;TestServlet&quot; ,true );
    request.send();
}



// 如果发送请求的同时，还想获取数据，那么代码如下

//执行get请求
function get() {

    //1. 创建xmlhttprequest 对象
    var request = ajaxFunction();

    //2. 设置请求参数
    request.open(&quot;GET&quot; ,&quot;TestServlet?name=aa&amp;age=18&quot; ,true );

    //3. 获取响应数据 注册监听的意思。  一会准备的状态发生了改变，那么就执行 = 号右边的方法
    request.onreadystatechange = function(){
        // readyState的值一共有5个状态，参见下表
        // readyState == 4 表示请求已经完成， 再判断状态码是否是200，200表示服务端正常响应(没有报错)
        if(request.readyState == 4 &amp;&amp; request.status == 200){
            //弹出响应的信息
            alert(request.responseText);
        }
    }
    
    // 4. 发送请求
    request.send();
}
</code></pre>
<h3 id="xmlhttprequest-readystate状态表">XMLHttpRequest readyState状态表</h3>
<table>
<thead>
<tr>
<th>值</th>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td><code>UNSENT</code></td>
<td>代理被创建，但尚未调用 open() 方法。</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>OPENED</code></td>
<td><code>open()</code> 方法已经被调用。</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>HEADERS_RECEIVED</code></td>
<td><code>send()</code> 方法已经被调用，并且头部和状态已经可获得。</td>
</tr>
<tr>
<td><code>3</code></td>
<td><code>LOADING</code></td>
<td>请求中； <code>responseText</code> 属性已经包含部分数据。</td>
</tr>
<tr>
<td><code>4</code></td>
<td><code>DONE</code></td>
<td>请求完成。</td>
</tr>
</tbody>
</table>
<h3 id="数据请求-post">数据请求 Post</h3>
<pre><code class="language-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
	//1. 创建对象
	// 和get请求一样
	
	function post() {
		//1. 创建请求对象
		var request = ajaxFunction();
		
		// 2. 设置请求地址、参数、类型(post、get)
		request.open(&quot;post&quot;, &quot;StudentServlet&quot;, true);
		
		//3. 获取响应数据 注册监听的意思。  一会准备的状态发生了改变，那么就执行 = 号右边的方法
	    request.onreadystatechange = function(){
	        //前半段表示 已经能够正常处理。  再判断状态码是否是200
	        if(request.readyState == 4 &amp;&amp; request.status == 200){
	            //弹出响应的信息
	            console.log(&quot;请求完成&quot;);
	            var h1 = document.getElementById(&quot;h1&quot;);
	        	h1.innerHTML = request.responseText;
	        }
	    }
		
	 	// 4. 如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据
		request.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
		
		// 5. 发送请求
    	// 如果是GET请求，参数写在这里是无效的
		request.send(&quot;id=555&quot;);
	}

&lt;/script&gt;
</code></pre>
<h2 id="jquery-ajax">JQuery Ajax</h2>
<h3 id="底层ajax写法">底层ajax写法</h3>
<pre><code class="language-javascript">// 语法：$.ajax(url, [settings]);

$.ajax(&quot;TestServlet&quot;, {
    type: &quot;GET&quot;,
    data: {
        action: &quot;json&quot;,
        uname: &quot;zhangsan&quot;
    },
    dataType: &quot;json&quot;,
    success: function(data, status_text){
        console.log(data);
        console.log(&quot;status_text: &quot; + status_text);
    },
    error: function(xhr, textStatus, errorThrow) {
        console.log(&quot;请求失败&quot;);
    }
});
</code></pre>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>a</mi><mi>j</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">所</mi><mi mathvariant="normal">有</mi><mi>a</mi><mi>j</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">相</mi><mi mathvariant="normal">关</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">底</mi><mi mathvariant="normal">层</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">现</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">都</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">基</mi><mi mathvariant="normal">础</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">给</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">封</mi><mi mathvariant="normal">装</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">更</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">便</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">关</mi><mi mathvariant="normal">于</mi></mrow><annotation encoding="application/x-tex">.ajax方法是其他所有ajax相关方法的底层实现，其他方法都是在它的基础上给我们封装的更方便使用的方法。 关于</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">有</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">相</span><span class="mord cjk_fallback">关</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">底</span><span class="mord cjk_fallback">层</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">现</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">都</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">基</span><span class="mord cjk_fallback">础</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">给</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">封</span><span class="mord cjk_fallback">装</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">更</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">便</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">关</span><span class="mord cjk_fallback">于</span></span></span></span>.ajax的详细介绍参见 <a href="http://jquery.cuishifeng.cn/jQuery.Ajax.html">http://jquery.cuishifeng.cn/jQuery.Ajax.html</a></p>
</blockquote>
<h3 id="get请求">get请求</h3>
<pre><code class="language-javascript">/*
 * 参数：
 *  url: 请求地址
 *  data: 待发送 Key/value 参数
 *  fn: 请求成功后回调函数
 *  type: 返回内容格式，xml, html, script, json, text, _default
 */

$.get( &quot;url&quot;,{pid:pid} ,function(data,status_text){
    console.log(data);
    console.log(&quot;status_text: &quot; + status_text);
},&quot;json&quot; );	// 指定请求返回的格式是json，jquery会帮我们把服务端返回的json字符串转换成js的json对象
</code></pre>
<h3 id="post请求">post请求</h3>
<pre><code class="language-javascript">/*
 * 参数：
 *  url: 请求地址
 *  data: 待发送 Key/value 参数
 *  fn: 请求成功后回调函数
 *  type: 返回内容格式，xml, html, script, json, text, _default
 */

$.post( &quot;url&quot;,{pid:pid} ,function(data,status){
    console.log(data);
    console.log(&quot;status_text: &quot; + status_text);
},&quot;json&quot; );	// 指定请求返回的格式是json，jquery会帮我们把服务端返回的json字符串转换成js的json对象
</code></pre>
<h3 id="获取json数据专用方法">获取JSON数据专用方法</h3>
<pre><code class="language-javascript">$.getJSON(&quot;url&quot;, {id:1, name: &quot;zhangsan&quot;} function(json){
  console.log(json);
});
</code></pre>
<h2 id="服务器和客户端数据传输的方式">服务器和客户端数据传输的方式</h2>
<h3 id="xml">xml</h3>
<p>因为无效数据占比太大，阅读困难。基本已经被json格式淘汰掉了</p>
<pre><code class="language-xml">  	&lt;list&gt;
        &lt;city&gt;
        &lt;id&gt;1&lt;id&gt;
        &lt;pid&gt;1&lt;/pid&gt;
        &lt;cname&gt;深圳&lt;/cname&gt;
        &lt;/city&gt;
        &lt;city &gt;
        &lt;id&gt;2&lt;id&gt;
        &lt;pid&gt;1&lt;/pid&gt;
        &lt;cname&gt;东莞&lt;/cname&gt;
        &lt;/city&gt;
    &lt;/list&gt;
</code></pre>
<h3 id="json">json</h3>
<p>阅读性更好 、 占用空间更小。</p>
<pre><code class="language-json">[{city:{id:1, pid:1, cname:&quot;深圳&quot;}}, {city:{id:2, pid:1, cname:&quot;东莞&quot;}}]
</code></pre>
<h4 id="前端json操作">前端json操作</h4>
<pre><code class="language-js">JSON.parse(jsonStr); // 将JSON字符串转成js对象
JSON.stringify(obj);  // 将js对象转成JSON字符串
</code></pre>
<h4 id="后台json操作库">后台json操作库</h4>
<ul>
<li>
<p>fastjson库</p>
<p>JSON.toJSONString();	// 将JavaBean encode成 json string<br>
JSON.parseObject();		// 将json对象decode成javabean<br>
JSON.parseArray();		// 将json数组decode成java List或 JSONArray类型</p>
</li>
<li>
<p>Gson库</p>
</li>
<li>
<p>Jackson库</p>
</li>
<li>
<p>...</p>
</li>
</ul>
<h2 id="总结">总结</h2>
<h3 id="ajax-2">Ajax</h3>
<ul>
<li>创建异步请求对象的方法</li>
<li>发起异步GET请求的步骤</li>
<li>发起异步POST请求的步骤</li>
<li>异步POST请求与GET请求的对比</li>
</ul>
<h3 id="jquery">JQuery</h3>
<ul>
<li>$.ajax()</li>
<li>$.get()</li>
<li>$.post()</li>
<li>$.getJSON()</li>
<li>jQuery中各个ajax方法之间的区别和联系</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cookie&Session]]></title>
        <id>https://ysjhhhhhhh.github.io/post/Cookie&amp;Session</id>
        <link href="https://ysjhhhhhhh.github.io/post/Cookie&amp;Session">
        </link>
        <updated>2018-03-30T12:48:19.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="cookie">Cookie</h1>
<blockquote>
<p>饼干. 其实是一份小数据， 是服务器给客户端，并且存储在客户端上的一份小数据</p>
</blockquote>
<h2 id="应用场景">应用场景</h2>
<blockquote>
<p>自动登录、浏览记录、购物车。</p>
</blockquote>
<h2 id="为什么要有这个cookie">为什么要有这个Cookie</h2>
<blockquote>
<p>http的请求是无状态。 客户端与服务器在通讯的时候，是无状态的，其实就是客户端在第二次来访的时候，服务器根本就不知道这个客户端以前有没有来访问过。 为了更好的用户体验，更好的交互 [自动登录]，其实从公司层面讲，就是为了更好的收集用户习惯[大数据]</p>
</blockquote>
<h2 id="cookie怎么用">Cookie怎么用</h2>
<h3 id="添加cookie给客户端">添加Cookie给客户端</h3>
<ol>
<li>在响应的时候，添加cookie</li>
</ol>
<pre><code class="language-java">	Cookie cookie = new Cookie(&quot;aa&quot;, &quot;bb&quot;);	
	//给响应，添加一个cookie
	response.addCookie(cookie);
</code></pre>
<ol start="2">
<li>客户端收到的信息里面，响应头中多了一个字段 Set-Cookie<br>
<img src="https://ysjhhhhhhh.github.io/post-images/1576045567472.png" alt=""></li>
</ol>
<h3 id="获取客户端带过来的cookie">获取客户端带过来的Cookie</h3>
<pre><code class="language-java">//获取客户端带过来的cookie
Cookie[] cookies = request.getCookies();
if(cookies != null){
    for (Cookie c : cookies) {
        String cookieName = c.getName();
        String cookieValue = c.getValue();
        System.out.println(cookieName + &quot; = &quot;+ cookieValue);
    }
}
</code></pre>
<h3 id="清除cookie">清除Cookie</h3>
<blockquote>
<p>Cookie没有提供delete方法，我们要删除需要设置maxAge 为0 。</p>
</blockquote>
<pre><code>Cookie cookie = new Cookie(&quot;history&quot;,&quot;&quot;);
cookie.setMaxAge(0); //设置立即删除
cookie.setPath(&quot;/CookieDemo02&quot;);
response.addCookie(cookie);
</code></pre>
<h3 id="其他常用方法">其他常用方法</h3>
<pre><code class="language-java">//关闭浏览器后，cookie就没有了。 ---&gt; 针对没有设置cookie的有效期。
//	expiry： 有效 以秒计算。
//正值 ： 表示 在这个数字过后，cookie将会失效。
//负值： 关闭浏览器，那么cookie就失效， 默认值是 -1
cookie.setMaxAge(60 * 60 * 24 * 7);

//赋值新的值
//cookie.setValue(newValue);

//用于指定只有请求了指定的域名，才会带上该cookie
cookie.setDomain(&quot;.itheima.com&quot;);

//只有访问该域名下的cookieDemo的这个路径地址才会带cookie
cookie.setPath(&quot;/CookieDemo&quot;);
</code></pre>
<h2 id="cookie示例-实现记住密码功能">Cookie示例 实现记住密码功能</h2>
<ol>
<li>用户打开网站后，自动读取Cookie中存储的用户名、密码</li>
<li>如果存在，自动填充到表单中</li>
<li>如果不存在，说明是第一次登录，需要登录后在后台将用户名、密码写入Cookie中，以便下次登录时自动填充</li>
</ol>
<h3 id="主要实现代码">主要实现代码</h3>
<h4 id="前端登录页">前端登录页</h4>
<pre><code class="language-jsp">&lt;body&gt;
	&lt;form action=&quot;LoginServlet&quot; method=&quot;post&quot;&gt;
		用户名： &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;userName&quot; onblur=&quot;inputPwd()&quot; &gt;
		&lt;br /&gt;
		密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码：
		&lt;input id=&quot;pwd&quot; type=&quot;password&quot; name=&quot;password&quot;&gt;
		&lt;br /&gt;
		&lt;input type=&quot;checkbox&quot; name=&quot;remeber_me&quot; value=&quot;true&quot; /&gt; 记住密码 
		&lt;br /&gt;
		&lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
	&lt;/form&gt;
&lt;/body&gt;
&lt;!-- 引入js操作Cookie的第三方库，也可以使用原生js API --&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
	
	// 从cookies里面按照用户输入的username去查找对应的password,
	// 如果找到，说明用户已经登录成功过，并且已经记录到cookie里。
	// 我们直接把对应的密码从cookie中拿出来，设置password密码框里
	
	// my_cookies其实就是一个map， 存储了所有的cookie键值对
	var my_cookies = Cookies.get();
	console.log(my_cookies);
	
	var pwdInput = document.getElementById(&quot;pwd&quot;);
	var username = document.getElementById(&quot;username&quot;);
	
	// 当输入完用户名，文本框失去焦点时，去cookie中找对应的密码，
	// 如果找到，直接填充到密码框里
	function inputPwd() {
		var userName = username.value;
		var cookieKey = &quot;username-&quot; + userName;
		console.log(cookieKey);
		var cookiePwd = my_cookies[cookieKey];
		console.log(cookiePwd);
		if(cookiePwd) {
			pwdInput.value = cookiePwd;
		}
	}
&lt;/script&gt;
</code></pre>
<h4 id="后台处理代码">后台处理代码</h4>
<pre><code class="language-java">protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		request.setCharacterEncoding(&quot;UTF-8&quot;);
		
		// 获取前台表单提交的用户名、密码
		String userName = request.getParameter(&quot;userName&quot;);
		String password = request.getParameter(&quot;password&quot;);
		
		// 获取前台是否勾上了记住密码
		String sRemeber = request.getParameter(&quot;remeber_me&quot;);
		boolean remeber = false;
		try {
			remeber = Boolean.parseBoolean(sRemeber);
		} catch (Exception e) {
		}
		
		
		// 设置响应格式和编码
		response.setContentType(&quot;text/html;charset=UTF-8&quot;);
		
		PrintWriter out = response.getWriter();
		if(isBlank(userName) || isBlank(password)) {
			out.println(&quot;&lt;script&gt;alert('用户名或密码不能为空!'); window.location.href='login.jsp';&lt;/script&gt;&quot;);
			return;
		}
		
		if(!userAccountData.containsKey(userName)) {
			out.println(&quot;&lt;script&gt;alert('不好意思，您还没有注册！'); window.location.href='login.jsp';&lt;/script&gt;&quot;);
			return;
		}
		
		String orginPassword = userAccountData.get(userName);
		if(password.startsWith(&quot;pwd-&quot;)) {
			password = password.substring(4);
		}
		
		if(orginPassword.equals(password)) {
			out.println(&quot;登录成功！&quot;);
			if(remeber) {
				Cookie cookie = new Cookie(&quot;username-&quot; + userName, &quot;pwd-&quot; + password);
				cookie.setMaxAge(120);
				response.addCookie(cookie);
			}
			return;
		} else {
			out.println(&quot;&lt;script&gt;alert('用户名或密码不正确，请重新输入！'); window.location.href='login.jsp';&lt;/script&gt;&quot;);
			return;
		}
	}
</code></pre>
<h2 id="cookie总结">Cookie总结</h2>
<ol>
<li>
<p>服务器给客户端发送过来的一小份数据，并且存放在客户端上。</p>
</li>
<li>
<p>创建Cookie:</p>
<p>使用new来创建Cookie对象</p>
<pre><code class="language-java">Cookie cookie = new Cookie(&quot;xxx&quot;, &quot;wangzhenongyao&quot;);
</code></pre>
</li>
<li>
<p>添加cookie</p>
<p>添加cookie通过响应对象的addCookie方法</p>
<pre><code class="language-java">// 底层实现原理其实是在响应头中添加了一个： Set-Cookie: password=qiaoshouyuan; Max-Age=60; Expires=Fri, 20-Sep-2019 08:41:19 GMT; HttpOnly
response.addCookie();
</code></pre>
</li>
<li>
<p>获取cookie</p>
<pre><code class="language-java">Cookie[] cookies = request.getCookies();
</code></pre>
</li>
<li>
<p>Cookie有效时间</p>
<ol>
<li>
<p>会话Cookie</p>
<p>默认情况下，关闭了浏览器，那么cookie就会消失。</p>
<blockquote>
<p>这是默认的行为，但是大部分现代的浏览器都不会这么做，比如chrome浏览器，默认打开时会恢复上次关闭时的状态，所有关闭浏览器cookie并不会失效。 我们可以设置浏览器打开时不恢复上次状态，改为打开新的标签页即可。</p>
</blockquote>
</li>
<li>
<p>持久Cookie</p>
<p>通过设置MaxAge指定存活时间，在存活时间内，都有效，并且会保存在客户端上。</p>
</li>
</ol>
<pre><code>cookie.setMaxAge(0); //设置立即删除  
cookie.setMaxAge(100); //100 秒
</code></pre>
</li>
<li>
<p>Cookie的安全问题。</p>
<blockquote>
<p>由于Cookie会保存在客户端上，所以有安全隐患问题。  还有一个问题， Cookie的大小与个数有限制。 为了解决这个问题 ---&gt; Session .</p>
</blockquote>
</li>
<li>
<p>Cookie不能直接存储中文，需要做转码</p>
</li>
</ol>
<h1 id="session">Session</h1>
<blockquote>
<p>会话 ， Session是基于Cookie的一种会话机制。 Cookie是服务器返回一小份数据给客户端，并且存放在客户端上。 Session是，数据存放在服务器端。</p>
</blockquote>
<h2 id="常用api">常用API</h2>
<pre><code class="language-java">//得到会话ID
String id = session.getId();

//存值
session.setAttribute(name, value);

//取值
session.getAttribute(name);

//移除值
session.removeAttribute(name);
</code></pre>
<h2 id="session创建和销毁">Session创建和销毁</h2>
<h3 id="创建">创建</h3>
<blockquote>
<p>在调用所有可以获取session的页面中(如：JSP、Servlet)，就会创建Session，并且浏览器Cookie中也会生成JSESSIONID</p>
</blockquote>
<h3 id="获取session">获取Session</h3>
<pre><code>request.getSession();
</code></pre>
<h3 id="销毁">销毁</h3>
<blockquote>
<p>session 是存放在服务器的内存中的一份数据。</p>
</blockquote>
<blockquote>
<ol>
<li>关闭服务器</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>session会话时间过期。 有效期过了，默认有效期： 30分钟。</li>
</ol>
</blockquote>
<h3 id="移除session中的元素">移除Session中的元素</h3>
<pre><code>//强制干掉会话，里面存放的任何数据就都没有了。
session.invalidate();

//从session中移除某一个数据
//session.removeAttribute(&quot;cart&quot;);
</code></pre>
<h1 id="总结">总结：</h1>
<h2 id="cookie-2">Cookie</h2>
<p>服务器给客户端发送一小份数据， 存放在客户端上。</p>
<h3 id="基本用法">基本用法：</h3>
<pre><code>添加cookie

获取cookie。
</code></pre>
<h3 id="什么时候有cookie">什么时候有cookie</h3>
<p>response.addCookie(new Cookie())</p>
<h3 id="cookie-分类">Cookie 分类</h3>
<ul>
<li>
<p>会话Cookie</p>
<pre><code>  关闭浏览器，就失效
</code></pre>
</li>
<li>
<p>持久cookie</p>
<p>存放在客户端上。 在指定的期限内有效。</p>
<pre><code>	setMaxAge();
</code></pre>
</li>
</ul>
<h2 id="session-2">Session</h2>
<p>也是基于cookie的一种会话技术，  数据存放存放在服务器端，会在cookie里面添加一个字段 JSESSIONID . 是tomcat服务器生成。</p>
<h3 id="常用api-2">常用API</h3>
<pre><code>
setAttribute 存数据
 
getAttribute 取数据

removeAttribute  移除数据

req.getRequestedSessionId();  获取会话id
session.getId();  获取会话id

invalidate() 强制让会话失效。
</code></pre>
<h3 id="创建和销毁">创建和销毁</h3>
<ul>
<li>创建： 首次访问所有可以调用request.getSession方法的页面时，session创建，同时JSESSIONID也会生成</li>
<li>销毁：
<ul>
<li>关闭浏览器</li>
<li>会话超时（默认是30分钟）</li>
<li>服务端调用invalidate</li>
</ul>
</li>
</ul>
<h2 id="cookie和session的区别">Cookie和Session的区别</h2>
<ol>
<li>Cookie数据存放到客户端（浏览器），Session存放在服务端；</li>
<li>Cookie存放的数据大小有限制，不能超过4k；很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>Cookie由于存放在客户端硬盘上，所以相较于Session来说安全性低一点；</li>
<li>cookie失效时间是通过setMaxAge来设置，session是通过setInactiveInterval方法设置</li>
<li>Cookie中只能存储字符串的值，而且还不能中文。而Session中可以存储任意语言的字符串，或者Java中的所有类型。</li>
<li>Cookie是由程序员在业务代码中自己创建的，而Session是由容器创建的。</li>
</ol>
<h2 id="cookie和session的关系">Cookie和Session的关系</h2>
<p>HTTP协议本身是无状态的，也就是说服务端无法通过一个请求判断出谁是谁，而Session作为服务端跟踪用户状态的一项技术，在整个容器中存在很多份数据。如何知道一个请求进来应该拿哪份Session数据这是个问题。那么要解决这个问题，我们需要在请求中添加一个标识，Cookie技术就解决了这个问题。具体来说，Tomcat会在浏览器第一次访问JSP、Servlet时分配一个独一无二的Cookie标识(JSESSIONID)，写到浏览器端。后续每次请求时，浏览器会携带这个标识，进而服务端就可以区分出来谁是谁，然后拿对应的Session数据。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Litener&Filter]]></title>
        <id>https://ysjhhhhhhh.github.io/post/Litener&amp;Filter</id>
        <link href="https://ysjhhhhhhh.github.io/post/Litener&amp;Filter">
        </link>
        <updated>2018-03-28T02:04:40.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="listener">Listener</h1>
<blockquote>
<p>监听器</p>
</blockquote>
<ul>
<li>能做什么事？</li>
</ul>
<blockquote>
<p>监听某一个事件的发生。 状态的改变。</p>
</blockquote>
<ul>
<li>监听器的内部机制</li>
</ul>
<blockquote>
<p>其实就是接口回调.</p>
</blockquote>
<h2 id="监听器实现原理观察者模式">监听器实现原理——观察者模式</h2>
<ul>
<li>需求：</li>
</ul>
<blockquote>
<p>A在执行循环，当循环到5的时候， 通知B。</p>
</blockquote>
<blockquote>
<p>事先先把一个对象传递给 A ， 当A 执行到5的时候，通过这个对象，来调用B中的方法。 但是注意，不是直接传递B的实例，而是传递一个接口的实例过去。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://ysjhhhhhhh.github.io/post-images/1576044349452.png" alt=""></figure>
<h2 id="web监听器介绍">Web监听器介绍</h2>
<p>在JavaWeb开发中监听器总共有8个</p>
<h3 id="按照使用方法来划分可以分为两类">按照使用方法来划分可以分为两类</h3>
<h4 id="第一类-实现接口然后通过注册生效">第一类 实现接口然后通过注册生效</h4>
<p>具体配置步骤</p>
<ol>
<li>实现对应的监听器接口</li>
<li>重写接口中的方法</li>
<li>然后在web.xml或者注解的方式注册到容器中来使用</li>
</ol>
<p>适用的监听器类型</p>
<p>ServletRequestListener、HttpSessionListener、ServletContextListener、ServletRequestAttributeListener、HttpSessionAttributeListener、SerlvetContextAttributeListener</p>
<h4 id="第二类-让需要监听session中的特定类型实现监听接口不需要注册生效">第二类  让需要监听Session中的特定类型实现监听接口，不需要注册生效</h4>
<p>具体配置步骤</p>
<ol>
<li>让需要监听Session中的特定类型，如UserInfo实现监听接口</li>
<li>实现接口中的方法</li>
</ol>
<p>适用的监听器类型</p>
<p>HttpSessionBindingListener、HttpSessionActivationListener</p>
<h3 id="按照监听器的作用可以划分为三类">按照监听器的作用可以划分为三类</h3>
<h4 id="监听三个作用域创建和销毁">监听三个作用域创建和销毁</h4>
<ul>
<li>request  ---HttpServletRequest</li>
<li>session  ---HttpSession</li>
<li>application  --- ServletContext</li>
</ul>
<h5 id="servletrequestlistener">ServletRequestListener</h5>
<ul>
<li>监听事件</li>
</ul>
<pre><code>request创建:

    访问服务器上的任意资源都会有请求出现。

    访问 html： 会
    访问 jsp:	会
    访问 servlet : 会 

request销毁：

	服务器已经对这次请求作出了响应。			
</code></pre>
<ul>
<li>实现示例</li>
</ul>
<ol>
<li>新建Java类，实现ServletRequestListener接口</li>
</ol>
<pre><code class="language-java">import javax.servlet.ServletRequestEvent;
import javax.servlet.ServletRequestListener;

public class RequestListener implements ServletRequestListener {

	@Override
	public void requestDestroyed(ServletRequestEvent sre) {
		System.out.println(&quot;request请求结束&quot;);
	}

	@Override
	public void requestInitialized(ServletRequestEvent sre) {
		System.out.println(&quot;request请求开始&quot;);
	}
}
</code></pre>
<ol start="2">
<li>在web.xml中注册监听器</li>
</ol>
<pre><code class="language-xml">&lt;listener&gt;
    &lt;listener-class&gt;com.lanou3g.demo.RequestListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<h5 id="httpsessionlistener">HttpSessionListener</h5>
<ul>
<li>监听事件</li>
</ul>
<pre><code>	session的创建
	    只要调用getSession
	
	    html:		不会
	    jsp:		会	  getSession();
	    servlet: 	会
	
	session的销毁
	    超时  30分钟
	    非正常关闭 销毁
	    正常关闭服务器(序列化)
</code></pre>
<ul>
<li>应用场景</li>
</ul>
<blockquote>
<p>统计在线人数.</p>
</blockquote>
<ul>
<li>实现示例</li>
</ul>
<ol>
<li>新建Java类，实现HttpSessionListener接口</li>
</ol>
<pre><code class="language-java">import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;

public class SessionLinsener implements HttpSessionListener {
	@Override
	public void sessionCreated(HttpSessionEvent se) {
		System.out.println(&quot;session被创建了&quot;);
	}

	@Override
	public void sessionDestroyed(HttpSessionEvent se) {
		System.out.println(&quot;session销毁了&quot;);
	}
}
</code></pre>
<ol start="2">
<li>在web.xml中注册监听器</li>
</ol>
<pre><code class="language-xml">&lt;listener&gt;
    &lt;listener-class&gt;com.lanou3g.demo.SessionLinsener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<h5 id="servletcontextlistener">ServletContextListener</h5>
<ul>
<li>
<p>监听事件</p>
<ul>
<li>
<p>ServletContext创建：启动服务器的时候</p>
</li>
<li>
<p>ServletContext销毁：关闭服务器. 从服务器移除项目</p>
</li>
</ul>
</li>
<li>
<p>应用场景</p>
</li>
</ul>
<blockquote>
<p>在servletcontext创建的时候，</p>
<ol>
<li>完成自己想要的初始化工作</li>
<li>执行自定义任务调度。 执行某一个任务。 Timer</li>
</ol>
</blockquote>
<ul>
<li>实现示例</li>
</ul>
<p>新建Java类，实现ServletContextListener接口</p>
<pre><code class="language-java">import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;

public class ContextListener implements ServletContextListener {
	@Override
	public void contextInitialized(ServletContextEvent sce) {
		System.out.println(&quot;ServletContext初始化&quot;);
	}
	@Override
	public void contextDestroyed(ServletContextEvent sce) {
		System.out.println(&quot;ServletContext销毁&quot;);
	}
}
</code></pre>
<p>在web.xml中注册监听器</p>
<pre><code class="language-xml">&lt;listener&gt;
    &lt;listener-class&gt;com.lanou3g.demo.ContextListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<h4 id="监听三个作用域属性状态变更">监听三个作用域属性状态变更</h4>
<blockquote>
<p>可以监听在作用域中值 添加  | 替换  | 移除的动作。</p>
</blockquote>
<h5 id="servletcontext-servletcontextattributelistener">servletContext --- ServletContextAttributeListener</h5>
<figure data-type="image" tabindex="2"><img src="https://ysjhhhhhhh.github.io/post-images/1576044425334.png" alt=""></figure>
<h5 id="request-servletrequestattributelistener">request --- ServletRequestAttributeListener</h5>
<figure data-type="image" tabindex="3"><img src="https://ysjhhhhhhh.github.io/post-images/1576044439138.png" alt=""></figure>
<h5 id="session-httpsessionattributelistener">session --- HttpSessionAttributeListener</h5>
<figure data-type="image" tabindex="4"><img src="https://ysjhhhhhhh.github.io/post-images/1576044413990.png" alt=""></figure>
<h4 id="监听httpsession里面存值的状态变更">监听httpSession里面存值的状态变更</h4>
<blockquote>
<p>这一类监听器不用注册。</p>
</blockquote>
<h5 id="httpsessionbindinglistener">HttpSessionBindingListener</h5>
<blockquote>
<p>监听特定类型对象与session 绑定和解除绑定 的动作，注意此监听器是让JavaBean实现监听接口，即表示当session中此类型的value状态发生变更时，此JavaBean会收到通知</p>
</blockquote>
<p><span style="color:red;font-weight:bold;">与HttpSessionAttributeListener监听器不同的是，该监听器只对Session中的某种特定类型的属性变化感兴趣</span></p>
<pre><code class="language-java">// 注意：是让JavaBean实现该接口，不需要添加任何注解或在web.xml中配置

import javax.servlet.http.HttpSessionBindingEvent;
import javax.servlet.http.HttpSessionBindingListener;

public class Man implements HttpSessionBindingListener {

	private String name;
	private String nickName;
	private int age;

	public Man() {
	}

	public Man(String name, String nickName, int age) {
		this.name = name;
		this.nickName = nickName;
		this.age = age;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getNickName() {
		return nickName;
	}

	public void setNickName(String nickName) {
		this.nickName = nickName;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	@Override
	public void valueBound(HttpSessionBindingEvent event) {
		Man man = (Man) event.getValue();
		System.out.println(&quot;man对象绑定到session中 name: &quot; + man.getName() + &quot;, value: &quot; + event.getValue());
	}

	@Override
	public void valueUnbound(HttpSessionBindingEvent event) {
		Man man = (Man) event.getValue();
		System.out.println(&quot;man对象从session中解绑 name: &quot; + man.getName() + &quot;, value: &quot; + event.getValue());
	}
}
</code></pre>
<h5 id="httpsessionactivationlistener">HttpSessionActivationListener</h5>
<blockquote>
<p>用于监听现在session的值 是 钝化 （序列化）还是活化 （反序列化）的动作</p>
</blockquote>
<ul>
<li>钝化 （序列化）</li>
</ul>
<blockquote>
<p>把内存中的数据 存储到硬盘上</p>
</blockquote>
<ul>
<li>活化 （反序列化）</li>
</ul>
<blockquote>
<p>把硬盘中的数据读取到内存中。</p>
</blockquote>
<ul>
<li>session的钝化活化的用意何在</li>
</ul>
<blockquote>
<p>session中的值可能会很多， 并且我们有很长一段时间不使用这个内存中的值， 那么可以考虑把session的值可以存储到硬盘上【钝化】，等下一次在使用的时候，在从硬盘上提取出来。 【活化】</p>
</blockquote>
<ul>
<li>如何让session的在一定时间内钝化.</li>
</ul>
<h6 id="钝化-活化监听需要修改tomcat配置">钝化、活化监听需要修改Tomcat配置</h6>
<p>修改的地方有三个可选，主要是作用范围不一样</p>
<pre><code>1. 在tomcat里面 conf/context.xml 里面配置

		对所有的运行在这个服务器的项目生效

2. 在conf/Catalina/localhost/context.xml 配置

		对 localhost生效。  localhost:8080

3. 在自己的web工程项目中的 META-INF/context.xml

		只对当前的工程生效。
</code></pre>
<p>修改方法：</p>
<pre><code class="language-xml">	&lt;!--
		参数说明：
		# maxIdleSwap ： 1分钟不用就钝化
		# directory ：  钝化后的那个文件存放的目录位置。 
	--&gt;
	&lt;Context&gt;
		&lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot; maxIdleSwap=&quot;1&quot;&gt;
			&lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;F:/temp&quot;/&gt;
		&lt;/Manager&gt;
	&lt;/Context&gt;
</code></pre>
<h6 id="监听器使用步骤">监听器使用步骤</h6>
<ol>
<li>与HttpSessionBindingListener类似， HttpSessionActivationListener也是针对特定类型监听的。那我们需要让需要监听钝化、活化状态的特定的JavaBean实现HttpSessionActivationListener接口</li>
<li>上面提到的几种配置方法，任选一种告诉Tomcat当Session不活跃、或者容器停止时Session钝化的策略</li>
</ol>
<p>做好上面两步，当Session中有监听的特定类型，并且Session钝化、活化时就能触发通知</p>
<h2 id="filter">Filter</h2>
<blockquote>
<p>过滤器 ， 其实就是对客户端发出来的请求进行过滤。 浏览器发出， 然后服务器派servlet处理。  在中间就可以过滤， 其实过滤器起到的是拦截的作用。</p>
</blockquote>
<ul>
<li>
<p>作用</p>
<ol>
<li>对一些敏感词汇进行过滤</li>
<li>统一设置编码</li>
<li>自动登录</li>
</ol>
<p>...</p>
</li>
</ul>
<h3 id="如何使用filter">如何使用Filter</h3>
<ol>
<li>定义一个类， 实现Filter</li>
</ol>
<pre><code class="language-java">public class FilterDemo implements Filter {	
    public void destroy() {
    }

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    System.out.println(&quot;来到过虑器了。。。&quot;);
    chain.doFilter(request, response);
    }

    public void init(FilterConfig fConfig) throws ServletException {
    }
}
</code></pre>
<ol start="2">
<li>注册过滤器</li>
</ol>
<blockquote>
<p>在web.xml里面注册，注册的手法与servlet基本一样。</p>
</blockquote>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;display-name&gt;FilterDemo&lt;/display-name&gt;
    &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt;
    &lt;filter-class&gt;com.itheima.filter.FilterDemo&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<blockquote>
<p>在Servlet3.0里可以通过 @WebFilter注解配置</p>
</blockquote>
<h3 id="filter的生命周期">Filter的生命周期</h3>
<ul>
<li>创建</li>
</ul>
<blockquote>
<p>在服务器启动的时候就创建。</p>
</blockquote>
<ul>
<li>销毁</li>
</ul>
<blockquote>
<p>服务器停止的时候。</p>
</blockquote>
<h3 id="filter执行顺序">Filter执行顺序</h3>
<ol>
<li>
<p>客户端发出请求，先经过过滤器， 如果过滤器放行，那么才能到servlet</p>
</li>
<li>
<p>如果有多个过滤器， 那么他们会按照注册的映射顺序 来 排队。 只要有一个过滤器， 不放行，那么后面排队的过滤器以及咱们的servlet都不会收到请求。</p>
</li>
</ol>
<h3 id="filter细节">Filter细节</h3>
<ol>
<li>
<p>init方法的参数 FilterConfig , 可以用于获取filter在注册的名字 以及初始化参数。  其实这里的设计的初衷与ServletConfig是一样的。</p>
</li>
<li>
<p>如果想放行，那么在doFilter 方法里面操作，使用参数 chain</p>
</li>
</ol>
<pre><code class="language-java">chain.doFilter(request, response); 放行， 让请求到达下一个目标。
</code></pre>
<ol start="3">
<li>
<p><url-pattern>/*</url-pattern> 写法格式与servlet一样。</p>
<ol>
<li>
<p>全路径匹配  以 /  开始</p>
<pre><code> /LoginServlet
</code></pre>
</li>
<li>
<p>以目录匹配 以 / 开始  以 * 结束</p>
<p>/demo01/*</p>
</li>
<li>
<p>以后缀名匹配  以 * 开始 以后缀名结束</p>
<p>*.jsp  *.html *.do</p>
</li>
</ol>
<blockquote>
<p>注意：*号只能代表一段目录或者文件名，不能代替单词中的部分字母</p>
</blockquote>
</li>
<li>
<p>针对 dispatcher 设置</p>
<pre><code> ​	REQUEST ： 只要是请求过来，都拦截，默认就是REQUEST 
</code></pre>
<p>​	FORWARD : 只要是转发都拦截。<br>
​	ERROR ： 页面出错发生跳转<br>
​	INCLUDE ： 包含页面的时候就拦截。<br>
​</p>
</li>
</ol>
<h3 id="案例一-实现自动登录">案例一 实现自动登录</h3>
<ul>
<li>
<p>需求分析</p>
<ol>
<li>用户正常登录过一次以后，只要session不失效，用户可以直接访问网站中的其他页面，而不用再次登录。</li>
<li>如果没有登录或者session失效了， 那直接访问其他页面重定向到登录页面</li>
</ol>
</li>
</ul>
<h4 id="1-搭建环境">1. 搭建环境</h4>
<ol>
<li>搭建数据库</li>
<li>搭建页面</li>
</ol>
<h4 id="2-部分后台代码">2. 部分后台代码</h4>
<p>登录servlet代码</p>
<pre><code class="language-java">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

	try {
		String userName = request.getParameter(&quot;username&quot;);
		String password = request.getParameter(&quot;password&quot;);
		String autoLogin = request.getParameter(&quot;auto_login&quot;);
		UserBean user = new UserBean();
		user.setUsername(userName);
		user.setPassword(password);
		
		UserDao dao = new UserDaoImpl();
		UserBean userBean = dao.login(user);
		
		if(userBean != null){
			//成功了，进入首页
			request.getSession().setAttribute(&quot;userBean&quot;, userBean);
			response.sendRedirect(&quot;index.jsp&quot;);
		}else{
			//不成功...
			request.getRequestDispatcher(&quot;login.jsp&quot;).forward(request, response);
		}
		
	} catch (SQLException e) {
		e.printStackTrace();
	}
}
</code></pre>
<p>过滤器代码</p>
<ul>
<li>实现思路</li>
</ul>
<ol>
<li>
<p>先判断session是否有效， 如果失效了，直接把请求重定向到登录页，让用户完成手动登录</p>
</li>
<li>
<p>如果session没有失效，那么就从session中获取用户登录信息和数据库中做对比，如果正确就可以正常登录。否则重定向到登录页，让用户手动登录。</p>
</li>
</ol>
<pre><code class="language-java">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		
		HttpServletRequest req = (HttpServletRequest) request;
		HttpServletResponse resp = (HttpServletResponse) response;
		HttpSession session = req.getSession();
		
		// 如果session里没有登录信息，无法自动登录，重定向到登录页，让用户手动登录
		if(session.getAttribute(&quot;username&quot;) == null) {
			resp.sendRedirect(&quot;login.jsp&quot;);
			return;
		}
		
		String username = (String) session.getAttribute(&quot;username&quot;);
		String password = (String) session.getAttribute(&quot;password&quot;);
		
		// 检查session中的登录信息是否正确
		if(checkValid(username, password)) {
			chain.doFilter(request, response);
		}
	}
</code></pre>
<h2 id="总结">总结</h2>
<h3 id="listener-2">Listener</h3>
<pre><code>8个 

三种类型  
	针对三个作用域的创建和销毁
	针对三个作用域的值改变 【添加 | 替换 | 移除】
	针对session中的值 【钝化 活化】 ， 【绑定  解绑】

钝化 ( 序列化 ) 
	内存中的对象存储到硬盘 

	超时失效。 session销毁了。 

非正常关闭服务器， 钝化  。 正常关闭服务器 销毁

设置了session钝化策略：context.xml

活化 (反序列化)
	从硬盘里面读取到内存
</code></pre>
<p>应用场景：</p>
<p>ServletContextListner  ： 应用被部署的时候， 服务器加载这个项目的时候，做一些初始化工作， 任务调度。<br>
HttpSessionBindingListener	： 统计在线人数<br>
HttpSessionActivationListener  ： 钝化活化处理</p>
<h3 id="filter-2">Filter</h3>
<blockquote>
<p>使用频率更高</p>
</blockquote>
<ul>
<li>如果要写一个过滤器。</li>
</ul>
<blockquote>
<ol>
<li>定义一个类，实现接口 Filter</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>注册 web.xml . 与servlet相似。</li>
</ol>
</blockquote>
<ul>
<li>过滤器放行。</li>
</ul>
<blockquote>
<p>chain.doFilter(request, response);</p>
</blockquote>
<ul>
<li>
<p>过滤器生命周期</p>
<p>创建： 服务器加载这个项目的时候创建实例</p>
<p>销毁： 关闭服务器或者从服务器中移除项目的时候。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文件上传]]></title>
        <id>https://ysjhhhhhhh.github.io/post/wen-jian-shang-chuan</id>
        <link href="https://ysjhhhhhhh.github.io/post/wen-jian-shang-chuan">
        </link>
        <updated>2018-03-27T11:44:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前端页面">前端页面</h2>
<h3 id="必要条件">必要条件</h3>
<ol>
<li>需要有一个form表单</li>
<li>form表单需要设置以下几个属性：
<ol>
<li>action:  提交数据的目的地</li>
<li>method: 设置post</li>
<li>enctype: 设置成multipart/form-data</li>
</ol>
</li>
<li>form里需要至少有一个file域： &lt;input type=&quot;file&quot; name=&quot;xxx&quot; /&gt;</li>
</ol>
<h2 id="后端技术">后端技术</h2>
<p>所谓文件上传其实就是用流的方式，将文件从客户的电脑上通过网页中的表单， 以二进制流的方式，流到服务器的过程。</p>
<p>文件下载就是反过来， 将文件从服务器上通过二进制流的方式流到客户电脑上。</p>
<h3 id="servlet30上传方式">Servlet3.0上传方式</h3>
<h4 id="servlet30上传的核心-一个注解-一个接口">Servlet3.0上传的核心： 一个注解、一个接口</h4>
<p>注解：</p>
<p>@MultipartConfig： 开启Servlet文件上传功能</p>
<p>接口：</p>
<p>javax.servlet.http.Part：  封装了上传的文件相关的所有信息</p>
<h4 id="具体操作步骤">具体操作步骤</h4>
<ol>
<li>新建处理文件上传的Servlet，然后重写doPost方法</li>
<li>给Servlet添加@MultipartConfig注解，开启文件上传功能</li>
<li>Part part = request.getPart(&quot;input type='type' name的值&quot;);</li>
<li>part对象有两个作用：
<ol>
<li>可以获取到上传文件的所有信息，比如：文件名、大小、类型、文件流数据</li>
<li>可以直接将文件写到服务器   part.write(&quot;文件保存的路径&quot;);</li>
</ol>
</li>
</ol>
<h3 id="apache-commons-fileupload-上传方式">Apache Commons Fileupload 上传方式</h3>
<h4 id="用fileupload上传的核心就是一个接口-两个类">用fileupload上传的核心就是：一个接口、两个类</h4>
<p>接口： FileItem</p>
<p>封装了我们表单中的每个域的数据（可能是普通文本数据，也可能是上传的文件）</p>
<p>类：</p>
<p>DiskFileItemFactory：  用于创建文件上传对象的工厂</p>
<p>ServletFileupload： 文件上传对象</p>
<h4 id="具体操作步骤-2">具体操作步骤</h4>
<ol>
<li>
<p>需要添加依赖： commons-fileupload.jar、commons-io.jar</p>
</li>
<li>
<p>新建处理文件上传的Servlet，然后重写doPost方法</p>
</li>
<li>
<p>调用ServletFileupload对象的静态方法，判断请求是否是一个文件上传请求</p>
<pre><code class="language-java">if(!ServletFileupload.isMultipartContent(request)) {
    // 如果不是multipart请求，代表不是一个有效的文件上传请求， 下面的步骤都可以省略了
}
</code></pre>
</li>
<li>
<p>创建文件上传工厂对象：</p>
<pre><code class="language-java">DiskFileItemFactory factory = new DiskFileItemFactory();
// factory.set.... 可以设置相关参数
</code></pre>
</li>
<li>
<p>创建文件上传对象</p>
<pre><code class="language-java">ServletFileupload upload = new ServletFileupload(factory);
// upload.set.... 可以设置相关参数
</code></pre>
</li>
<li>
<p>用文件上传对象解析请求对象，然后获取解析后的所有FileItem</p>
<pre><code class="language-java">List&lt;FileItem&gt; fileItems = upload.parseRequest(request);
</code></pre>
</li>
<li>
<p>迭代处理每个FileItem</p>
<ol>
<li>文本信息的FileItem获取后进行相关的业务操作</li>
<li>文件类型的FileItem获取后，调用FileItem.write将文件写到服务器某个目录下。</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JSP & EL & JSTL]]></title>
        <id>https://ysjhhhhhhh.github.io/post/jsp-and-el-and-jstl</id>
        <link href="https://ysjhhhhhhh.github.io/post/jsp-and-el-and-jstl">
        </link>
        <updated>2018-03-26T05:57:33.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="jsp基础知识">JSP基础知识</h2>
<blockquote>
<p>JSP全称Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servlet设计，它是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。</p>
</blockquote>
<ul>
<li>什么是jsp</li>
</ul>
<blockquote>
<p>从用户角度看待 ，就是是一个网页 ， 从程序员角度看待 ， 其实是一个java类， 它继承了servlet，所以可以直接说jsp 就是一个Servlet.</p>
</blockquote>
<ul>
<li>为什么会有jsp?</li>
</ul>
<blockquote>
<p>html 多数情况下用来显示静态内容 ， 一成不变的。 但是有时候我们需要在网页上显示一些动态数据， 比如： 查询所有的学生信息， 根据姓名去查询具体某个学生。  这些动作都需要去查询数据库，然后在网页上显示。 html是不支持写java代码  ， jsp里面可以写java代码。</p>
</blockquote>
<ul>
<li>动态网页</li>
</ul>
<blockquote>
<p>所谓的动态网页，是指跟静态网页相对的一种网页编程技术。静态网页，随着html代码的生成，页面的内容和显示效果就基本上不会发生变化了——除非你修改页面代码。而动态网页则不然，页面代码虽然没有变，但是显示的内容却是可以随着时间、环境或者数据库操作的结果而发生改变的。</p>
<p>不要将动态网页和页面内容是否有动感混为一谈。这里说的动态网页，与网页上的各种动画、滚动字幕等视觉上的动态效果没有直接关系，动态网页也可以是纯文字内容的，也可以是包含各种动画的内容，这些只是网页具体内容的表现形式，无论网页是否具有动态效果，只要是采用了动态网站技术生成的网页都可以称为动态网页。</p>
</blockquote>
<h3 id="页面结构">页面结构</h3>
<h3 id="jsp声明变量-方法">JSP声明变量、方法</h3>
<pre><code class="language-jsp">&lt;%! 

  private int age = 0;
	
	public void sayHello() {
     out.println(&quot;Hello World!&quot;);
  }
  
%&gt;
</code></pre>
<h3 id="jsp表达式">JSP表达式</h3>
<pre><code class="language-jsp">&lt;%=age %&gt;
</code></pre>
<h3 id="java代码片段">Java代码片段</h3>
<pre><code class="language-jsp">&lt;%

age = age + 10;
sayHello();

%&gt;
</code></pre>
<h3 id="jsp注释">JSP注释</h3>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>语法</strong></th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&lt;%-- 注释 --%&gt;</td>
<td style="text-align:left">JSP注释，注释内容不会被发送至浏览器甚至不会被编译</td>
</tr>
<tr>
<td style="text-align:left"><!-- 注释 --></td>
<td style="text-align:left">HTML注释，通过浏览器查看网页源代码时可以看见注释内容</td>
</tr>
<tr>
<td style="text-align:left">&lt;%</td>
<td style="text-align:left">代表静态 &lt;%常量</td>
</tr>
<tr>
<td style="text-align:left">%\&gt;</td>
<td style="text-align:left">代表静态 %&gt; 常量</td>
</tr>
<tr>
<td style="text-align:left">\'</td>
<td style="text-align:left">在属性中使用的单引号</td>
</tr>
<tr>
<td style="text-align:left">\&quot;</td>
<td style="text-align:left">在属性中使用的双引号</td>
</tr>
</tbody>
</table>
<h3 id="jsp生命周期">JSP生命周期</h3>
<figure data-type="image" tabindex="1"><img src="img/jsp_life_cycle.jpg" alt="JSP生命周期"></figure>
<ul>
<li>
<p>编译阶段</p>
<p>当浏览器请求JSP页面时，JSP引擎会首先去检查是否需要编译这个文件。如果这个文件没有被编译过，或者在上次编译后被更改过，则编译这个JSP文件。</p>
<ul>
<li>解析JSP文件</li>
<li>将JSP文件转为Servlet</li>
<li>编译Servlet文件</li>
</ul>
</li>
<li>
<p>初始化阶段</p>
<p>加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法</p>
<pre><code class="language-java">// 可以重写此方法，添加初始化逻辑
public void _jspInit() {
}
</code></pre>
</li>
<li>
<p>执行阶段</p>
<p>调用与JSP对应的servlet实例的服务方法</p>
<pre><code class="language-java">public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)throws java.io.IOException, javax.servlet.ServletException {
  // 分发请求
  // doGet
  // doPost
}
</code></pre>
</li>
<li>
<p>销毁阶段</p>
<p>调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例</p>
<pre><code class="language-java">// 可以重写此方法，添加销毁操作
public void _jspDestroy() {
}
</code></pre>
</li>
</ul>
<h2 id="三大jsp指令">三大JSP指令</h2>
<h3 id="指令写法">指令写法</h3>
<p>&lt;%@ 指令名字 属性名=&quot;属性值&quot; %&gt;</p>
<h3 id="page指令">page指令</h3>
<ul>
<li>language</li>
</ul>
<blockquote>
<p>表明jsp页面中可以写java代码</p>
</blockquote>
<ul>
<li>contentType</li>
</ul>
<blockquote>
<p>其实即使说这个文件是什么类型，告诉浏览器我是什么内容类型，以及使用什么编码</p>
</blockquote>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
</code></pre>
<ul>
<li>
<p>pageEncoding  jsp内容编码</p>
</li>
<li>
<p>extends 用于指定jsp翻译成java文件后，继承的父类是谁，一般不用改。</p>
</li>
<li>
<p>import 导包使用的，一般不用手写。</p>
</li>
<li>
<p>session</p>
</li>
</ul>
<blockquote>
<p>值可选的有true or false .</p>
</blockquote>
<blockquote>
<p>用于控制在这个jsp页面里面，能够直接使用session对象。</p>
</blockquote>
<blockquote>
<p>具体的区别是，请看翻译后的java文件   如果该值是true , 那么在代码里面会有getSession（）的调用，如果是false :  那么就不会有该方法调用，也就是没有session对象了。在页面上自然也就不能使用session了。</p>
</blockquote>
<ul>
<li>errorPage</li>
</ul>
<blockquote>
<p>指的是错误的页面， 值需要给错误的页面路径</p>
</blockquote>
<ul>
<li>isErrorPage</li>
</ul>
<blockquote>
<p>上面的errorPage 用于指定错误的时候跑到哪一个页面去。 那么这个isErroPage , 就是声明某一个页面到底是不是错误的页面。</p>
</blockquote>
<h3 id="include指令">include指令</h3>
<blockquote>
<p>包含另外一个jsp的内容进来。</p>
</blockquote>
<pre><code>	&lt;%@ include file=&quot;other02.jsp&quot;%&gt;
</code></pre>
<ul>
<li>背后细节:</li>
</ul>
<blockquote>
<p>把另外一个页面的所有内容拿过来一起输出。 所有的标签元素都包含进来。</p>
</blockquote>
<h3 id="taglib">taglib</h3>
<p>作用：用于引入标签库</p>
<p>语法：&lt;%@ taglib prefix=&quot;&quot;  uri=&quot;&quot;%&gt;</p>
<pre><code>uri: 标签库路径
prefix : 标签库的别名  
</code></pre>
<h2 id="七大jsp-动作标签">七大JSP 动作标签</h2>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdn.net/20160715152725431?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="七大动作标签"></figure>
<h3 id="jspinclude">jsp:include</h3>
<pre><code class="language-jsp">&lt;jsp:include page=&quot;other02.jsp&quot;&gt;&lt;/jsp:include&gt;
</code></pre>
<blockquote>
<p>包含指定的页面， 这里是动态包含。 也就是不把包含的页面所有元素标签全部拿过来输出，而是把它的运行结果拿过来。</p>
</blockquote>
<h3 id="jspforward">jsp:forward</h3>
<pre><code class="language-jsp">&lt;!-- 不带参数跳转 --&gt;
&lt;jsp:forward page=&quot;test.jsp&quot;&gt;&lt;/jsp:forward&gt;
&lt;jsp:forward page=&quot;test.jsp&quot; /&gt;

&lt;!-- 带参数跳转 --&gt;
&lt;!-- 中文参数会出现乱码，因为底层是通过URIEncoding来编码的，默认取的是request.getCharsetEncoding() , 要解决此乱码问题，我们需要再跳转前设置 request.setCharsetEncoding(&quot;UTF-8&quot;);
--&gt;
&lt;% request.setCharsetEncoding(&quot;UTF-8&quot;); %&gt;
&lt;jsp:forward page=&quot;test.jsp&quot;&gt;
	&lt;jsp:param name=&quot;sname&quot; value=&quot;zhangsan&quot; /&gt;
&lt;/jsp:forward&gt;

&lt;!-- 如果这样写，中间必须加上param子标签 --&gt;
&lt;jsp:forward page=&quot;test.jsp&quot;&gt;
&lt;/jsp:forward&gt;
</code></pre>
<blockquote>
<p>前往哪一个页面。</p>
</blockquote>
<h3 id="jspparam">jsp:param</h3>
<blockquote>
<p>意思是： 在包含某个页面的时候，或者在跳转某个页面的时候，加入这个参数。</p>
</blockquote>
<pre><code class="language-jsp">&lt;jsp:forward page=&quot;other02.jsp&quot;&gt;
  &lt;jsp:param value=&quot;beijing&quot; name=&quot;address&quot;/&gt;
&lt;/jsp:forward&gt;

在other02.jsp中获取参数

&lt;br&gt;收到的参数是：&lt;br&gt;

&lt;%= request.getParameter(&quot;address&quot;)%&gt;
</code></pre>
<h3 id="jspusebeanjspsetpropertyjspgetproperty">jsp:useBean&amp;jsp:setProperty&amp;jsp:getProperty</h3>
<p>这组动作标签用于实例化JavaBean，并且设置、获取属性</p>
<pre><code class="language-jsp">&lt;jsp:useBean id=&quot;stu&quot; class=&quot;com.lanou3g.demo.bean.Student&quot; /&gt;
&lt;jsp:setProperty name=&quot;stu&quot; property=&quot;sname&quot; value=&quot;张三&quot; /&gt;
&lt;jsp:getProperty property=&quot;sname&quot; name=&quot;stu&quot;/&gt;
</code></pre>
<h2 id="jsp九大内置对象">JSP九大内置对象</h2>
<blockquote>
<p>所谓内置对象，就是我们可以直接在jsp页面中使用这些对象。 不用创建。</p>
</blockquote>
<h3 id="pagecontext-javaxservletjsppagecontext">pageContext 【javax.servlet.jsp.PageContext】</h3>
<p>作用：为JSP页面包装页面的上下文。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>forward</td>
<td>重定向到另一页面或Servlet组件</td>
</tr>
<tr>
<td>getAttribute</td>
<td>获取某范围中指定名字的属性值</td>
</tr>
<tr>
<td>findAttribute</td>
<td>按范围搜索指定名字的属性</td>
</tr>
<tr>
<td>removeAttribute</td>
<td>删除某范围中指定名字的属性</td>
</tr>
<tr>
<td>setAttribute</td>
<td>设定某范围中指定名字的属性值</td>
</tr>
<tr>
<td>getException</td>
<td>返回当前异常对象</td>
</tr>
<tr>
<td>getRequest</td>
<td>返回当前请求对象</td>
</tr>
<tr>
<td>getResponse</td>
<td>返回当前响应对象</td>
</tr>
<tr>
<td>getServletConfig</td>
<td>返回当前页面的ServletConfig对象</td>
</tr>
<tr>
<td>getServletContext</td>
<td>返回所有页面共享的ServletContext对象</td>
</tr>
<tr>
<td>getSession</td>
<td>返回当前页面的会话对象</td>
</tr>
</tbody>
</table>
<h3 id="request-javaxservlethttphttpservletrequest">request   【javax.servlet.http.HttpServletRequest】</h3>
<p>作用：向服务端请求数据</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>isUserInRole</td>
<td>判断认证后的用户是否属于某一成员组</td>
</tr>
<tr>
<td>getAttribute</td>
<td>获取指定属性的值,如该属性值不存在返回Null</td>
</tr>
<tr>
<td>getAttributeNames</td>
<td>获取所有属性名的集合</td>
</tr>
<tr>
<td>getCookies</td>
<td>获取所有Cookie对象</td>
</tr>
<tr>
<td>getCharacterEncoding</td>
<td>获取请求的字符编码方式</td>
</tr>
<tr>
<td>getContentLength</td>
<td>返回请求正文的长度,如不确定返回-1</td>
</tr>
<tr>
<td>getHeader</td>
<td>获取指定名字报头值</td>
</tr>
<tr>
<td>getHeaders</td>
<td>获取指定名字报头的所有值,一个枚举</td>
</tr>
<tr>
<td>getHeaderNames</td>
<td>获取所有报头的名字,一个枚举</td>
</tr>
<tr>
<td>getInputStream</td>
<td>返回请求输入流,获取请求中的数据</td>
</tr>
<tr>
<td>getMethod</td>
<td>获取客户端向服务器端传送数据的方法</td>
</tr>
<tr>
<td>getParameter</td>
<td>获取指定名字参数值</td>
</tr>
<tr>
<td>getParameterNames</td>
<td>获取所有参数的名字,一个枚举</td>
</tr>
<tr>
<td>getParameterValues</td>
<td>获取指定名字参数的所有值</td>
</tr>
<tr>
<td>getProtocol</td>
<td>获取客户端向服务器端传送数据的协议名称</td>
</tr>
<tr>
<td>getQueryString</td>
<td>获取以get方法向服务器传送的查询字符串</td>
</tr>
<tr>
<td>getRequestURI</td>
<td>获取发出请求字符串的客户端地址</td>
</tr>
<tr>
<td>getRemoteAddr</td>
<td>获取客户端的IP地址</td>
</tr>
<tr>
<td>getRemoteHost</td>
<td>获取客户端的名字</td>
</tr>
<tr>
<td>getSession</td>
<td>获取和请求相关的会话</td>
</tr>
<tr>
<td>getServerName</td>
<td>获取服务器的名字</td>
</tr>
<tr>
<td>getServerPath</td>
<td>获取客户端请求文件的路径</td>
</tr>
<tr>
<td>getServerPort</td>
<td>获取服务器的端口号</td>
</tr>
<tr>
<td>removeAttribute</td>
<td>删除请求中的一个属性</td>
</tr>
<tr>
<td>setAttribute</td>
<td>设置指定名字参数值</td>
</tr>
</tbody>
</table>
<h3 id="session-javaxservlethttphttpsession">session   【javax.servlet.http.HttpSession】</h3>
<p>作用：用来保存每个用户的信息,以便跟踪每个用户的操作状态</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getAttribute</td>
<td>获取指定名字的属性</td>
</tr>
<tr>
<td>getAttributeNames</td>
<td>获取session中全部属性名字,一个枚举</td>
</tr>
<tr>
<td>getCreationTime</td>
<td>返回session的创建时间</td>
</tr>
<tr>
<td>getId</td>
<td>获取会话标识符</td>
</tr>
<tr>
<td>getLastAccessedTime</td>
<td>返回最后发送请求的时间</td>
</tr>
<tr>
<td>getMaxInactiveInterval</td>
<td>返回session对象的生存时间单位千分之一秒</td>
</tr>
<tr>
<td>invalidate</td>
<td>销毁session对象</td>
</tr>
<tr>
<td>isNew</td>
<td>每个请求是否会产生新的session对象</td>
</tr>
<tr>
<td>removeAttribute</td>
<td>删除指定名字的属性</td>
</tr>
<tr>
<td>setAttribute</td>
<td>设定指定名字的属性值</td>
</tr>
</tbody>
</table>
<h3 id="application-javaxservletservletcontext">application  【javax.servlet.ServletContext】</h3>
<p>作用：对应ServletContext对象， 在整个应用的生命周期内共享数据</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getAttribute</td>
<td>获取应用对象中指定名字的属性值</td>
</tr>
<tr>
<td>getAttributeNames</td>
<td>获取应用对象中所有属性的名字,一个枚举</td>
</tr>
<tr>
<td>getInitParameter</td>
<td>返回应用对象中指定名字的初始参数值</td>
</tr>
<tr>
<td>getServletInfo</td>
<td>返回Servlet编译器中当前版本信息</td>
</tr>
<tr>
<td>setAttribute</td>
<td>设置应用对象中指定名字的属性值</td>
</tr>
</tbody>
</table>
<h3 id="out-javaxservletjspjspwriter">out		 【javax.servlet.jsp.JspWriter】</h3>
<p>作用：向客户端输出数据</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>print或println</td>
<td>输出数据</td>
</tr>
<tr>
<td>newLine</td>
<td>输出换行字符</td>
</tr>
<tr>
<td>flush</td>
<td>输出缓冲区数据</td>
</tr>
<tr>
<td>close</td>
<td>关闭输出流</td>
</tr>
<tr>
<td>clear</td>
<td>清除缓冲区中数据,但不输出到客户端</td>
</tr>
<tr>
<td>clearBuffer</td>
<td>清除缓冲区中数据,输出到客户端</td>
</tr>
<tr>
<td>getBufferSize</td>
<td>获得缓冲区大小</td>
</tr>
<tr>
<td>getRemaining</td>
<td>获得缓冲区中没有被占用的空间</td>
</tr>
<tr>
<td>isAutoFlush</td>
<td>是否为自动输出</td>
</tr>
</tbody>
</table>
<h3 id="response-javaxservlethttphttpservletresponse">response  【javax.servlet.http.HttpServletResponse】</h3>
<p>作用：封装了jsp产生的响应,然后被发送到客户端以响应客户的请求</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>addCookie</td>
<td>添加一个Cookie对象</td>
</tr>
<tr>
<td>addHeader</td>
<td>添加Http文件指定名字头信息</td>
</tr>
<tr>
<td>containsHeader</td>
<td>判断指定名字Http文件头信息是否存在</td>
</tr>
<tr>
<td>encodeURL</td>
<td>使用sessionid封装URL</td>
</tr>
<tr>
<td>flushBuffer</td>
<td>强制把当前缓冲区内容发送到客户端</td>
</tr>
<tr>
<td>getBufferSize</td>
<td>返回缓冲区大小</td>
</tr>
<tr>
<td>getOutputStream</td>
<td>返回到客户端的输出流对象</td>
</tr>
<tr>
<td>sendError</td>
<td>向客户端发送错误信息</td>
</tr>
<tr>
<td>sendRedirect</td>
<td>把响应发送到另一个位置进行处理</td>
</tr>
<tr>
<td>setContentType</td>
<td>设置响应的MIME类型</td>
</tr>
<tr>
<td>setHeader</td>
<td>设置指定名字的Http文件头信息</td>
</tr>
</tbody>
</table>
<h3 id="exception-javalangthrowable">exception  【java.lang.Throwable】</h3>
<p>被调用的错误页面的结果,只有在错误页面中才可使用,</p>
<p>即在页面指令中设置:&lt;%@page isErrorPage=“true”%&gt;</p>
<h3 id="page-javalangobject">page	 【java.lang.Object】</h3>
<p>它代表JSP被编译成Servlet,可以使用它来调用Servlet类中所定义的方法</p>
<h3 id="config-javaxservletservletconfig">config 【javax.servlet.ServletConfig】</h3>
<p>作用：表示Servlet的配置,当一个Servlet初始化时,容器把某些信息通过此对象传递给这个Servlet</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getServletContext</td>
<td>返回所执行的Servlet的环境对象</td>
</tr>
<tr>
<td>getServletName</td>
<td>返回所执行的Servlet的名字</td>
</tr>
<tr>
<td>getInitParameter</td>
<td>返回指定名字的初始参数值</td>
</tr>
<tr>
<td>getInitParameterNames</td>
<td>返回该JSP中所有的初始参数名,一个枚举</td>
</tr>
</tbody>
</table>
<h2 id="四个作用域">四个作用域</h2>
<blockquote>
<p>表示这些对象可以存值，他们的取值范围有限定。  setAttribute   和  getAttribute</p>
</blockquote>
<h3 id="使用作用域来存储数据">使用作用域来存储数据</h3>
<pre><code class="language-jsp">&lt;%
pageContext.setAttribute(&quot;name&quot;, &quot;page&quot;);
request.setAttribute(&quot;name&quot;, &quot;request&quot;);
session.setAttribute(&quot;name&quot;, &quot;session&quot;);
application.setAttribute(&quot;name&quot;, &quot;application&quot;);
%&gt;
</code></pre>
<h3 id="取出四个作用域中的值">取出四个作用域中的值</h3>
<pre><code class="language-jsp">&lt;%=pageContext.getAttribute(&quot;name&quot;)%&gt;
&lt;%=request.getAttribute(&quot;name&quot;)%&gt;
&lt;%=session.getAttribute(&quot;name&quot;)%&gt;
&lt;%=application.getAttribute(&quot;name&quot;)%&gt;
</code></pre>
<p>作用域范围大小：</p>
<blockquote>
<p>pageContext -- request --- session -- application</p>
</blockquote>
<h3 id="四个作用域的区别">四个作用域的区别</h3>
<ul>
<li>pageContext 【PageContext】</li>
</ul>
<blockquote>
<p>作用域仅限于当前的页面。</p>
<p>除了可以存储数据， 还可以获取其他8个内置对象</p>
</blockquote>
<ul>
<li>request 【HttpServletRequest】</li>
</ul>
<blockquote>
<p>作用域仅限于一次请求， 只要服务器对该请求做出了响应。 这个域中存的值就没有了。</p>
</blockquote>
<ul>
<li>session 【HttpSession】</li>
</ul>
<blockquote>
<p>作用域限于一次会话（多次请求与响应） 当中。</p>
</blockquote>
<ul>
<li>application 【ServletContext】</li>
</ul>
<blockquote>
<p>整个工程都可以访问， 服务器关闭后就不能访问了。</p>
</blockquote>
<h2 id="el表达式">EL表达式</h2>
<blockquote>
<p>是为了简化咱们的jsp代码，具体一点就是为了简化在jsp里面写的那些java代码。</p>
</blockquote>
<ul>
<li>
<p>语法结构</p>
<p>${expression }</p>
</li>
<li>
<p>从指定的作用域取参数</p>
<p>${requestScope.表达式}</p>
</li>
</ul>
<blockquote>
<p>如果从作用域中取值，会先从小的作用域开始取，如果没有，就往下一个作用域取。  一直把四个作用域取完都没有， 就没有显示。</p>
</blockquote>
<h3 id="如何使用">如何使用</h3>
<ol>
<li>取出4个作用域中存放的值。</li>
</ol>
<pre><code class="language-jsp">&lt;%
pageContext.setAttribute(&quot;name&quot;, &quot;page&quot;);
request.setAttribute(&quot;name&quot;, &quot;request&quot;);
session.setAttribute(&quot;name&quot;, &quot;session&quot;);
application.setAttribute(&quot;name&quot;, &quot;application&quot;);
%&gt;

按普通手段取值&lt;br&gt;

&lt;%= pageContext.getAttribute(&quot;name&quot;)%&gt;
&lt;%= request.getAttribute(&quot;name&quot;)%&gt;
&lt;%= session.getAttribute(&quot;name&quot;)%&gt;
&lt;%= application.getAttribute(&quot;name&quot;)%&gt;

&lt;br&gt;使用EL表达式取出作用域中的值&lt;br&gt;

${ pageScope.name }
${ requestScope.name }
${ sessionScope.name }
${ applicationScope.name }
</code></pre>
<ol start="2">
<li>如果域中所存的是数组</li>
</ol>
<pre><code class="language-jsp">&lt;%
String [] a = {&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;};
pageContext.setAttribute(&quot;array&quot;, a);
%&gt;
      		
使用EL表达式取出作用域中数组的值&lt;br&gt;

${array[0] } , ${array[1] },${array[2] },${array[3] }
</code></pre>
<ol start="3">
<li>如果域中锁存的是集合</li>
</ol>
<pre><code class="language-jsp">&lt;%
List&lt;String&gt; list =  new ArrayList&lt;&gt;();
list.add(&quot;aa&quot;);
list.add(&quot;bb&quot;);
list.add(&quot;cc&quot;);
list.add(&quot;dd&quot;);

pageContext.setAttribute(&quot;li&quot;, list);
%&gt;
使用EL表达式取出作用域中集合的值&lt;br&gt;

${list[0] } , ${li[1] },${li[2] },${li[3] }

</code></pre>
<ol start="4">
<li>取出Map集合的值</li>
</ol>
<pre><code class="language-java">&lt;%
Map map = new HashMap();
map.put(&quot;name&quot;, &quot;zhangsna&quot;);
map.put(&quot;age&quot;,18);
map.put(&quot;address&quot;,&quot;北京..&quot;);

map.put(&quot;address.aa&quot;,&quot;深圳..&quot;);

pageContext.setAttribute(&quot;map&quot;, map);
%&gt;
使用EL表达式取出作用域中Map的值&lt;br&gt;

&lt;!-- map的key中有特殊字符时，我们必须用[]这种方式来获取值 --&gt;
${map.name } , ${map.age } , ${map.address }  , ${map[&quot;address.aa&quot;] }
</code></pre>
<h2 id="el表达式-的11个内置对象">EL表达式 的11个内置对象。</h2>
<p>${ 对象名.成员 }</p>
<ul>
<li>pageContext</li>
</ul>
<p>作用域相关对象</p>
<ul>
<li>pageScope</li>
<li>requestScope</li>
<li>sessionScope</li>
<li>applicationScope</li>
</ul>
<p>头信息相关对象</p>
<ul>
<li>header</li>
<li>headerValues</li>
</ul>
<p>参数信息相关对象</p>
<ul>
<li>
<p>param</p>
</li>
<li>
<p>paramValues</p>
</li>
<li>
<p>cookie</p>
</li>
</ul>
<p>全局初始化参数</p>
<ul>
<li>initParam</li>
</ul>
<h2 id="jstl">JSTL</h2>
<blockquote>
<p>全称 ： JSP Standard Tag Library  jsp标准标签库</p>
</blockquote>
<blockquote>
<p>简化jsp的代码编写。 替换 &lt;%%&gt; 写法。 一般与EL表达式配合</p>
</blockquote>
<h3 id="怎么使用">怎么使用</h3>
<ol>
<li>
<p>导入jar文件到工程的WebContent/Web-Inf/lib  jstl.jar standard.jar</p>
</li>
<li>
<p>在jsp页面上，使用taglib 指令，来引入标签库</p>
</li>
</ol>
<blockquote>
<p>比如引入JSTL核心标签库</p>
</blockquote>
<pre><code class="language-jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
</code></pre>
<ol start="3">
<li>注意： 如果想支持 EL表达式，那么引入的标签库必须选择1.1以上的版本，1.0的版本不支持EL表达式。</li>
</ol>
<h3 id="jstl标签分类">JSTL标签分类</h3>
<h4 id="核心标签最核心-最重用">核心标签(最核心、最重用)</h4>
<pre><code class="language-jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
</code></pre>
<ul>
<li>
<p>表达式控制标签</p>
<ul>
<li>out</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>输出值，如果是常量直接赋值， 如果是变量需要通过EL表达式取值</td>
<td>是</td>
</tr>
<tr>
<td>default</td>
<td>当value为null时， 输出default属性配置的值</td>
<td>否</td>
</tr>
<tr>
<td>escapeXml</td>
<td>是否转义XML特殊字符，取值true/false， 默认是true</td>
<td>否</td>
</tr>
</tbody>
</table>
<ul>
<li>set</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>搭配var属性使用，设置变量的值；搭配property和target使用，设置javabean属性的值</td>
<td>是</td>
</tr>
<tr>
<td>var</td>
<td>定义的变量名称</td>
<td>否</td>
</tr>
<tr>
<td>scope</td>
<td>变量保存到的作用域，默认是pageContext</td>
<td>否</td>
</tr>
<tr>
<td>target</td>
<td>给javabean设置属性，指定那个javabean。需配合&lt;jsp:useBean&gt;标签和property、value属性使用</td>
<td>否</td>
</tr>
<tr>
<td>property</td>
<td>设置javabean的哪个属性的值</td>
<td>否</td>
</tr>
</tbody>
</table>
<ul>
<li>remove</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>var</td>
<td>删除指定的变量，只能删除变量，不能删除javabean的属性</td>
<td>是</td>
</tr>
</tbody>
</table>
<ul>
<li>catch</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>var</td>
<td>存储错误信息</td>
<td>是</td>
</tr>
</tbody>
</table>
<pre><code class="language-jsp">&lt;%-- &lt;c:catch&gt;用于包裹其他容易出错的标签，比如 --%&gt;
&lt;c:catch var=&quot;error&quot;&gt;
  &lt;!-- aa为没有实例化的javabean --&gt;
	&lt;c:set target=&quot;aa&quot; property=&quot;name&quot; value=&quot;zhangsan&quot; /&gt;
&lt;/c:catch&gt;
&lt;c:out value=&quot;${error}&quot; /&gt;
</code></pre>
</li>
<li>
<p>流程控制标签</p>
<ul>
<li>if</li>
</ul>
<pre><code class="language-jsp">&lt;c:if test=&quot;${income &gt; 8000}&quot; var=&quot;ret&quot;&gt;  
  &lt;p&gt;My income is: &lt;c:out value=&quot;${income}&quot;/&gt;&lt;p&gt;  
&lt;/c:if&gt;
&lt;!-- var属性ret存储的是test运算的结果 --&gt;
${ret}
</code></pre>
<ul>
<li>choose&amp;when&amp;otherwise</li>
</ul>
<pre><code class="language-jsp">&lt;c:choose&gt;  
    &lt;c:when test=&quot;${income &lt;= 1000}&quot;&gt;  
       Income is not good.  
    &lt;/c:when&gt;  
    &lt;c:when test=&quot;${income &gt; 10000}&quot;&gt;  
        Income is very good.  
    &lt;/c:when&gt;  
    &lt;c:otherwise&gt;  
       Income is undetermined...  
    &lt;/c:otherwise&gt;  
&lt;/c:choose&gt;  
</code></pre>
<ul>
<li>forEach</li>
</ul>
<pre><code class="language-jsp">&lt;%
 List&lt;String&gt; students = new ArrayList&lt;&gt;();
 students.add(&quot;张三&quot;);
 students.add(&quot;李四&quot;);
 students.add(&quot;王五&quot;);
 students.add(&quot;赵六&quot;);
 
 request.setAttribute(&quot;stus&quot;, students);
%&gt;

&lt;!-- forEach遍历全部元素 --&gt;
&lt;c:forEach var=&quot;stu&quot; items=&quot;${stus}&quot;&gt;
	&lt;c:out value=&quot;${stu}&quot; /&gt; &lt;br /&gt;
&lt;/c:forEach&gt;

&lt;!-- forEach遍历部分元素 --&gt;
&lt;c:forEach var=&quot;stu&quot; items=&quot;${stus}&quot; begin=&quot;1&quot; end=&quot;3&quot;&gt;
	&lt;c:out value=&quot;${stu}&quot; /&gt; &lt;br /&gt;
&lt;/c:forEach&gt;

&lt;!-- forEach遍历部分元素，指定步长 --&gt;
&lt;c:forEach var=&quot;stu&quot; items=&quot;${stus}&quot; begin=&quot;1&quot; step=&quot;2&quot;&gt;
	&lt;c:out value=&quot;${stu}&quot; /&gt; &lt;br /&gt;
&lt;/c:forEach&gt;

&lt;!-- 用法四：部分遍历并带状态 --&gt;
&lt;c:forEach var=&quot;stu&quot; items=&quot;${stus}&quot; begin=&quot;1&quot; end=&quot;3&quot; varStatus=&quot;status&quot;&gt;
&lt;c:out value=&quot;${stu}——四个属性：&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value=&quot;index属性：${status.index}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value=&quot;count属性：${status.count}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value=&quot;first属性：${status.first}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value=&quot;last属性：${status.last}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value=&quot;----------&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;/c:forEach&gt;

&lt;!-- varStatus变量的几个属性：index从0开始；count从1开始；first是否第一个（boolean）；last是否最后一个（boolean）。  --&gt;

</code></pre>
<ul>
<li>forTokens</li>
</ul>
<pre><code class="language-jsp">&lt;c:forTokens items=&quot;zhangsan,lisi,wangwu&quot; delims=&quot;,&quot; var=&quot;item&quot;&gt;
	&lt;c:out value=&quot;${item}&quot; /&gt; &lt;br /&gt;
&lt;/c:forTokens&gt;

&lt;!-- 另外forTokens也支持begin、end、step、varStatus几个属性，用法和forEach一样 --&gt;
</code></pre>
</li>
<li>
<p>URL操作标签</p>
<ul>
<li>url</li>
</ul>
<pre><code class="language-jsp"> &lt;c:url value=&quot;http://localhost:8080/Test/index.jsp&quot; var=&quot;newUrl&quot; scope=&quot;session&quot;&gt;
 		&lt;c:param name=&quot;username&quot;&gt;zhangsan&lt;/c:param&gt;
  		&lt;c:param name=&quot;password&quot;&gt;a123456&lt;/c:param&gt;
 &lt;/c:url&gt;
	&lt;a href=&quot;${newUrl}&quot;&gt;New URL&lt;/a&gt;
</code></pre>
<ul>
<li>redirect</li>
</ul>
<pre><code class="language-jsp">  	&lt;c:redirect url=&quot;www.baidu.com&quot;&gt;
  		&lt;c:param name=&quot;username&quot;&gt;zhangsan&lt;/c:param&gt;
  		&lt;c:param name=&quot;password&quot;&gt;a123456&lt;/c:param&gt;
  	&lt;/c:redirect&gt;
</code></pre>
<ul>
<li>param</li>
</ul>
<p>一般作为其他标签的子标签使用，为其附加参数</p>
</li>
</ul>
<h4 id="格式化标签">格式化标签</h4>
<pre><code class="language-jsp">&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;
</code></pre>
<ul>
<li>格式化时间</li>
</ul>
<pre><code class="language-jsp">&lt;%
	Date date = new Date();
	pageContext.setAttribute(&quot;d&quot;, date);
%&gt;
&lt;fmt:formatDate value=&quot;${d }&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;
</code></pre>
<ul>
<li>格式化数字</li>
</ul>
<pre><code class="language-jsp">&lt;%
	double d1 = 3.5;
	double d2 = 4.4; 
	pageContext.setAttribute(&quot;d1&quot;, d1);
	pageContext.setAttribute(&quot;d2&quot;, d2);
%&gt;
&lt;fmt:formatNumber value=&quot;${d1 }&quot; pattern=&quot;0.00&quot;/&gt;&lt;br/&gt;
&lt;fmt:formatNumber value=&quot;${d2 }&quot; pattern=&quot;#.##&quot;/&gt;
</code></pre>
<h4 id="sql标签">SQL标签</h4>
<pre><code class="language-jsp">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/sql&quot; prefix=&quot;sql&quot;%&gt;  
</code></pre>
<ul>
<li>setDataSource</li>
</ul>
<pre><code class="language-jsp">&lt;sql:setDataSource var=&quot;db&quot; driver=&quot;com.mysql.jdbc.Driver&quot;  
     url=&quot;jdbc:mysql://localhost/test&quot;  
     user=&quot;root&quot;  password=&quot;1234&quot;/&gt;  
</code></pre>
<ul>
<li>query</li>
</ul>
<pre><code class="language-jsp">&lt;sql:query dataSource=&quot;${db}&quot; var=&quot;rs&quot;&gt;  
SELECT * from Students;  
&lt;/sql:query&gt;  
</code></pre>
<ul>
<li>update</li>
</ul>
<pre><code class="language-jsp">&lt;sql:update dataSource=&quot;${db}&quot; var=&quot;count&quot;&gt;  
INSERT INTO Students VALUES (154,'Nasreen', 'jaha', 25);  
&lt;/sql:update&gt;  
</code></pre>
<ul>
<li>param &amp; dateParam</li>
</ul>
<pre><code class="language-jsp">&lt;%
Date DoB = new Date(&quot;2000/10/16&quot;);
int studentId = 151;
%&gt;
&lt;sql:update dataSource=&quot;${db}&quot; var=&quot;count&quot;&gt;
   UPDATE Student SET dob = ? WHERE Id = ?
   &lt;sql:dateParam value=&quot;&lt;%=DoB%&gt;&quot; type=&quot;DATE&quot; /&gt;
   &lt;sql:param value=&quot;&lt;%=studentId%&gt;&quot; /&gt;
&lt;/sql:update&gt;

</code></pre>
<ul>
<li>transaction</li>
</ul>
<pre><code class="language-jsp">&lt;sql:transaction dataSource=&quot;${db}&quot;&gt;  
   &lt;sql:update var=&quot;count&quot;&gt;  
      UPDATE Student SET First_Name = 'Suraj' WHERE Id = 150  
   &lt;/sql:update&gt;  
   &lt;sql:update var=&quot;count&quot;&gt;  
      UPDATE Student SET Last_Name= 'Saifi' WHERE Id = 153  
   &lt;/sql:update&gt;  
   &lt;sql:update var=&quot;count&quot;&gt;  
     INSERT INTO Student   
     VALUES (154,'Supriya', 'Jaiswal', '1995/10/6');  
   &lt;/sql:update&gt;  
&lt;/sql:transaction&gt;  
</code></pre>
<h4 id="xml标签">XML标签</h4>
<p>用的不多，这里不在列举</p>
<p>ps: 更多详细内容，参见：<a href="https://www.javatpoint.com/jstl">https://www.javatpoint.com/jstl</a></p>
<h2 id="总结">总结：</h2>
<ul>
<li>
<p>JSP</p>
<p>三大指令</p>
<pre><code>  	page
  	include
  	taglib
  
  六个动作标签
  	&lt;jsp:include&gt;
  	&lt;jsp:forward&gt;
  	&lt;jsp:param&gt;
</code></pre>
<p>​		jsp:useBean</p>
<p>​		jsp:setProperty</p>
<p>​		jsp:getProperty</p>
<p>九个内置对象</p>
<pre><code>  四个作用域
  	pageContext
  	request
  	session
  	application

  out
  exception
  response
  page
  config
</code></pre>
</li>
</ul>
<p>​</p>
<ul>
<li>
<p>EL</p>
<p>${ 表达式 }</p>
<p>取4个作用域中的值</p>
<p>${ name }</p>
<p>有11个内置对象。</p>
<p>pageContext</p>
<p>pageScope<br>
requestScope<br>
sessionScope<br>
applicationScope</p>
<p>header<br>
headerValues</p>
<p>param<br>
paramValues</p>
<p>cookie<br>
initParam</p>
</li>
<li>
<p>JSTL</p>
</li>
</ul>
<blockquote>
<p>使用1.1的版本， 支持EL表达式， 1.0不支持EL表达式</p>
</blockquote>
<blockquote>
<p>拷贝jar包， 通过taglib 去引入标签库</p>
</blockquote>
<pre><code>&lt;c:set&gt;
&lt;c:if&gt;
&lt;c:forEach&gt;
</code></pre>
<p>​</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据分页]]></title>
        <id>https://ysjhhhhhhh.github.io/post/shu-ju-fen-ye</id>
        <link href="https://ysjhhhhhhh.github.io/post/shu-ju-fen-ye">
        </link>
        <updated>2018-03-25T12:35:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="核心参数">核心参数</h2>
<ul>
<li>总数据条数
<ul>
<li>来源： 后台自己从数据库中查询而来</li>
</ul>
</li>
<li>每页展示条数(pageSize)
<ul>
<li>来源：从前端页面传递过来</li>
</ul>
</li>
<li>总页数（计算得知）
<ul>
<li>来源： 根据总条数和每页展示数量计算得来</li>
</ul>
</li>
<li>当前展示的页码（currentPage)
<ul>
<li>来源：从前端页面传递过来</li>
</ul>
</li>
<li>每页要展示的数据本身
<ul>
<li>来源：后台自己从数据库中查询而来</li>
</ul>
</li>
</ul>
<h2 id="物理分页">物理分页</h2>
<h3 id="概述">概述</h3>
<p>所谓的物理分页其实就是直接通过数据库来实现返回一部分数据。每次只从数据库中查询一页的数据。与之相对应的还有逻辑分页。</p>
<h3 id="mysql中实现语句">Mysql中实现语句</h3>
<pre><code class="language-sql">    SELECT * FROM `shop` LIMIT (currentPage-1)*pageSize, pageSize;
</code></pre>
<h2 id="逻辑分页">逻辑分页</h2>
<p>所谓的逻辑分页其实就是通过内存来进行分页。具体来说，首次查询数据时，将所有数据都取出放到内存中，展示其他页的数据时，在内存中实现数据的截取，展示。</p>
<h2 id="两种分页的对比">两种分页的对比</h2>
<ol>
<li>物理分页节约内存空间，效率相比逻辑分页理论上效率低一些。试用场景：数据量大的时候。</li>
<li>逻辑分页占用空间大，理论上分页性能高一些。试用场景：数据量小，访问用户多。要处理缓存数据同步的问题。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Apache Tomcat下载、安装、配置]]></title>
        <id>https://ysjhhhhhhh.github.io/post/apache-tomcat-xia-zai-an-zhuang-pei-zhi</id>
        <link href="https://ysjhhhhhhh.github.io/post/apache-tomcat-xia-zai-an-zhuang-pei-zhi">
        </link>
        <updated>2018-03-21T02:32:15.000Z</updated>
        <content type="html"><![CDATA[<p>Apache Tomcat下载、安装、配置图文教程自我心得<br>
1、Tomcat下载<br>
（1）Tomcat官网：<a href="http://tomcat.apache.org/">Tomcat官方网址</a>，可以在此处下载Tomcat。<br>
（2）点击左侧Download下的对应版本。<br>
注意有zip和exe两种格式的，zip是免安装版的，exe是安装版。同时观察自己的电脑是64位系统还是32位系统。<br>
例如进入：<a href="http://tomcat.apache.org/download-90.cgi">Tomcat 9 版本下载页面</a>，下滑，到core处选择自己需要的版本，如图所示：<br>
<img src="https://img-blog.csdn.net/20170227190709370?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>我的电脑是64位，可以直接选择32-bit/64-bit Windows Service installer(pgp,md5,sha1)，点击即可选择下载位置，点击下载，此处选择下载的是exe安装版本。若想下载免安装版本的，选择下载64-bit Windows zip(pgp,md5,sha1)。<br>
2、Tomcat安装<br>
2.1 exe版本安装<br>
1、从下载位置双击下载的zip<br>
<img src="https://img-blog.csdn.net/20170227220255334?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>点击next；<br>
2、同意安装协议：即点击I Agree<br>
<img src="https://img-blog.csdn.net/20170227220536666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>3、点开Tomcat，选中Service，以后将可以在管理的服务中启动和关闭Tomcat（也可以默认，不改变配置），点击next<br>
<img src="https://img-blog.csdn.net/20170227220858858?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>4、出现管理提示框，要求输入端口和管理密码，保持默认设置就行。默认的端口号就是8080，这里一般不用设置。点击Next。<br>
<img src="https://img-blog.csdn.net/20170227221248471?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>5、点击Next后会出现下图，它会自动找到JRE位置，如果用户没有安装JRE，可以修改指向JDK目录（很多用户安装后无法编译JSP，就是这里没找到JRE，请务必先要安装JDK，并把这个目录正确指向JRE或者JDK的目录）。<br>
<img src="https://img-blog.csdn.net/20170227221856106?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>6、点击next，之后会出现Tomcat安装路径选择，一般默认安装到C盘，可以直接把C改成D，没有的文件夹会自动创建。修改完毕后点击Install。<br>
<img src="https://img-blog.csdn.net/20170227222133335?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>7、安装完毕，点击finish。<br>
<img src="https://img-blog.csdn.net/20170227222413424?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>8、打开浏览器 键入 <a href="http://localhost:8080/">http://localhost:8080</a> 进入如下页面则表示安装成功：<br>
<img src="https://img-blog.csdn.net/20170227222804476?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>2.2 zip版（免安装版本）<br>
直接解压缩，找到目录bin下的startup.bat，启动Tomcat；shutdown.bat：关闭Tomcat。<br>
3、Tomcat配置<br>
配置Tomcat之前要保证jdk已经配置完成。<br>
右击，计算机——属性——高级系统设置——打开环境变量的配置窗口，在系统环境变量一栏点击新建。变量名为TOMCAT_HOME，变量值为Tomcat安装目录，此处为：D:\Program Files (x86)\Apache Software Foundation\Tomcat 9.0。点击确定即可。<br>
在另外一篇博客中这样介绍Tomcat配置过程：<br>
Tomcat环境变量配置：<br>
如果你的Tomcat安装在C盘里，如：C:\Program Files\Apache Software Foundation\Tomcat 8.0（在这里切记一下，安装Tomcat时，在其字母周围一定不要存在空格，否则最后可能导致配置不成功）<br>
同样，在系统变量里点新建：<br>
变量名：CATALINA_BASE<br>
变量值：C:\Program Files\Apache Software Foundation\Tomcat 8.0;<br>
再次新建：<br>
变量名：CATALINA_HOME<br>
变量值：C:\Program Files\Apache Software Foundation\Tomcat 8.0;<br>
点击确定后在classpath中加入%CATALINA_HOME%\common\lib\servlet-api.jar;（注意加的时候在原变量值后加英文状态下的“；”）<br>
在path中加入%CATALINA_HOME%\bin;（注意加的时候在原变量值后加英文状态下的“；”）<br>
确定后你的Tomcat就配置好了，同样要验证是否配置成功，那就运行Tomcat,点击启动（或Start service）后，打开浏览器，敲入<a href="http://localhost:8080/">http://localhost:8080</a>,如果出现页面，那么配置成功。</p>
]]></content>
    </entry>
</feed>