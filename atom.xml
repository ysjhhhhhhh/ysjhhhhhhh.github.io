<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ysjhhhhhhh.github.io</id>
    <title>Gridea</title>
    <updated>2019-12-12T07:46:04.981Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ysjhhhhhhh.github.io"/>
    <link rel="self" href="https://ysjhhhhhhh.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://ysjhhhhhhh.github.io/images/avatar.png</logo>
    <icon>https://ysjhhhhhhh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Spring框架]]></title>
        <id>https://ysjhhhhhhh.github.io/post/spring-kuang-jia</id>
        <link href="https://ysjhhhhhhh.github.io/post/spring-kuang-jia">
        </link>
        <updated>2018-04-12T07:38:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="spring">Spring</h1>
<ul>
<li>
<p>什么是spring</p>
<blockquote>
<p>Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson开发。</p>
<p>它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架</p>
<p>dao(JdbcTemplate)  service(spring控制事务)   web(springmvc)</p>
<p>Spring的核心是控制反转（IoC）和面向切面（AOP）。</p>
<p>简单来说，Spring是一个分层的JavaSE/EE full-stack 轻量级开源框架。  1）IoC  和DI  2）AOP</p>
<p>一句话描述spring：full-stack 轻量级开源框架</p>
</blockquote>
</li>
<li>
<p>spring核心</p>
<blockquote>
<p>Spring的核心是控制反转IOC和面向切面AOP</p>
</blockquote>
</li>
</ul>
<h2 id="ioc">IOC</h2>
<ul>
<li>
<p>IOC是什么</p>
<blockquote>
<p>**Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。**在Java开发中，<strong>Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</strong></p>
</blockquote>
</li>
<li>
<p>spring IOC容器初始化方式</p>
<pre><code class="language-java">//xml初始化
ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;classpath:/ioc.xml&quot;);

//注解类初始化
ApplicationContext acc = new AnnotationConfigApplicationContext(ApplicationContextTest.class);
</code></pre>
</li>
<li>
<p>通过xml方式配置容器</p>
<blockquote>
<p>bean标签代指容器中的一个对象</p>
<p>property标签使用在bean标签之中为bean对象属性赋值</p>
</blockquote>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;


    &lt;bean id=&quot;stu01&quot; class=&quot;com.lanou.bean.Student&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;28&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;stu02&quot; class=&quot;com.lanou.bean.Student&quot;&gt;
        &lt;constructor-arg value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg value=&quot;28&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;

    &lt;context:property-placeholder location=&quot;classpath:jdbcConfig.properties&quot;/&gt;

    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.jdbcUrl}&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;plane&quot; class=&quot;com.lanou.bean.plane&quot; autowire=&quot;constructor&quot;&gt;
        &lt;property name=&quot;hight&quot; value=&quot;#{3*12}&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;teacher&quot; class=&quot;com.lanou.bean.Teacher&quot; p:name=&quot;#{T(java.util.UUID).randomUUID().toString()}&quot; p:age=&quot;20&quot; p:sex=&quot;女&quot;&gt;&lt;/bean&gt;
&lt;!--    &lt;bean id=&quot;teacher2&quot; class=&quot;com.lanou.bean.Teacher&quot; p:name=&quot;李老师&quot; p:age=&quot;20&quot; p:sex=&quot;男&quot;&gt;&lt;/bean&gt;--&gt;

    &lt;bean id=&quot;banji&quot; class=&quot;com.lanou.bean.BanJi&quot; autowire=&quot;constructor&quot;&gt;
&lt;!--        &lt;property name=&quot;teacher&quot; value=&quot;#{teacher2}&quot;&gt;&lt;/property&gt;--&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;dog1&quot; class=&quot;com.lanou.bean.Dog&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;红狗&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;2&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;com.lanou.bean.Man&quot;&gt;

    &lt;/bean&gt;

    &lt;!-- 扫描通过注解配置的容器bean --&gt;
    &lt;context:component-scan base-package=&quot;com.lanou&quot;&gt;&lt;/context:component-scan&gt;
&lt;/beans&gt;
</code></pre>
<p>bean初始化方法：</p>
<p>1.普通方式</p>
<pre><code class="language-xml">&lt;bean class=&quot;com.lanou.bean.Man&quot;&gt;
</code></pre>
<p>2.静态工厂方式</p>
<pre><code class="language-xml">&lt;!-- 
	class：指定的是静态工厂类 factory-method: 指定的是工厂中的静态方法 
--&gt;
&lt;bean id=&quot;getMan&quot; class=&quot;com.test.ManFactory&quot; factory-method=&quot;getMan&quot; /&gt;
</code></pre>
<p>3.实例工厂方式</p>
<pre><code class="language-xml">&lt;!-- 工厂实例bean --&gt;
&lt;bean id=&quot;manFactory&quot; class=&quot;com.lanou.ManFactory&quot;&gt;&lt;/bean&gt;

&lt;bean id=&quot;getMan&quot; factory-bean=&quot;manFactory&quot; factory-method=&quot;getMan&quot;&gt;&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>通过注解的方式配置容器</p>
<pre><code class="language-java">package com.lanou3g;

import com.lanou3g.bean.Man;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.*;

import javax.annotation.Resource;

@Configuration //通过这个注解指定此类为IOC容器配置类
@ComponentScan(&quot;com.lanou3g&quot;)//次注解是指定容器初始化时扫描那些包下
@ImportResource({&quot;ioc.xml&quot;})//此注解表示在此配置类初始化时包含其他配置文件中的配置
@PropertySource(&quot;classpath:/manproperties.properties&quot;)//此注解表示在初始化容器时读取某properties文件中的配置信息
public class ApplicationContextTest {

    //此注解为属性赋值
    @Value(&quot;${name}&quot;)
    private String name;

    @Value(&quot;${age}&quot;)
    private Integer age;

    //此注解向容器中配置bean
    @Bean(&quot;man123&quot;)
    public Man aaa(){
        Man man = new Man();
        man.setName(&quot;哈哈&quot;);
        man.setAge(1);
        return man;
    }

    @Bean(&quot;manTest&quot;)
    public Man bbb(){
        Man man = new Man();
        man.setName(name);
        man.setAge(age);
        return man;
    }

}
</code></pre>
</li>
<li>
<p>bean的命名</p>
<blockquote>
<p>id是唯一标识，每个bean只能有一个id，且不同bean之间id也不能重复</p>
<p>name也是bean的标识，每个bean可以拥有多个name。name属性已久不能重复</p>
</blockquote>
</li>
<li>
<p>bean的作用域</p>
<blockquote>
<p>prototype:此属性表示此bean为多例，因此对象不会在容器初始化时创建</p>
<p>singleton(默认):单例bean会在容器初始化时创建bean对象</p>
</blockquote>
</li>
</ul>
<p>多例图解：</p>
<figure data-type="image" tabindex="1"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/prototype.png" alt=""></figure>
<p>单例图解：</p>
<figure data-type="image" tabindex="2"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/singleton.png" alt=""></figure>
<ul>
<li>
<p>bean懒加载：</p>
<p>lazy-init属性 默认是false</p>
<p>（懒加载主要是针对单例，可以让单例在容器初始化时不进行加载。在使用此bean是才去加载）</p>
</li>
</ul>
<h2 id="di">DI</h2>
<ul>
<li>
<p>DI-依赖注入</p>
<blockquote>
<p>创建对象的过程中Spring可以依据配置对对象的属性 进行设置，这个过程称之为依赖注入，即DI</p>
</blockquote>
</li>
<li>
<p>set方法注入</p>
<blockquote>
<p>通常javabean的属性都会私有化，而对外暴露setXx()getXx()方法，此时spring可以通过这样的setXx()方法将属性的值注入对象。</p>
<p>1)spring内置的可直接注入类型的注入</p>
<p>在<bean>标签下添加<property name="set方法名中set之后的单词(首字母小写)" value="要设置的属性的值"></p>
<p>2)非spring内置(即另外的实体类，比如定义一个Person类中有猫和狗两个属性，而猫和狗分别是两个实体类Cat和Dog的对象)的可以直接注入类型的注入</p>
<p>需要添加对应类的<bean>标签，在原始类中添加<property name="自定义名称(一般与类中的属性名称一致)" ref="非spring内置类配置的id值"></p>
</blockquote>
</li>
<li>
<p>基于构造方法的注入</p>
<blockquote>
<p>在<bean>标签下添加&lt;constructor-arg index=&quot;构造方法的第几个参数，下标从0开始&quot; name=&quot;为构造方法的哪个名字的参数ref:该构造方法参数的值,用来指定引用其他bean的值&gt;<br>
ps：index和name可以配置任何一个或同时配置，但要求一旦配置必须正确，推荐优先使用index方式配置，防止没有源码造成name无法匹配到对应的参数</p>
</blockquote>
</li>
<li>
<p>自动装配</p>
<blockquote>
<p>在Spring的set方式实现的注入过程中，支持自动装配机制。所谓自动装配机制，会根据要设置的javabean属性的名字或类型，到spring中自动寻找对应id或类型的<bean>进行设置，从而省去依次配置的过程，简化了配置。</p>
<p>自动装配的两种方式</p>
<p>1)为指定<bean>开启自动装配</p>
<p>在<bean>标签中添加autowire属性：<br>
byName：根据javabean（javabean简单的讲就是实体类，用来封装对象，这个类里面全部都是属性值和get、set方法）中需要注入的属性的名字，在spring容器中找对应id的<bean>，将该<bean>的对象赋值给当前的属性<br>
byType：根据javabean中需要注入的属性的类型，在Spring容器中找对应class类型的<bean>将该<bean>的对象赋值给当前的属性<br>
byType方式根据类型进行匹配，可能匹配到多个<bean>，此时会抛出异常，而byName是通过id来寻找<bean>，id没有重复，不会有这方面的问题，所以推荐使用byName方式<br>
总结：自动装配机制简化了set方法注入中的非Spring内置的可以直接注入类型的注入</p>
<p>2)为全局配置自动装配</p>
<p>在<beans>标签中添加default-autowire属性：<br>
byName与byType和第一点相同</p>
</blockquote>
</li>
</ul>
<h2 id="aop">AOP</h2>
<ul>
<li>
<p>什么是AOP</p>
<blockquote>
<p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方<br>
式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个<br>
热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑<br>
的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高<br>
了开发的效率。</p>
</blockquote>
</li>
<li>
<p>aop术语</p>
<blockquote>
<p>切面（Aspect）</p>
<p>简单来说，切面就是我们要往目标代码中插入进去的代码。</p>
<p>连接点（Join Pointer）</p>
<p>理论上所有可能会被切入的地方都可以称之为连接点</p>
<p>切入点(Pointcut)</p>
<p>选择某个连接点切入，将切面代码织入进去。这个连接点就叫做切入点。</p>
<p>织入(Weaving)</p>
<p>把切面代码糅合到目标代码中的过程就是织入。</p>
<p>通知(Advice)</p>
<p>通知决定了切面代码织入到目标代码中后，运行的时机(比如是在目标方法执行前，还是执行后)。</p>
</blockquote>
</li>
<li>
<p>在spring中使用aop</p>
<p>定义被切的类和方法</p>
<pre><code class="language-java">package com.lanou3g.bean;

import com.lanou3g.Calculator;
import org.springframework.stereotype.Component;

public class MyCalculator implements Calculator {
    @Override
    public int add(int a, int b) {
        return a+b;
    }

    @Override
    public int sub(int a, int b) {
        return a-b;
    }

    @Override
    public int mul(int a, int b) {
        return a*b;
    }

    @Override
    public int div(int a, int b) {
        return a/b;
    }
}

</code></pre>
<p>定义切面类</p>
<pre><code class="language-java">package com.lanou3g.log;


import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

import java.util.Arrays;

public class CalculatorLog {

//    public static void cutclass(){}

    public static void logStart(JoinPoint joinPoint){
        String methodname = joinPoint.getSignature().getName();
        System.out.println(methodname+&quot;方法前置切面方法启动，参数为:&quot;+ Arrays.asList(joinPoint.getArgs()));
    }



    public static void logThrowing(JoinPoint joinPoint,Exception e){
        String methodname = joinPoint.getSignature().getName();
        System.out.println(methodname+&quot;方法异常切面方法启动，错误信息为:&quot;+ e.getMessage());
    }

    public static void logEnd(JoinPoint joinPoint){
        String methodname = joinPoint.getSignature().getName();
        System.out.println(methodname+&quot;方法最终切面方法启动&quot;);
    }

    public static Object logAround(ProceedingJoinPoint pjp) throws Throwable {
        String methodname = pjp.getSignature().getName();
        Object[] args = pjp.getArgs();
        Object res = null;

        try {
            System.out.println(methodname+&quot;方法[环绕]前置切面方法启动，参数为:&quot;+ Arrays.asList(args));
            res = pjp.proceed(args);
            System.out.println(methodname+&quot;方法[环绕]返回切面方法启动，结果为:&quot;+ res);

        }catch (Exception e){
            System.out.println(methodname+&quot;方法[环绕]异常切面方法启动，异常信息为:&quot;+ e.getMessage());
        }finally {
            System.out.println(methodname+&quot;方法[环绕]最终切面方法启动&quot;);
        }

        return res;
    }
    public static void logReturning(JoinPoint joinPoint,Object res){
        String methodname = joinPoint.getSignature().getName();
        System.out.println(methodname+&quot;方法返回切面方法启动，结果为:&quot;+ res);
    }

}
</code></pre>
<blockquote>
<p>在xml文件中配置aop</p>
</blockquote>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;



    &lt;bean id=&quot;man&quot; class=&quot;com.lanou3g.bean.Man&quot; lazy-init=&quot;true&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;28&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;hobbys&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;王者&quot; value=&quot;最强王者&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;aop:aspectj-autoproxy  expose-proxy=&quot;true&quot;    proxy-target-class=&quot;true&quot;/&gt;

    &lt;bean id=&quot;myc&quot; class=&quot;com.lanou3g.bean.MyCalculator&quot; /&gt;

    &lt;bean id=&quot;callog&quot; class=&quot;com.lanou3g.log.CalculatorLog&quot; /&gt;

    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;mycutpoint&quot; expression=&quot;execution(* com.lanou3g.bean.MyCalculator.*(int,int))&quot;/&gt;

        &lt;aop:aspect ref=&quot;callog&quot;&gt;
            &lt;aop:before method=&quot;logStart&quot; pointcut-ref=&quot;mycutpoint&quot; /&gt;
            &lt;aop:after-returning method=&quot;logReturning&quot; pointcut-ref=&quot;mycutpoint&quot; returning=&quot;res&quot;/&gt;
            &lt;aop:after-throwing method=&quot;logThrowing&quot; pointcut-ref=&quot;mycutpoint&quot; throwing=&quot;e&quot;/&gt;
            &lt;aop:after method=&quot;logEnd&quot; pointcut-ref=&quot;mycutpoint&quot; /&gt;
            &lt;aop:around method=&quot;logAround&quot; pointcut-ref=&quot;mycutpoint&quot; /&gt;
        &lt;/aop:aspect&gt;

    &lt;/aop:config&gt;

    &lt;context:component-scan base-package=&quot;com.lanou3g&quot; resource-pattern=&quot;com.lanou3g.log.*&quot;/&gt;
   
&lt;/beans&gt;
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux常用命令大全]]></title>
        <id>https://ysjhhhhhhh.github.io/post/linux-chang-yong-ming-ling-da-quan</id>
        <link href="https://ysjhhhhhhh.github.io/post/linux-chang-yong-ming-ling-da-quan">
        </link>
        <updated>2018-04-06T02:28:57.000Z</updated>
        <content type="html"><![CDATA[<p>最近都在和Linux打交道，这方面基础比较薄弱的我只好买了本鸟哥的书看看，感觉还不错。我觉得Linux相比windows比较麻烦的就是很多东西都要用命令来控制，当然，这也是很多人喜欢linux的原因，比较短小但却功能强大。为了方便大家查找linux的相关命令，我就将我了解到的命令列举一下，仅供大家参考：</p>
<h2 id="系统信息">系统信息</h2>
<p>arch 显示机器的处理器架构(1)<br>
uname -m 显示机器的处理器架构(2)<br>
uname -r 显示正在使用的内核版本<br>
dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>
hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>
hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>
cat /proc/cpuinfo 显示CPU info的信息<br>
cat /proc/interrupts 显示中断<br>
cat /proc/meminfo 校验内存使用<br>
cat /proc/swaps 显示哪些swap被使用<br>
cat /proc/version 显示内核的版本<br>
cat /proc/net/dev 显示网络适配器及统计<br>
cat /proc/mounts 显示已加载的文件系统<br>
lspci -tv 罗列 PCI 设备<br>
lsusb -tv 显示 USB 设备<br>
date 显示系统日期<br>
cal 2007 显示2007年的日历表<br>
date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>
clock -w 将时间修改保存到 BIOS</p>
<h2 id="关机-系统的关机-重启以及登出">关机 (系统的关机、重启以及登出 )</h2>
<p>shutdown -h now 关闭系统(1)<br>
init 0 关闭系统(2)<br>
telinit 0 关闭系统(3)<br>
shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>
shutdown -c 取消按预定时间关闭系统<br>
shutdown -r now 重启(1)<br>
reboot 重启(2)<br>
logout 注销</p>
<h2 id="文件和目录">文件和目录</h2>
<p>cd /home 进入 '/ home' 目录'<br>
cd .. 返回上一级目录<br>
cd ../.. 返回上两级目录<br>
cd 进入个人的主目录<br>
cd ~user1 进入个人的主目录<br>
cd - 返回上次所在的目录<br>
pwd 显示工作路径<br>
ls 查看目录中的文件<br>
ls -F 查看目录中的文件<br>
ls -l 显示文件和目录的详细资料<br>
ls -a 显示隐藏文件<br>
ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>
tree 显示文件和目录由根目录开始的树形结构(1)<br>
lstree 显示文件和目录由根目录开始的树形结构(2)<br>
mkdir dir1 创建一个叫做 'dir1' 的目录'<br>
mkdir dir1 dir2 同时创建两个目录<br>
mkdir -p /tmp/dir1/dir2 创建一个目录树<br>
rm -f file1 删除一个叫做 'file1' 的文件'<br>
rmdir dir1 删除一个叫做 'dir1' 的目录'<br>
rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容<br>
rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>
mv dir1 new_dir 重命名/移动 一个目录<br>
cp file1 file2 复制一个文件<br>
cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>
cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>
cp -a dir1 dir2 复制一个目录<br>
ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>
ln file1 lnk1 创建一个指向文件或目录的物理链接<br>
touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>
file file1 outputs the mime type of the file as text<br>
iconv -l 列出已知的编码<br>
iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>
find . -maxdepth 1 -name *.jpg -print -exec convert &quot;{}&quot; -resize 80x60 &quot;thumbs/{}&quot; ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)</p>
<h2 id="文件搜索">文件搜索</h2>
<p>find / -name file1 从 '/' 开始进入根文件系统搜索文件和目录<br>
find / -user user1 搜索属于用户 'user1' 的文件和目录<br>
find /home/user1 -name *.bin 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件<br>
find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>
find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>
find / -name *.rpm -exec chmod 755 '{}' ; 搜索以 '.rpm' 结尾的文件并定义其权限<br>
find / -xdev -name *.rpm 搜索以 '.rpm' 结尾的文件，忽略光驱、捷盘等可移动设备<br>
locate *.ps 寻找以 '.ps' 结尾的文件 - 先运行 'updatedb' 命令<br>
whereis halt 显示一个二进制文件、源码或man的位置<br>
which halt 显示一个二进制文件或可执行文件的完整路径</p>
<h2 id="挂载一个文件系统">挂载一个文件系统</h2>
<p>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 '/ mnt/hda2' 已经存在<br>
umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 '/ mnt/hda2' 退出<br>
fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>
umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>
mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>
mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>
mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>
mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>
mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>
mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>
mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>
mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享</p>
<h2 id="磁盘空间">磁盘空间</h2>
<p>df -h 显示已经挂载的分区列表<br>
ls -lSr |more 以尺寸大小排列文件和目录<br>
du -sh dir1 估算目录 'dir1' 已经使用的磁盘空间'<br>
du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>
rpm -q -a --qf '%10{SIZE}t%{NAME}n' | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>
dpkg-query -W -f='<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>I</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>d</mi><mo>−</mo><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo separator="true">;</mo><mn>10</mn></mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">{Installed-Size;10}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span></span><span class="mord mathdefault">t</span></span></span></span>{Package}n' | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)</p>
<h2 id="用户和群组">用户和群组</h2>
<p>groupadd group_name 创建一个新用户组<br>
groupdel group_name 删除一个用户组<br>
groupmod -n new_group_name old_group_name 重命名一个用户组<br>
useradd -c &quot;Name Surname &quot; -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 &quot;admin&quot; 用户组的用户<br>
useradd user1 创建一个新用户<br>
userdel -r user1 删除一个用户 ( '-r' 排除主目录)<br>
usermod -c &quot;User FTP&quot; -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>
passwd 修改口令<br>
passwd user1 修改一个用户的口令 (只允许root执行)<br>
chage -E 2005-12-31 user1 设置用户口令的失效期限<br>
pwck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的用户<br>
grpck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的群组<br>
newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组</p>
<h2 id="文件的权限-使用-设置权限使用-用于取消">文件的权限 - 使用 &quot;+&quot; 设置权限，使用 &quot;-&quot; 用于取消</h2>
<p>ls -lh 显示权限<br>
ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>
chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>
chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>
chown user1 file1 改变一个文件的所有人属性<br>
chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>
chgrp group1 file1 改变文件的群组<br>
chown user1:group1 file1 改变一个文件的所有人和群组属性<br>
find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>
chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>
chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>
chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>
chmod g-s /home/public 禁用一个目录的 SGID 位<br>
chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>
chmod o-t /home/public 禁用一个目录的 STIKY 位</p>
<h2 id="文件的特殊属性-使用-设置权限使用-用于取消">文件的特殊属性 - 使用 &quot;+&quot; 设置权限，使用 &quot;-&quot; 用于取消</h2>
<p>chattr +a file1 只允许以追加方式读写文件<br>
chattr +c file1 允许这个文件能被内核自动压缩/解压<br>
chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>
chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>
chattr +s file1 允许一个文件被安全地删除<br>
chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>
chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>
lsattr 显示特殊的属性</p>
<h2 id="打包和压缩文件">打包和压缩文件</h2>
<p>bunzip2 file1.bz2 解压一个叫做 'file1.bz2'的文件<br>
bzip2 file1 压缩一个叫做 'file1' 的文件<br>
gunzip file1.gz 解压一个叫做 'file1.gz'的文件<br>
gzip file1 压缩一个叫做 'file1'的文件<br>
gzip -9 file1 最大程度压缩<br>
rar a file1.rar test_file 创建一个叫做 'file1.rar' 的包<br>
rar a file1.rar file1 file2 dir1 同时压缩 'file1', 'file2' 以及目录 'dir1'<br>
rar x file1.rar 解压rar包<br>
unrar x file1.rar 解压rar包<br>
tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>
tar -cvf archive.tar file1 file2 dir1 创建一个包含了 'file1', 'file2' 以及 'dir1'的档案文件<br>
tar -tf archive.tar 显示一个包中的内容<br>
tar -xvf archive.tar 释放一个包<br>
tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>
tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>
tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包<br>
tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>
tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包<br>
zip file1.zip file1 创建一个zip格式的压缩包<br>
zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>
unzip file1.zip 解压一个zip格式压缩包</p>
<h2 id="rpm-包-fedora-redhat及类似系统">RPM 包 - （Fedora, Redhat及类似系统）</h2>
<p>rpm -ivh package.rpm 安装一个rpm包<br>
rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>
rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>
rpm -F package.rpm 更新一个确定已经安装的rpm包<br>
rpm -e package_name.rpm 删除一个rpm包<br>
rpm -qa 显示系统中所有已经安装的rpm包<br>
rpm -qa | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的rpm包<br>
rpm -qi package_name 获取一个已安装包的特殊信息<br>
rpm -qg &quot;System Environment/Daemons&quot; 显示一个组件的rpm包<br>
rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>
rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>
rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表<br>
rpm -q package_name --whatprovides 显示一个rpm包所占的体积<br>
rpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l<br>
rpm -q package_name --changelog 显示一个rpm包的修改历史<br>
rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>
rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>
rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>
rpm --checksig package.rpm 确认一个rpm包的完整性<br>
rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>
rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>
rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>
rpm -Vp package.rpm 确认一个rpm包还未安装<br>
rpm2cpio package.rpm | cpio --extract --make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>
rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>
rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包</p>
<h2 id="yum-软件包升级器-fedora-redhat及类似系统">YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h2>
<p>yum install package_name 下载并安装一个rpm包<br>
yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>
yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>
yum update package_name 更新一个rpm包<br>
yum remove package_name 删除一个rpm包<br>
yum list 列出当前系统中安装的所有包<br>
yum search package_name 在rpm仓库中搜寻软件包<br>
yum clean packages 清理rpm缓存删除下载的包<br>
yum clean headers 删除所有头文件<br>
yum clean all 删除所有缓存的包和头文件</p>
<h2 id="deb-包-debian-ubuntu-以及类似系统">DEB 包 (Debian, Ubuntu 以及类似系统)</h2>
<p>dpkg -i package.deb 安装/更新一个 deb 包<br>
dpkg -r package_name 从系统删除一个 deb 包<br>
dpkg -l 显示系统中所有已经安装的 deb 包<br>
dpkg -l | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的deb包<br>
dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>
dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>
dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表<br>
dpkg -S /bin/ping 确认所给的文件由哪个deb包提供</p>
<h2 id="apt-软件工具-debian-ubuntu-以及类似系统">APT 软件工具 (Debian, Ubuntu 以及类似系统)</h2>
<p>apt-get install package_name 安装/更新一个 deb 包<br>
apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>
apt-get update 升级列表中的软件包<br>
apt-get upgrade 升级所有已安装的软件<br>
apt-get remove package_name 从系统删除一个deb包<br>
apt-get check 确认依赖的软件仓库正确<br>
apt-get clean 从下载的软件包中清理缓存<br>
apt-cache search searched-package 返回包含所要搜索字符串的软件包名称</p>
<h2 id="查看文件内容">查看文件内容</h2>
<p>cat file1 从第一个字节开始正向查看文件的内容<br>
tac file1 从最后一行开始反向查看一个文件的内容<br>
more file1 查看一个长文件的内容<br>
less file1 类似于 'more' 命令，但是它允许在文件中和正向操作一样的反向操作<br>
head -2 file1 查看一个文件的前两行<br>
tail -2 file1 查看一个文件的最后两行<br>
tail -f /var/log/messages 实时查看被添加到一个文件中的内容</p>
<h2 id="文本处理">文本处理</h2>
<p>cat file1 file2 ... | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>
cat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>
cat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>
grep Aug /var/log/messages 在文件 '/var/log/messages'中查找关键词&quot;Aug&quot;<br>
grep ^Aug /var/log/messages 在文件 '/var/log/messages'中查找以&quot;Aug&quot;开始的词汇<br>
grep [0-9] /var/log/messages 选择 '/var/log/messages' 文件中所有包含数字的行<br>
grep Aug -R /var/log/* 在目录 '/var/log' 及随后的目录中搜索字符串&quot;Aug&quot;<br>
sed 's/stringa1/stringa2/g' example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot;<br>
sed '/^<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 49: …所有空白行 
sed &#039;/ *#̲/d; /^'>/d&#039; example.txt 从example.txt文件中删除所有空白行 
sed &#039;/ *#/d; /^</span>/d' example.txt 从example.txt文件中删除所有注释和空白行<br>
echo 'esempio' | tr '[:lower:]' '[:upper:]' 合并上下单元格内容<br>
sed -e '1d' result.txt 从文件example.txt 中排除第一行<br>
sed -n '/stringa1/p' 查看只包含词汇 &quot;string1&quot;的行<br>
sed -e 's/ <em>$//' example.txt 删除每一行最后的空白字符<br>
sed -e 's/stringa1//g' example.txt 从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部<br>
sed -n '1,5p;5q' example.txt 查看从第一行到第5行内容<br>
sed -n '5p;5q' example.txt 查看第5行<br>
sed -e 's/00</em>/0/g' example.txt 用单个零替换多个零<br>
cat -n file1 标示文件的行数<br>
cat example.txt | awk 'NR%2==1' 删除example.txt文件中的所有偶数行<br>
echo a b c | awk '{print $1}' 查看一行第一栏<br>
echo a b c | awk '{print $1,$3}' 查看一行的第一和第三栏<br>
paste file1 file2 合并两个文件或两栏的内容<br>
paste -d '+' file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分<br>
sort file1 file2 排序两个文件的内容<br>
sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>
sort file1 file2 | uniq -u 删除交集，留下其他的行<br>
sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>
comm -1 file1 file2 比较两个文件的内容只删除 'file1' 所包含的内容<br>
comm -2 file1 file2 比较两个文件的内容只删除 'file2' 所包含的内容<br>
comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分</p>
<h2 id="字符设置和文件格式转换">字符设置和文件格式转换</h2>
<p>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>
unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>
recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>
recode -l | more 显示所有允许的转换格式</p>
<h2 id="文件系统分析">文件系统分析</h2>
<p>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块<br>
fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性<br>
fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>
e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>
e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>
fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>
fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性<br>
fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性<br>
dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性</p>
<h2 id="初始化一个文件系统">初始化一个文件系统</h2>
<p>mkfs /dev/hda1 在hda1分区创建一个文件系统<br>
mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统<br>
mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>
mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统<br>
fdformat -n /dev/fd0 格式化一个软盘<br>
mkswap /dev/hda3 创建一个swap文件系统</p>
<h2 id="swap文件系统">SWAP文件系统</h2>
<p>mkswap /dev/hda3 创建一个swap文件系统<br>
swapon /dev/hda3 启用一个新的swap文件系统<br>
swapon /dev/hda2 /dev/hdb3 启用两个swap分区</p>
<h2 id="备份">备份</h2>
<p>dump -0aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的完整备份<br>
dump -1aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的交互式备份<br>
restore -if /tmp/home0.bak 还原一个交互式备份<br>
rsync -rogpav --delete /home /tmp 同步两边的目录<br>
rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync<br>
rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录<br>
rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录<br>
dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of=hda.gz' 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>
dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件<br>
tar -Puf backup.tar /home/user 执行一次对 '/home/user' 目录的交互式备份操作<br>
( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr 'cd /home/share/ &amp;&amp; tar x -p' 通过ssh在远程目录中复制一个目录内容<br>
( tar c /home ) | ssh -C user@ip_addr 'cd /home/backup-home &amp;&amp; tar x -p' 通过ssh在远程目录中复制一个本地目录<br>
tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>
find /home/user1 -name '<em>.txt' | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 '.txt' 结尾的文件到另一个目录<br>
find /var/log -name '</em>.log' | tar cv --files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 '.log' 结尾的文件并做成一个bzip包<br>
dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>
dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容</p>
<h2 id="光盘">光盘</h2>
<p>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容<br>
mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>
mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>
mkisofs -J -allow-leading-dots -R -V &quot;Label CD&quot; -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件<br>
cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件<br>
gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件<br>
mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件<br>
cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>
cd-paranoia -- &quot;-3&quot; 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>
cdrecord --scanbus 扫描总线以识别scsi通道<br>
dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD</p>
<h2 id="网络-以太网和wifi无线">网络 - （以太网和WIFI无线）</h2>
<p>ifconfig eth0 显示一个以太网卡的配置<br>
ifup eth0 启用一个 'eth0' 网络设备<br>
ifdown eth0 禁用一个 'eth0' 网络设备<br>
ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>
ifconfig eth0 promisc 设置 'eth0' 成混杂模式以嗅探数据包 (sniffing)<br>
dhclient eth0 以dhcp模式启用 'eth0'<br>
route -n show routing table<br>
route add -net 0/0 gw IP_Gateway configura default gateway<br>
route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network '192.168.0.0/16'<br>
route del 0/0 gw IP_gateway remove static route<br>
echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward activate ip routing<br>
hostname show hostname of system<br>
host www.example.com lookup hostname to resolve name to ip address and viceversa(1)<br>
nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2)<br>
ip link show show link status of all interfaces<br>
mii-tool eth0 show link status of 'eth0'<br>
ethtool eth0 show statistics of network card 'eth0'<br>
netstat -tup show all active network connections and their PID<br>
netstat -tupl show all network services listening on the system and their PID<br>
tcpdump tcp port 80 show all HTTP traffic<br>
iwlist scan show wireless networks<br>
iwconfig eth1 show configuration of a wireless network card<br>
hostname show hostname<br>
host www.example.com lookup hostname to resolve name to ip address and viceversa<br>
nslookup www.example.com lookup hostname to resolve name to ip address and viceversa<br>
whois www.example.com lookup on Whois database</p>
<h2 id="go-top-index">GO TOP INDEX ^</h2>
<p>Microsoft Windows networks (SAMBA)<br>
nbtscan ip_addr netbios name resolution<br>
nmblookup -A ip_addr netbios name resolution<br>
smbclient -L ip_addr/hostname show remote shares of a windows host<br>
smbget -Rr smb://ip_addr/share like wget can download files from a host windows via smb<br>
mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share mount a windows network share</p>
<p>转发自：<a href="http://www.cnblogs.com/fnlingnzb-learner/p/5831284.html">原博客</a> 谢谢。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jdbc]]></title>
        <id>https://ysjhhhhhhh.github.io/post/jdbc</id>
        <link href="https://ysjhhhhhhh.github.io/post/jdbc">
        </link>
        <updated>2018-04-05T13:38:39.000Z</updated>
        <content type="html"><![CDATA[<p>一. JDBC编程概述</p>
<ol>
<li>
<p>什么JDBC<br>
  JDBC（Java Database Connection）：为多种关系数据库提供统一访问。它由一组用Java语言编写的类和接口组成。是Java访问数据库的标准和规范。</p>
</li>
<li>
<p>常见数据库介绍<br>
  Mysql：开源免费的数据库，小型的数据库。非常实用和受欢迎。已经被Oracle收购了.MySQL6.x版本也开始收费。<br>
  Oracle：收费的大型数据库，Oracle公司的产品。一般中大型公司会使用。Oracle收购了SUN公司，Mysql数据库。<br>
  DB2：IBM公司的收费数据库产品。常应用在银行系统和金融系统中.<br>
  SQLServer：MicroSoft 公司收费的中型的数据库。常常在C#、.net等语言中使用。<br>
  SyBase：提供了一个非常专业数据建模的工具PowerDesigner，但是数据库本身已经淡出历史舞台。<br>
  SQLite: 嵌入式的小型数据库，基本上用于移动端。<br>
  Java相关的数据库：MYSQL，Oracle。<br>
  数据库的设计和开发，sql语句的编写在这里不做详细的介绍。</p>
</li>
</ol>
<p>oracle.jpg<br>
3. JDBC开发原理<br>
  Java和数据库之间没有必然的联系，两者之间是如何连接的呢？虽然Java提供了各种数据库接口，但是我们并不知道各种数据库具体的实现原理，难以对接口进行具体的实现。<br>
  所以，数据库生产商提供了这些接口的实现类：驱动<br>
  Java提供访问数据库规范称为JDBC，而生产厂商提供规范的实现类称为驱动。</p>
<p>JDBC原理图.png</p>
<p>JDBC是接口，驱动是接口的实现，没有驱动将无法完成数据库连接，从而不能操作数据库。每个数据库厂商都需要提供自己的驱动，用来连接自己公司的数据库。<br>
二. JDBC开发步骤<br>
JDBC一般的开发步骤如下：<br>
首先要从官方网站上下载Mysql的驱动，并通过Eclipse导入驱动（jar包）<br>
导入驱动的方法.png</p>
<p>JDBC开发步骤如下：<br>
注册驱动（Driver）<br>
获得连接（Connection）<br>
获得语句执行平台（Statement）<br>
使用SQL语句进行处理<br>
释放资源，关闭链接<br>
数据库中创建示例：<br>
create table users(<br>
username varchar(10),<br>
pass varchar(10),<br>
nicheng varchar(30)<br>
);<br>
insert into users (username,pass,nicheng) values('wjy','wjykl22','凉凉夜色为你思念成河');<br>
select * from users;<br>
Java连接数据库<br>
1.注册驱动:<br>
官方API推荐方法：</p>
<p>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<br>
不推荐使用DriverManager.registerDriver(new com.mysql.jdbc.Driver());注册，以上代码有两点不足：</p>
<p>硬编码，后期不易维护<br>
驱动在源码中就被注册过，驱动会被两次注册<br>
Driver源码：<br>
public class Driver extends NonRegisteringDriver implements java.sql.Driver {<br>
static {<br>
try {<br>
java.sql.DriverManager.registerDriver(new Driver());<br>
} catch (SQLException E) {<br>
throw new RuntimeException(&quot;Can't register driver!&quot;);<br>
}<br>
}<br>
}<br>
2.获得连接:<br>
String url = &quot;jdbc:mysql://localhost:3306/jdbc&quot;;<br>
String username = &quot;root&quot;;<br>
String password = &quot;wjykl22&quot;;<br>
Connection con = DriverManager.getConnection(url, username, password);<br>
其中url：需要连接数据库的位置（网址）目前来说格式基本上固定。</p>
<p>第一部分：jdbc，这是固定的；<br>
第二部分：数据库名称，我们连接的是Mysql数据库，所以使用Mysql<br>
第三部分：由数据库厂商规定的，每个厂商都有各自的要求，分别由数据库服务器的IP地址（localhost）、端口号（3306），以及DATABASE名称(jdbc)组成。</p>
<p>username：数据库用户名。<br>
password：数据库密码。<br>
采用上述方法就可以获得数据库的链接。</p>
<p>3.获得执行平台并执行sql语句<br>
Statement stat = con.createStatement();<br>
int executeUpdate(String sql);//用于执行insert update delete语句.<br>
ResultSet executeQuery(String sql); //用于执行select语句.<br>
boolean execute(String sql); //用于执行select返回true 执行其他的语句返回false.<br>
4.结果集处理<br>
得到ResultSet结果集后，需要对其中的数据进行数据的提取，对于ResultSet结果集的处理方法：</p>
<p>Object getObject(int index) / Object getObject(String name) 获得任意对象<br>
String getString(int index) / Object getObject(String name) 获得字符串<br>
int getInt(int index) / Object getObject(String name) 获得整形<br>
double getDouble(int index) / Object getObject(String name) 获得双精度浮点型<br>
5.释放资源<br>
最后一步就是释放资源，与IO释放资源的方式如出一辙。</p>
<p>rs.close();<br>
stmt.close();<br>
con.close();<br>
总结<br>
完整的上述步骤如下：</p>
<p>public class JDBCDemo {<br>
public static void main(String args[]) {<br>
try {<br>
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<br>
String url = &quot;jdbc:mysql://localhost:3306/jdbc&quot;;<br>
String username = &quot;root&quot;;<br>
String password = &quot;wjykl22&quot;;<br>
Connection con = DriverManager.getConnection(url, username, password);<br>
Statement stat = con.createStatement();<br>
stat.executeUpdate(&quot;insert into users (username,pass,nicheng) values('wjy2','wjykl33','如水流央')&quot;);<br>
ResultSet rs = stat.executeQuery(&quot;select * from users&quot;);<br>
while(rs.next()) {<br>
System.out.println(rs.getString(&quot;username&quot;)<br>
+&quot;\t&quot;+rs.getString(&quot;pass&quot;)+&quot;\t&quot;+rs.getString(&quot;nicheng&quot;));<br>
}<br>
rs.close();<br>
stat.close();<br>
con.close();<br>
} catch (Exception e) {<br>
e.printStackTrace();<br>
}<br>
}<br>
}<br>
预处理对象方法<br>
  为了防止代码存在SQL注入漏洞，使得代码更加完善，我们一般采用预处理对象：PreparedStatement<br>
  每条sql语句所有的实际参数，都使用逗号分隔。</p>
<ol>
<li>预处理对象并执行sql语句<br>
String sql = &quot;insert into sort(sid,sname) values(?,?)&quot;;<br>
PreparedStatement psmt = conn.prepareStatement(sql)</li>
<li>设置实际参数<br>
void setXxx(int index, Xxx xx)<br>
完整的代码程序段如下：</li>
</ol>
<p>public class LoginDemo {<br>
/*<br>
* Java程序实现用户的登录，用户名和密码，数据库检查<br>
* 防止注入攻击<br>
* Statment有一个子接口PrepareStatment，表示预编译的SQL语句对象，可以高效的执行<br>
* 这个方法是Connection数据库连接的方法<br>
* 如何获取这个实现类呢？<br>
*/<br>
public static void main(String args[]) throws Exception {<br>
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<br>
String url = &quot;jdbc:mysql://localhost:3306/world&quot;;<br>
String username = &quot;root&quot;;<br>
String password = &quot;wjykl22&quot;;<br>
Connection con = DriverManager.getConnection(url,username,password);<br>
Scanner sc = new Scanner(System.in);<br>
String user = sc.nextLine();<br>
String pass = sc.nextLine();<br>
//执行sql语句，查询用户名和密码。<br>
//注意要写问号<br>
String sql = &quot;select * from users where username =? and pass =?&quot;;<br>
java.sql.PreparedStatement pst = con.prepareStatement(sql);<br>
//调用pst中的set方法<br>
pst.setObject(1, user);<br>
pst.setObject(2, pass);</p>
<pre><code>    System.out.println(sql);
    ResultSet rs = pst.executeQuery();
    while(rs.next()) {
        System.out.println(rs.getString(&quot;username&quot;) + &quot;    &quot; + rs.getString(&quot;pass&quot;));
    }
}
</code></pre>
<p>}<br>
三. 工具类撰写和使用<br>
  作为一名程序员最应该学会的事情就是偷懒。设想一下，如果我们要在多各程序中使用Mysql数据库，会有很多代码重复使用，我们可以创建一个工具类Utils，通过工具类来完成注册驱动，获得链接，获得执行平台以及释放资源的操作。<br>
  <br>
  代码如下：</p>
<p>public class JDBCUtils {<br>
public static final  String DRIVERNAME = &quot;com.mysql.jdbc.Driver&quot;;<br>
public static final  String URL = &quot;jdbc:mysql://localhost:3306/mydb&quot;;<br>
public static final  String USER = &quot;root&quot;;<br>
public static final  String PASSWORD = &quot;root&quot;;<br>
static {<br>
try {<br>
Class.forName(DRIVERNAME);<br>
} catch (ClassNotFoundException e) {<br>
System.out.println(&quot;数据库驱动注册失败！&quot;);<br>
}<br>
}<br>
public static Connection getConn() throws Exception {<br>
Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);<br>
return conn;<br>
}<br>
}<br>
通过调用Utils类中的各种静态方法来达到重复利用代码的效果。</p>
<p>四. properties配置文件<br>
  上述代码还是不太方便，如果要修改某个参数，需要修改源代码，有没有方法能够不修改源代码就能够完成配置的修改呢？<br>
  通常情况下，我们习惯使用properties文件来存储与数据库有关的配置文件。</p>
<p>文件位置：任意，建议src下<br>
文件名称：任意，扩展名为properties<br>
文件内容：一行一组数据，格式是“key=value”.<br>
3.1 key命名自定义，如果是多个单词，习惯使用点分隔。例如：jdbc.driver<br>
3.2 value值不支持中文，如果需要使用非英文字符，将进行unicode转换。<br>
例如：<br>
driver=com.mysql.jdbc.Driver<br>
url=jdbc:mysql://localhost:3306/jdbc<br>
user=root<br>
password=root</p>
<p>加载配置文件properties的方法：<br>
  对应properties文件处理，开发中也使用Properties对象进行。我们将采用加载properties文件获得流，然后使用Properties对象进行处理。</p>
<p>public class JDBCUtils {<br>
private static String driver;<br>
private static String url;<br>
private static String user;<br>
private static String password;<br>
static {<br>
try {<br>
// 1. 使用Properties处理流<br>
// 使用load()方法加载指定的流<br>
Properties props = new Properties();<br>
Reader is = new FileReader(&quot;db.properties&quot;);<br>
props.load(is);<br>
// 2. 使用getProperty(key)，通过key获得需要的值，<br>
driver = props.getProperty(&quot;driver&quot;);<br>
url = props.getProperty(&quot;url&quot;);<br>
user = props.getProperty(&quot;user&quot;);<br>
password = props.getProperty(&quot;password&quot;);<br>
} catch (Exception e) {<br>
throw new RuntimeException(e);<br>
}<br>
}</p>
<pre><code>/**
 * 获得连接
 */
public static Connection getConnection() {
    try {
        // 1 注册驱动
        Class.forName(driver);
        // 2 获得连接
        Connection conn = DriverManager.getConnection(url, user, password);
        return conn;
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ajax]]></title>
        <id>https://ysjhhhhhhh.github.io/post/ajax</id>
        <link href="https://ysjhhhhhhh.github.io/post/ajax">
        </link>
        <updated>2018-03-31T09:38:57.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="ajax">Ajax</h2>
<ul>
<li>是什么?</li>
</ul>
<blockquote>
<p>“Asynchronous Javascript And XML”（异步JavaScript和XML），</p>
</blockquote>
<blockquote>
<p>并不是新的技术，只是把原有的技术，整合到一起而已。</p>
</blockquote>
<pre><code>1.使用CSS和XHTML来表示。
2.使用DOM模型来交互和动态显示。
3.使用XMLHttpRequest来和服务器进行异步通信。
4.使用javascript来绑定和调用。
</code></pre>
<ul>
<li>有什么用?</li>
</ul>
<blockquote>
<p>咱们的网页如果想要刷新局部内容。 那么需要重新载入整个网页。用户体验不是很好。  就是为了解决局部刷新的问题。 保持其他部分不动，只刷新某些地方。</p>
</blockquote>
<h3 id="数据请求-get">数据请求 Get</h3>
<h4 id="创建ajax请求对象">创建ajax请求对象</h4>
<pre><code class="language-javascript">function  ajaxFunction(){
	    var xmlHttp;
	    try{ // Firefox, Chrome, Opera 8.0+, Safari
	        xmlHttp=new XMLHttpRequest();
	    }
	    catch (e){
	        try{// Internet Explorer（高版本）
	            xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
	        }
	        catch (e){
	            try{// Internet Explorer（低版本）
	                xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
	            }
	            catch (e){}
	        }
	    }
	    return xmlHttp;
	}
</code></pre>
<h4 id="发送请求">发送请求</h4>
<pre><code class="language-javascript">//执行get请求
function get() {

    //1. 创建xmlhttprequest 对象
    var request = ajaxFunction();

    //2. 发送请求。
    /*	
	 *	参数一： 请求类型  GET or  POST
	 *	参数二： 请求的路径
	 *	参数三： 是否异步， true  or false
	 */
    request.open(&quot;GET&quot; ,&quot;TestServlet&quot; ,true );
    request.send();
}



// 如果发送请求的同时，还想获取数据，那么代码如下

//执行get请求
function get() {

    //1. 创建xmlhttprequest 对象
    var request = ajaxFunction();

    //2. 设置请求参数
    request.open(&quot;GET&quot; ,&quot;TestServlet?name=aa&amp;age=18&quot; ,true );

    //3. 获取响应数据 注册监听的意思。  一会准备的状态发生了改变，那么就执行 = 号右边的方法
    request.onreadystatechange = function(){
        // readyState的值一共有5个状态，参见下表
        // readyState == 4 表示请求已经完成， 再判断状态码是否是200，200表示服务端正常响应(没有报错)
        if(request.readyState == 4 &amp;&amp; request.status == 200){
            //弹出响应的信息
            alert(request.responseText);
        }
    }
    
    // 4. 发送请求
    request.send();
}
</code></pre>
<h3 id="xmlhttprequest-readystate状态表">XMLHttpRequest readyState状态表</h3>
<table>
<thead>
<tr>
<th>值</th>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td><code>UNSENT</code></td>
<td>代理被创建，但尚未调用 open() 方法。</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>OPENED</code></td>
<td><code>open()</code> 方法已经被调用。</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>HEADERS_RECEIVED</code></td>
<td><code>send()</code> 方法已经被调用，并且头部和状态已经可获得。</td>
</tr>
<tr>
<td><code>3</code></td>
<td><code>LOADING</code></td>
<td>请求中； <code>responseText</code> 属性已经包含部分数据。</td>
</tr>
<tr>
<td><code>4</code></td>
<td><code>DONE</code></td>
<td>请求完成。</td>
</tr>
</tbody>
</table>
<h3 id="数据请求-post">数据请求 Post</h3>
<pre><code class="language-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
	//1. 创建对象
	// 和get请求一样
	
	function post() {
		//1. 创建请求对象
		var request = ajaxFunction();
		
		// 2. 设置请求地址、参数、类型(post、get)
		request.open(&quot;post&quot;, &quot;StudentServlet&quot;, true);
		
		//3. 获取响应数据 注册监听的意思。  一会准备的状态发生了改变，那么就执行 = 号右边的方法
	    request.onreadystatechange = function(){
	        //前半段表示 已经能够正常处理。  再判断状态码是否是200
	        if(request.readyState == 4 &amp;&amp; request.status == 200){
	            //弹出响应的信息
	            console.log(&quot;请求完成&quot;);
	            var h1 = document.getElementById(&quot;h1&quot;);
	        	h1.innerHTML = request.responseText;
	        }
	    }
		
	 	// 4. 如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据
		request.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
		
		// 5. 发送请求
    	// 如果是GET请求，参数写在这里是无效的
		request.send(&quot;id=555&quot;);
	}

&lt;/script&gt;
</code></pre>
<h2 id="jquery-ajax">JQuery Ajax</h2>
<h3 id="底层ajax写法">底层ajax写法</h3>
<pre><code class="language-javascript">// 语法：$.ajax(url, [settings]);

$.ajax(&quot;TestServlet&quot;, {
    type: &quot;GET&quot;,
    data: {
        action: &quot;json&quot;,
        uname: &quot;zhangsan&quot;
    },
    dataType: &quot;json&quot;,
    success: function(data, status_text){
        console.log(data);
        console.log(&quot;status_text: &quot; + status_text);
    },
    error: function(xhr, textStatus, errorThrow) {
        console.log(&quot;请求失败&quot;);
    }
});
</code></pre>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>a</mi><mi>j</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">所</mi><mi mathvariant="normal">有</mi><mi>a</mi><mi>j</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">相</mi><mi mathvariant="normal">关</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">底</mi><mi mathvariant="normal">层</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">现</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">都</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">基</mi><mi mathvariant="normal">础</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">给</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">封</mi><mi mathvariant="normal">装</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">更</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">便</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">关</mi><mi mathvariant="normal">于</mi></mrow><annotation encoding="application/x-tex">.ajax方法是其他所有ajax相关方法的底层实现，其他方法都是在它的基础上给我们封装的更方便使用的方法。 关于</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">有</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">相</span><span class="mord cjk_fallback">关</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">底</span><span class="mord cjk_fallback">层</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">现</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">都</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">基</span><span class="mord cjk_fallback">础</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">给</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">封</span><span class="mord cjk_fallback">装</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">更</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">便</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">关</span><span class="mord cjk_fallback">于</span></span></span></span>.ajax的详细介绍参见 <a href="http://jquery.cuishifeng.cn/jQuery.Ajax.html">http://jquery.cuishifeng.cn/jQuery.Ajax.html</a></p>
</blockquote>
<h3 id="get请求">get请求</h3>
<pre><code class="language-javascript">/*
 * 参数：
 *  url: 请求地址
 *  data: 待发送 Key/value 参数
 *  fn: 请求成功后回调函数
 *  type: 返回内容格式，xml, html, script, json, text, _default
 */

$.get( &quot;url&quot;,{pid:pid} ,function(data,status_text){
    console.log(data);
    console.log(&quot;status_text: &quot; + status_text);
},&quot;json&quot; );	// 指定请求返回的格式是json，jquery会帮我们把服务端返回的json字符串转换成js的json对象
</code></pre>
<h3 id="post请求">post请求</h3>
<pre><code class="language-javascript">/*
 * 参数：
 *  url: 请求地址
 *  data: 待发送 Key/value 参数
 *  fn: 请求成功后回调函数
 *  type: 返回内容格式，xml, html, script, json, text, _default
 */

$.post( &quot;url&quot;,{pid:pid} ,function(data,status){
    console.log(data);
    console.log(&quot;status_text: &quot; + status_text);
},&quot;json&quot; );	// 指定请求返回的格式是json，jquery会帮我们把服务端返回的json字符串转换成js的json对象
</code></pre>
<h3 id="获取json数据专用方法">获取JSON数据专用方法</h3>
<pre><code class="language-javascript">$.getJSON(&quot;url&quot;, {id:1, name: &quot;zhangsan&quot;} function(json){
  console.log(json);
});
</code></pre>
<h2 id="服务器和客户端数据传输的方式">服务器和客户端数据传输的方式</h2>
<h3 id="xml">xml</h3>
<p>因为无效数据占比太大，阅读困难。基本已经被json格式淘汰掉了</p>
<pre><code class="language-xml">  	&lt;list&gt;
        &lt;city&gt;
        &lt;id&gt;1&lt;id&gt;
        &lt;pid&gt;1&lt;/pid&gt;
        &lt;cname&gt;深圳&lt;/cname&gt;
        &lt;/city&gt;
        &lt;city &gt;
        &lt;id&gt;2&lt;id&gt;
        &lt;pid&gt;1&lt;/pid&gt;
        &lt;cname&gt;东莞&lt;/cname&gt;
        &lt;/city&gt;
    &lt;/list&gt;
</code></pre>
<h3 id="json">json</h3>
<p>阅读性更好 、 占用空间更小。</p>
<pre><code class="language-json">[{city:{id:1, pid:1, cname:&quot;深圳&quot;}}, {city:{id:2, pid:1, cname:&quot;东莞&quot;}}]
</code></pre>
<h4 id="前端json操作">前端json操作</h4>
<pre><code class="language-js">JSON.parse(jsonStr); // 将JSON字符串转成js对象
JSON.stringify(obj);  // 将js对象转成JSON字符串
</code></pre>
<h4 id="后台json操作库">后台json操作库</h4>
<ul>
<li>
<p>fastjson库</p>
<p>JSON.toJSONString();	// 将JavaBean encode成 json string<br>
JSON.parseObject();		// 将json对象decode成javabean<br>
JSON.parseArray();		// 将json数组decode成java List或 JSONArray类型</p>
</li>
<li>
<p>Gson库</p>
</li>
<li>
<p>Jackson库</p>
</li>
<li>
<p>...</p>
</li>
</ul>
<h2 id="总结">总结</h2>
<h3 id="ajax-2">Ajax</h3>
<ul>
<li>创建异步请求对象的方法</li>
<li>发起异步GET请求的步骤</li>
<li>发起异步POST请求的步骤</li>
<li>异步POST请求与GET请求的对比</li>
</ul>
<h3 id="jquery">JQuery</h3>
<ul>
<li>$.ajax()</li>
<li>$.get()</li>
<li>$.post()</li>
<li>$.getJSON()</li>
<li>jQuery中各个ajax方法之间的区别和联系</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cookie&Session]]></title>
        <id>https://ysjhhhhhhh.github.io/post/Cookie&amp;Session</id>
        <link href="https://ysjhhhhhhh.github.io/post/Cookie&amp;Session">
        </link>
        <updated>2018-03-30T12:48:19.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="cookie">Cookie</h1>
<blockquote>
<p>饼干. 其实是一份小数据， 是服务器给客户端，并且存储在客户端上的一份小数据</p>
</blockquote>
<h2 id="应用场景">应用场景</h2>
<blockquote>
<p>自动登录、浏览记录、购物车。</p>
</blockquote>
<h2 id="为什么要有这个cookie">为什么要有这个Cookie</h2>
<blockquote>
<p>http的请求是无状态。 客户端与服务器在通讯的时候，是无状态的，其实就是客户端在第二次来访的时候，服务器根本就不知道这个客户端以前有没有来访问过。 为了更好的用户体验，更好的交互 [自动登录]，其实从公司层面讲，就是为了更好的收集用户习惯[大数据]</p>
</blockquote>
<h2 id="cookie怎么用">Cookie怎么用</h2>
<h3 id="添加cookie给客户端">添加Cookie给客户端</h3>
<ol>
<li>在响应的时候，添加cookie</li>
</ol>
<pre><code class="language-java">	Cookie cookie = new Cookie(&quot;aa&quot;, &quot;bb&quot;);	
	//给响应，添加一个cookie
	response.addCookie(cookie);
</code></pre>
<ol start="2">
<li>客户端收到的信息里面，响应头中多了一个字段 Set-Cookie<br>
<img src="https://ysjhhhhhhh.github.io/post-images/1576045567472.png" alt=""></li>
</ol>
<h3 id="获取客户端带过来的cookie">获取客户端带过来的Cookie</h3>
<pre><code class="language-java">//获取客户端带过来的cookie
Cookie[] cookies = request.getCookies();
if(cookies != null){
    for (Cookie c : cookies) {
        String cookieName = c.getName();
        String cookieValue = c.getValue();
        System.out.println(cookieName + &quot; = &quot;+ cookieValue);
    }
}
</code></pre>
<h3 id="清除cookie">清除Cookie</h3>
<blockquote>
<p>Cookie没有提供delete方法，我们要删除需要设置maxAge 为0 。</p>
</blockquote>
<pre><code>Cookie cookie = new Cookie(&quot;history&quot;,&quot;&quot;);
cookie.setMaxAge(0); //设置立即删除
cookie.setPath(&quot;/CookieDemo02&quot;);
response.addCookie(cookie);
</code></pre>
<h3 id="其他常用方法">其他常用方法</h3>
<pre><code class="language-java">//关闭浏览器后，cookie就没有了。 ---&gt; 针对没有设置cookie的有效期。
//	expiry： 有效 以秒计算。
//正值 ： 表示 在这个数字过后，cookie将会失效。
//负值： 关闭浏览器，那么cookie就失效， 默认值是 -1
cookie.setMaxAge(60 * 60 * 24 * 7);

//赋值新的值
//cookie.setValue(newValue);

//用于指定只有请求了指定的域名，才会带上该cookie
cookie.setDomain(&quot;.itheima.com&quot;);

//只有访问该域名下的cookieDemo的这个路径地址才会带cookie
cookie.setPath(&quot;/CookieDemo&quot;);
</code></pre>
<h2 id="cookie示例-实现记住密码功能">Cookie示例 实现记住密码功能</h2>
<ol>
<li>用户打开网站后，自动读取Cookie中存储的用户名、密码</li>
<li>如果存在，自动填充到表单中</li>
<li>如果不存在，说明是第一次登录，需要登录后在后台将用户名、密码写入Cookie中，以便下次登录时自动填充</li>
</ol>
<h3 id="主要实现代码">主要实现代码</h3>
<h4 id="前端登录页">前端登录页</h4>
<pre><code class="language-jsp">&lt;body&gt;
	&lt;form action=&quot;LoginServlet&quot; method=&quot;post&quot;&gt;
		用户名： &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;userName&quot; onblur=&quot;inputPwd()&quot; &gt;
		&lt;br /&gt;
		密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码：
		&lt;input id=&quot;pwd&quot; type=&quot;password&quot; name=&quot;password&quot;&gt;
		&lt;br /&gt;
		&lt;input type=&quot;checkbox&quot; name=&quot;remeber_me&quot; value=&quot;true&quot; /&gt; 记住密码 
		&lt;br /&gt;
		&lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
	&lt;/form&gt;
&lt;/body&gt;
&lt;!-- 引入js操作Cookie的第三方库，也可以使用原生js API --&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
	
	// 从cookies里面按照用户输入的username去查找对应的password,
	// 如果找到，说明用户已经登录成功过，并且已经记录到cookie里。
	// 我们直接把对应的密码从cookie中拿出来，设置password密码框里
	
	// my_cookies其实就是一个map， 存储了所有的cookie键值对
	var my_cookies = Cookies.get();
	console.log(my_cookies);
	
	var pwdInput = document.getElementById(&quot;pwd&quot;);
	var username = document.getElementById(&quot;username&quot;);
	
	// 当输入完用户名，文本框失去焦点时，去cookie中找对应的密码，
	// 如果找到，直接填充到密码框里
	function inputPwd() {
		var userName = username.value;
		var cookieKey = &quot;username-&quot; + userName;
		console.log(cookieKey);
		var cookiePwd = my_cookies[cookieKey];
		console.log(cookiePwd);
		if(cookiePwd) {
			pwdInput.value = cookiePwd;
		}
	}
&lt;/script&gt;
</code></pre>
<h4 id="后台处理代码">后台处理代码</h4>
<pre><code class="language-java">protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		request.setCharacterEncoding(&quot;UTF-8&quot;);
		
		// 获取前台表单提交的用户名、密码
		String userName = request.getParameter(&quot;userName&quot;);
		String password = request.getParameter(&quot;password&quot;);
		
		// 获取前台是否勾上了记住密码
		String sRemeber = request.getParameter(&quot;remeber_me&quot;);
		boolean remeber = false;
		try {
			remeber = Boolean.parseBoolean(sRemeber);
		} catch (Exception e) {
		}
		
		
		// 设置响应格式和编码
		response.setContentType(&quot;text/html;charset=UTF-8&quot;);
		
		PrintWriter out = response.getWriter();
		if(isBlank(userName) || isBlank(password)) {
			out.println(&quot;&lt;script&gt;alert('用户名或密码不能为空!'); window.location.href='login.jsp';&lt;/script&gt;&quot;);
			return;
		}
		
		if(!userAccountData.containsKey(userName)) {
			out.println(&quot;&lt;script&gt;alert('不好意思，您还没有注册！'); window.location.href='login.jsp';&lt;/script&gt;&quot;);
			return;
		}
		
		String orginPassword = userAccountData.get(userName);
		if(password.startsWith(&quot;pwd-&quot;)) {
			password = password.substring(4);
		}
		
		if(orginPassword.equals(password)) {
			out.println(&quot;登录成功！&quot;);
			if(remeber) {
				Cookie cookie = new Cookie(&quot;username-&quot; + userName, &quot;pwd-&quot; + password);
				cookie.setMaxAge(120);
				response.addCookie(cookie);
			}
			return;
		} else {
			out.println(&quot;&lt;script&gt;alert('用户名或密码不正确，请重新输入！'); window.location.href='login.jsp';&lt;/script&gt;&quot;);
			return;
		}
	}
</code></pre>
<h2 id="cookie总结">Cookie总结</h2>
<ol>
<li>
<p>服务器给客户端发送过来的一小份数据，并且存放在客户端上。</p>
</li>
<li>
<p>创建Cookie:</p>
<p>使用new来创建Cookie对象</p>
<pre><code class="language-java">Cookie cookie = new Cookie(&quot;xxx&quot;, &quot;wangzhenongyao&quot;);
</code></pre>
</li>
<li>
<p>添加cookie</p>
<p>添加cookie通过响应对象的addCookie方法</p>
<pre><code class="language-java">// 底层实现原理其实是在响应头中添加了一个： Set-Cookie: password=qiaoshouyuan; Max-Age=60; Expires=Fri, 20-Sep-2019 08:41:19 GMT; HttpOnly
response.addCookie();
</code></pre>
</li>
<li>
<p>获取cookie</p>
<pre><code class="language-java">Cookie[] cookies = request.getCookies();
</code></pre>
</li>
<li>
<p>Cookie有效时间</p>
<ol>
<li>
<p>会话Cookie</p>
<p>默认情况下，关闭了浏览器，那么cookie就会消失。</p>
<blockquote>
<p>这是默认的行为，但是大部分现代的浏览器都不会这么做，比如chrome浏览器，默认打开时会恢复上次关闭时的状态，所有关闭浏览器cookie并不会失效。 我们可以设置浏览器打开时不恢复上次状态，改为打开新的标签页即可。</p>
</blockquote>
</li>
<li>
<p>持久Cookie</p>
<p>通过设置MaxAge指定存活时间，在存活时间内，都有效，并且会保存在客户端上。</p>
</li>
</ol>
<pre><code>cookie.setMaxAge(0); //设置立即删除  
cookie.setMaxAge(100); //100 秒
</code></pre>
</li>
<li>
<p>Cookie的安全问题。</p>
<blockquote>
<p>由于Cookie会保存在客户端上，所以有安全隐患问题。  还有一个问题， Cookie的大小与个数有限制。 为了解决这个问题 ---&gt; Session .</p>
</blockquote>
</li>
<li>
<p>Cookie不能直接存储中文，需要做转码</p>
</li>
</ol>
<h1 id="session">Session</h1>
<blockquote>
<p>会话 ， Session是基于Cookie的一种会话机制。 Cookie是服务器返回一小份数据给客户端，并且存放在客户端上。 Session是，数据存放在服务器端。</p>
</blockquote>
<h2 id="常用api">常用API</h2>
<pre><code class="language-java">//得到会话ID
String id = session.getId();

//存值
session.setAttribute(name, value);

//取值
session.getAttribute(name);

//移除值
session.removeAttribute(name);
</code></pre>
<h2 id="session创建和销毁">Session创建和销毁</h2>
<h3 id="创建">创建</h3>
<blockquote>
<p>在调用所有可以获取session的页面中(如：JSP、Servlet)，就会创建Session，并且浏览器Cookie中也会生成JSESSIONID</p>
</blockquote>
<h3 id="获取session">获取Session</h3>
<pre><code>request.getSession();
</code></pre>
<h3 id="销毁">销毁</h3>
<blockquote>
<p>session 是存放在服务器的内存中的一份数据。</p>
</blockquote>
<blockquote>
<ol>
<li>关闭服务器</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>session会话时间过期。 有效期过了，默认有效期： 30分钟。</li>
</ol>
</blockquote>
<h3 id="移除session中的元素">移除Session中的元素</h3>
<pre><code>//强制干掉会话，里面存放的任何数据就都没有了。
session.invalidate();

//从session中移除某一个数据
//session.removeAttribute(&quot;cart&quot;);
</code></pre>
<h1 id="总结">总结：</h1>
<h2 id="cookie-2">Cookie</h2>
<p>服务器给客户端发送一小份数据， 存放在客户端上。</p>
<h3 id="基本用法">基本用法：</h3>
<pre><code>添加cookie

获取cookie。
</code></pre>
<h3 id="什么时候有cookie">什么时候有cookie</h3>
<p>response.addCookie(new Cookie())</p>
<h3 id="cookie-分类">Cookie 分类</h3>
<ul>
<li>
<p>会话Cookie</p>
<pre><code>  关闭浏览器，就失效
</code></pre>
</li>
<li>
<p>持久cookie</p>
<p>存放在客户端上。 在指定的期限内有效。</p>
<pre><code>	setMaxAge();
</code></pre>
</li>
</ul>
<h2 id="session-2">Session</h2>
<p>也是基于cookie的一种会话技术，  数据存放存放在服务器端，会在cookie里面添加一个字段 JSESSIONID . 是tomcat服务器生成。</p>
<h3 id="常用api-2">常用API</h3>
<pre><code>
setAttribute 存数据
 
getAttribute 取数据

removeAttribute  移除数据

req.getRequestedSessionId();  获取会话id
session.getId();  获取会话id

invalidate() 强制让会话失效。
</code></pre>
<h3 id="创建和销毁">创建和销毁</h3>
<ul>
<li>创建： 首次访问所有可以调用request.getSession方法的页面时，session创建，同时JSESSIONID也会生成</li>
<li>销毁：
<ul>
<li>关闭浏览器</li>
<li>会话超时（默认是30分钟）</li>
<li>服务端调用invalidate</li>
</ul>
</li>
</ul>
<h2 id="cookie和session的区别">Cookie和Session的区别</h2>
<ol>
<li>Cookie数据存放到客户端（浏览器），Session存放在服务端；</li>
<li>Cookie存放的数据大小有限制，不能超过4k；很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>Cookie由于存放在客户端硬盘上，所以相较于Session来说安全性低一点；</li>
<li>cookie失效时间是通过setMaxAge来设置，session是通过setInactiveInterval方法设置</li>
<li>Cookie中只能存储字符串的值，而且还不能中文。而Session中可以存储任意语言的字符串，或者Java中的所有类型。</li>
<li>Cookie是由程序员在业务代码中自己创建的，而Session是由容器创建的。</li>
</ol>
<h2 id="cookie和session的关系">Cookie和Session的关系</h2>
<p>HTTP协议本身是无状态的，也就是说服务端无法通过一个请求判断出谁是谁，而Session作为服务端跟踪用户状态的一项技术，在整个容器中存在很多份数据。如何知道一个请求进来应该拿哪份Session数据这是个问题。那么要解决这个问题，我们需要在请求中添加一个标识，Cookie技术就解决了这个问题。具体来说，Tomcat会在浏览器第一次访问JSP、Servlet时分配一个独一无二的Cookie标识(JSESSIONID)，写到浏览器端。后续每次请求时，浏览器会携带这个标识，进而服务端就可以区分出来谁是谁，然后拿对应的Session数据。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Litener&Filter]]></title>
        <id>https://ysjhhhhhhh.github.io/post/Litener&amp;Filter</id>
        <link href="https://ysjhhhhhhh.github.io/post/Litener&amp;Filter">
        </link>
        <updated>2018-03-28T02:04:40.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="listener">Listener</h1>
<blockquote>
<p>监听器</p>
</blockquote>
<ul>
<li>能做什么事？</li>
</ul>
<blockquote>
<p>监听某一个事件的发生。 状态的改变。</p>
</blockquote>
<ul>
<li>监听器的内部机制</li>
</ul>
<blockquote>
<p>其实就是接口回调.</p>
</blockquote>
<h2 id="监听器实现原理观察者模式">监听器实现原理——观察者模式</h2>
<ul>
<li>需求：</li>
</ul>
<blockquote>
<p>A在执行循环，当循环到5的时候， 通知B。</p>
</blockquote>
<blockquote>
<p>事先先把一个对象传递给 A ， 当A 执行到5的时候，通过这个对象，来调用B中的方法。 但是注意，不是直接传递B的实例，而是传递一个接口的实例过去。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://ysjhhhhhhh.github.io/post-images/1576044349452.png" alt=""></figure>
<h2 id="web监听器介绍">Web监听器介绍</h2>
<p>在JavaWeb开发中监听器总共有8个</p>
<h3 id="按照使用方法来划分可以分为两类">按照使用方法来划分可以分为两类</h3>
<h4 id="第一类-实现接口然后通过注册生效">第一类 实现接口然后通过注册生效</h4>
<p>具体配置步骤</p>
<ol>
<li>实现对应的监听器接口</li>
<li>重写接口中的方法</li>
<li>然后在web.xml或者注解的方式注册到容器中来使用</li>
</ol>
<p>适用的监听器类型</p>
<p>ServletRequestListener、HttpSessionListener、ServletContextListener、ServletRequestAttributeListener、HttpSessionAttributeListener、SerlvetContextAttributeListener</p>
<h4 id="第二类-让需要监听session中的特定类型实现监听接口不需要注册生效">第二类  让需要监听Session中的特定类型实现监听接口，不需要注册生效</h4>
<p>具体配置步骤</p>
<ol>
<li>让需要监听Session中的特定类型，如UserInfo实现监听接口</li>
<li>实现接口中的方法</li>
</ol>
<p>适用的监听器类型</p>
<p>HttpSessionBindingListener、HttpSessionActivationListener</p>
<h3 id="按照监听器的作用可以划分为三类">按照监听器的作用可以划分为三类</h3>
<h4 id="监听三个作用域创建和销毁">监听三个作用域创建和销毁</h4>
<ul>
<li>request  ---HttpServletRequest</li>
<li>session  ---HttpSession</li>
<li>application  --- ServletContext</li>
</ul>
<h5 id="servletrequestlistener">ServletRequestListener</h5>
<ul>
<li>监听事件</li>
</ul>
<pre><code>request创建:

    访问服务器上的任意资源都会有请求出现。

    访问 html： 会
    访问 jsp:	会
    访问 servlet : 会 

request销毁：

	服务器已经对这次请求作出了响应。			
</code></pre>
<ul>
<li>实现示例</li>
</ul>
<ol>
<li>新建Java类，实现ServletRequestListener接口</li>
</ol>
<pre><code class="language-java">import javax.servlet.ServletRequestEvent;
import javax.servlet.ServletRequestListener;

public class RequestListener implements ServletRequestListener {

	@Override
	public void requestDestroyed(ServletRequestEvent sre) {
		System.out.println(&quot;request请求结束&quot;);
	}

	@Override
	public void requestInitialized(ServletRequestEvent sre) {
		System.out.println(&quot;request请求开始&quot;);
	}
}
</code></pre>
<ol start="2">
<li>在web.xml中注册监听器</li>
</ol>
<pre><code class="language-xml">&lt;listener&gt;
    &lt;listener-class&gt;com.lanou3g.demo.RequestListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<h5 id="httpsessionlistener">HttpSessionListener</h5>
<ul>
<li>监听事件</li>
</ul>
<pre><code>	session的创建
	    只要调用getSession
	
	    html:		不会
	    jsp:		会	  getSession();
	    servlet: 	会
	
	session的销毁
	    超时  30分钟
	    非正常关闭 销毁
	    正常关闭服务器(序列化)
</code></pre>
<ul>
<li>应用场景</li>
</ul>
<blockquote>
<p>统计在线人数.</p>
</blockquote>
<ul>
<li>实现示例</li>
</ul>
<ol>
<li>新建Java类，实现HttpSessionListener接口</li>
</ol>
<pre><code class="language-java">import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;

public class SessionLinsener implements HttpSessionListener {
	@Override
	public void sessionCreated(HttpSessionEvent se) {
		System.out.println(&quot;session被创建了&quot;);
	}

	@Override
	public void sessionDestroyed(HttpSessionEvent se) {
		System.out.println(&quot;session销毁了&quot;);
	}
}
</code></pre>
<ol start="2">
<li>在web.xml中注册监听器</li>
</ol>
<pre><code class="language-xml">&lt;listener&gt;
    &lt;listener-class&gt;com.lanou3g.demo.SessionLinsener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<h5 id="servletcontextlistener">ServletContextListener</h5>
<ul>
<li>
<p>监听事件</p>
<ul>
<li>
<p>ServletContext创建：启动服务器的时候</p>
</li>
<li>
<p>ServletContext销毁：关闭服务器. 从服务器移除项目</p>
</li>
</ul>
</li>
<li>
<p>应用场景</p>
</li>
</ul>
<blockquote>
<p>在servletcontext创建的时候，</p>
<ol>
<li>完成自己想要的初始化工作</li>
<li>执行自定义任务调度。 执行某一个任务。 Timer</li>
</ol>
</blockquote>
<ul>
<li>实现示例</li>
</ul>
<p>新建Java类，实现ServletContextListener接口</p>
<pre><code class="language-java">import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;

public class ContextListener implements ServletContextListener {
	@Override
	public void contextInitialized(ServletContextEvent sce) {
		System.out.println(&quot;ServletContext初始化&quot;);
	}
	@Override
	public void contextDestroyed(ServletContextEvent sce) {
		System.out.println(&quot;ServletContext销毁&quot;);
	}
}
</code></pre>
<p>在web.xml中注册监听器</p>
<pre><code class="language-xml">&lt;listener&gt;
    &lt;listener-class&gt;com.lanou3g.demo.ContextListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<h4 id="监听三个作用域属性状态变更">监听三个作用域属性状态变更</h4>
<blockquote>
<p>可以监听在作用域中值 添加  | 替换  | 移除的动作。</p>
</blockquote>
<h5 id="servletcontext-servletcontextattributelistener">servletContext --- ServletContextAttributeListener</h5>
<figure data-type="image" tabindex="2"><img src="https://ysjhhhhhhh.github.io/post-images/1576044425334.png" alt=""></figure>
<h5 id="request-servletrequestattributelistener">request --- ServletRequestAttributeListener</h5>
<figure data-type="image" tabindex="3"><img src="https://ysjhhhhhhh.github.io/post-images/1576044439138.png" alt=""></figure>
<h5 id="session-httpsessionattributelistener">session --- HttpSessionAttributeListener</h5>
<figure data-type="image" tabindex="4"><img src="https://ysjhhhhhhh.github.io/post-images/1576044413990.png" alt=""></figure>
<h4 id="监听httpsession里面存值的状态变更">监听httpSession里面存值的状态变更</h4>
<blockquote>
<p>这一类监听器不用注册。</p>
</blockquote>
<h5 id="httpsessionbindinglistener">HttpSessionBindingListener</h5>
<blockquote>
<p>监听特定类型对象与session 绑定和解除绑定 的动作，注意此监听器是让JavaBean实现监听接口，即表示当session中此类型的value状态发生变更时，此JavaBean会收到通知</p>
</blockquote>
<p><span style="color:red;font-weight:bold;">与HttpSessionAttributeListener监听器不同的是，该监听器只对Session中的某种特定类型的属性变化感兴趣</span></p>
<pre><code class="language-java">// 注意：是让JavaBean实现该接口，不需要添加任何注解或在web.xml中配置

import javax.servlet.http.HttpSessionBindingEvent;
import javax.servlet.http.HttpSessionBindingListener;

public class Man implements HttpSessionBindingListener {

	private String name;
	private String nickName;
	private int age;

	public Man() {
	}

	public Man(String name, String nickName, int age) {
		this.name = name;
		this.nickName = nickName;
		this.age = age;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getNickName() {
		return nickName;
	}

	public void setNickName(String nickName) {
		this.nickName = nickName;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	@Override
	public void valueBound(HttpSessionBindingEvent event) {
		Man man = (Man) event.getValue();
		System.out.println(&quot;man对象绑定到session中 name: &quot; + man.getName() + &quot;, value: &quot; + event.getValue());
	}

	@Override
	public void valueUnbound(HttpSessionBindingEvent event) {
		Man man = (Man) event.getValue();
		System.out.println(&quot;man对象从session中解绑 name: &quot; + man.getName() + &quot;, value: &quot; + event.getValue());
	}
}
</code></pre>
<h5 id="httpsessionactivationlistener">HttpSessionActivationListener</h5>
<blockquote>
<p>用于监听现在session的值 是 钝化 （序列化）还是活化 （反序列化）的动作</p>
</blockquote>
<ul>
<li>钝化 （序列化）</li>
</ul>
<blockquote>
<p>把内存中的数据 存储到硬盘上</p>
</blockquote>
<ul>
<li>活化 （反序列化）</li>
</ul>
<blockquote>
<p>把硬盘中的数据读取到内存中。</p>
</blockquote>
<ul>
<li>session的钝化活化的用意何在</li>
</ul>
<blockquote>
<p>session中的值可能会很多， 并且我们有很长一段时间不使用这个内存中的值， 那么可以考虑把session的值可以存储到硬盘上【钝化】，等下一次在使用的时候，在从硬盘上提取出来。 【活化】</p>
</blockquote>
<ul>
<li>如何让session的在一定时间内钝化.</li>
</ul>
<h6 id="钝化-活化监听需要修改tomcat配置">钝化、活化监听需要修改Tomcat配置</h6>
<p>修改的地方有三个可选，主要是作用范围不一样</p>
<pre><code>1. 在tomcat里面 conf/context.xml 里面配置

		对所有的运行在这个服务器的项目生效

2. 在conf/Catalina/localhost/context.xml 配置

		对 localhost生效。  localhost:8080

3. 在自己的web工程项目中的 META-INF/context.xml

		只对当前的工程生效。
</code></pre>
<p>修改方法：</p>
<pre><code class="language-xml">	&lt;!--
		参数说明：
		# maxIdleSwap ： 1分钟不用就钝化
		# directory ：  钝化后的那个文件存放的目录位置。 
	--&gt;
	&lt;Context&gt;
		&lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot; maxIdleSwap=&quot;1&quot;&gt;
			&lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;F:/temp&quot;/&gt;
		&lt;/Manager&gt;
	&lt;/Context&gt;
</code></pre>
<h6 id="监听器使用步骤">监听器使用步骤</h6>
<ol>
<li>与HttpSessionBindingListener类似， HttpSessionActivationListener也是针对特定类型监听的。那我们需要让需要监听钝化、活化状态的特定的JavaBean实现HttpSessionActivationListener接口</li>
<li>上面提到的几种配置方法，任选一种告诉Tomcat当Session不活跃、或者容器停止时Session钝化的策略</li>
</ol>
<p>做好上面两步，当Session中有监听的特定类型，并且Session钝化、活化时就能触发通知</p>
<h2 id="filter">Filter</h2>
<blockquote>
<p>过滤器 ， 其实就是对客户端发出来的请求进行过滤。 浏览器发出， 然后服务器派servlet处理。  在中间就可以过滤， 其实过滤器起到的是拦截的作用。</p>
</blockquote>
<ul>
<li>
<p>作用</p>
<ol>
<li>对一些敏感词汇进行过滤</li>
<li>统一设置编码</li>
<li>自动登录</li>
</ol>
<p>...</p>
</li>
</ul>
<h3 id="如何使用filter">如何使用Filter</h3>
<ol>
<li>定义一个类， 实现Filter</li>
</ol>
<pre><code class="language-java">public class FilterDemo implements Filter {	
    public void destroy() {
    }

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    System.out.println(&quot;来到过虑器了。。。&quot;);
    chain.doFilter(request, response);
    }

    public void init(FilterConfig fConfig) throws ServletException {
    }
}
</code></pre>
<ol start="2">
<li>注册过滤器</li>
</ol>
<blockquote>
<p>在web.xml里面注册，注册的手法与servlet基本一样。</p>
</blockquote>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;display-name&gt;FilterDemo&lt;/display-name&gt;
    &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt;
    &lt;filter-class&gt;com.itheima.filter.FilterDemo&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<blockquote>
<p>在Servlet3.0里可以通过 @WebFilter注解配置</p>
</blockquote>
<h3 id="filter的生命周期">Filter的生命周期</h3>
<ul>
<li>创建</li>
</ul>
<blockquote>
<p>在服务器启动的时候就创建。</p>
</blockquote>
<ul>
<li>销毁</li>
</ul>
<blockquote>
<p>服务器停止的时候。</p>
</blockquote>
<h3 id="filter执行顺序">Filter执行顺序</h3>
<ol>
<li>
<p>客户端发出请求，先经过过滤器， 如果过滤器放行，那么才能到servlet</p>
</li>
<li>
<p>如果有多个过滤器， 那么他们会按照注册的映射顺序 来 排队。 只要有一个过滤器， 不放行，那么后面排队的过滤器以及咱们的servlet都不会收到请求。</p>
</li>
</ol>
<h3 id="filter细节">Filter细节</h3>
<ol>
<li>
<p>init方法的参数 FilterConfig , 可以用于获取filter在注册的名字 以及初始化参数。  其实这里的设计的初衷与ServletConfig是一样的。</p>
</li>
<li>
<p>如果想放行，那么在doFilter 方法里面操作，使用参数 chain</p>
</li>
</ol>
<pre><code class="language-java">chain.doFilter(request, response); 放行， 让请求到达下一个目标。
</code></pre>
<ol start="3">
<li>
<p><url-pattern>/*</url-pattern> 写法格式与servlet一样。</p>
<ol>
<li>
<p>全路径匹配  以 /  开始</p>
<pre><code> /LoginServlet
</code></pre>
</li>
<li>
<p>以目录匹配 以 / 开始  以 * 结束</p>
<p>/demo01/*</p>
</li>
<li>
<p>以后缀名匹配  以 * 开始 以后缀名结束</p>
<p>*.jsp  *.html *.do</p>
</li>
</ol>
<blockquote>
<p>注意：*号只能代表一段目录或者文件名，不能代替单词中的部分字母</p>
</blockquote>
</li>
<li>
<p>针对 dispatcher 设置</p>
<pre><code> ​	REQUEST ： 只要是请求过来，都拦截，默认就是REQUEST 
</code></pre>
<p>​	FORWARD : 只要是转发都拦截。<br>
​	ERROR ： 页面出错发生跳转<br>
​	INCLUDE ： 包含页面的时候就拦截。<br>
​</p>
</li>
</ol>
<h3 id="案例一-实现自动登录">案例一 实现自动登录</h3>
<ul>
<li>
<p>需求分析</p>
<ol>
<li>用户正常登录过一次以后，只要session不失效，用户可以直接访问网站中的其他页面，而不用再次登录。</li>
<li>如果没有登录或者session失效了， 那直接访问其他页面重定向到登录页面</li>
</ol>
</li>
</ul>
<h4 id="1-搭建环境">1. 搭建环境</h4>
<ol>
<li>搭建数据库</li>
<li>搭建页面</li>
</ol>
<h4 id="2-部分后台代码">2. 部分后台代码</h4>
<p>登录servlet代码</p>
<pre><code class="language-java">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

	try {
		String userName = request.getParameter(&quot;username&quot;);
		String password = request.getParameter(&quot;password&quot;);
		String autoLogin = request.getParameter(&quot;auto_login&quot;);
		UserBean user = new UserBean();
		user.setUsername(userName);
		user.setPassword(password);
		
		UserDao dao = new UserDaoImpl();
		UserBean userBean = dao.login(user);
		
		if(userBean != null){
			//成功了，进入首页
			request.getSession().setAttribute(&quot;userBean&quot;, userBean);
			response.sendRedirect(&quot;index.jsp&quot;);
		}else{
			//不成功...
			request.getRequestDispatcher(&quot;login.jsp&quot;).forward(request, response);
		}
		
	} catch (SQLException e) {
		e.printStackTrace();
	}
}
</code></pre>
<p>过滤器代码</p>
<ul>
<li>实现思路</li>
</ul>
<ol>
<li>
<p>先判断session是否有效， 如果失效了，直接把请求重定向到登录页，让用户完成手动登录</p>
</li>
<li>
<p>如果session没有失效，那么就从session中获取用户登录信息和数据库中做对比，如果正确就可以正常登录。否则重定向到登录页，让用户手动登录。</p>
</li>
</ol>
<pre><code class="language-java">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		
		HttpServletRequest req = (HttpServletRequest) request;
		HttpServletResponse resp = (HttpServletResponse) response;
		HttpSession session = req.getSession();
		
		// 如果session里没有登录信息，无法自动登录，重定向到登录页，让用户手动登录
		if(session.getAttribute(&quot;username&quot;) == null) {
			resp.sendRedirect(&quot;login.jsp&quot;);
			return;
		}
		
		String username = (String) session.getAttribute(&quot;username&quot;);
		String password = (String) session.getAttribute(&quot;password&quot;);
		
		// 检查session中的登录信息是否正确
		if(checkValid(username, password)) {
			chain.doFilter(request, response);
		}
	}
</code></pre>
<h2 id="总结">总结</h2>
<h3 id="listener-2">Listener</h3>
<pre><code>8个 

三种类型  
	针对三个作用域的创建和销毁
	针对三个作用域的值改变 【添加 | 替换 | 移除】
	针对session中的值 【钝化 活化】 ， 【绑定  解绑】

钝化 ( 序列化 ) 
	内存中的对象存储到硬盘 

	超时失效。 session销毁了。 

非正常关闭服务器， 钝化  。 正常关闭服务器 销毁

设置了session钝化策略：context.xml

活化 (反序列化)
	从硬盘里面读取到内存
</code></pre>
<p>应用场景：</p>
<p>ServletContextListner  ： 应用被部署的时候， 服务器加载这个项目的时候，做一些初始化工作， 任务调度。<br>
HttpSessionBindingListener	： 统计在线人数<br>
HttpSessionActivationListener  ： 钝化活化处理</p>
<h3 id="filter-2">Filter</h3>
<blockquote>
<p>使用频率更高</p>
</blockquote>
<ul>
<li>如果要写一个过滤器。</li>
</ul>
<blockquote>
<ol>
<li>定义一个类，实现接口 Filter</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>注册 web.xml . 与servlet相似。</li>
</ol>
</blockquote>
<ul>
<li>过滤器放行。</li>
</ul>
<blockquote>
<p>chain.doFilter(request, response);</p>
</blockquote>
<ul>
<li>
<p>过滤器生命周期</p>
<p>创建： 服务器加载这个项目的时候创建实例</p>
<p>销毁： 关闭服务器或者从服务器中移除项目的时候。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文件上传]]></title>
        <id>https://ysjhhhhhhh.github.io/post/wen-jian-shang-chuan</id>
        <link href="https://ysjhhhhhhh.github.io/post/wen-jian-shang-chuan">
        </link>
        <updated>2018-03-27T11:44:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前端页面">前端页面</h2>
<h3 id="必要条件">必要条件</h3>
<ol>
<li>需要有一个form表单</li>
<li>form表单需要设置以下几个属性：
<ol>
<li>action:  提交数据的目的地</li>
<li>method: 设置post</li>
<li>enctype: 设置成multipart/form-data</li>
</ol>
</li>
<li>form里需要至少有一个file域： &lt;input type=&quot;file&quot; name=&quot;xxx&quot; /&gt;</li>
</ol>
<h2 id="后端技术">后端技术</h2>
<p>所谓文件上传其实就是用流的方式，将文件从客户的电脑上通过网页中的表单， 以二进制流的方式，流到服务器的过程。</p>
<p>文件下载就是反过来， 将文件从服务器上通过二进制流的方式流到客户电脑上。</p>
<h3 id="servlet30上传方式">Servlet3.0上传方式</h3>
<h4 id="servlet30上传的核心-一个注解-一个接口">Servlet3.0上传的核心： 一个注解、一个接口</h4>
<p>注解：</p>
<p>@MultipartConfig： 开启Servlet文件上传功能</p>
<p>接口：</p>
<p>javax.servlet.http.Part：  封装了上传的文件相关的所有信息</p>
<h4 id="具体操作步骤">具体操作步骤</h4>
<ol>
<li>新建处理文件上传的Servlet，然后重写doPost方法</li>
<li>给Servlet添加@MultipartConfig注解，开启文件上传功能</li>
<li>Part part = request.getPart(&quot;input type='type' name的值&quot;);</li>
<li>part对象有两个作用：
<ol>
<li>可以获取到上传文件的所有信息，比如：文件名、大小、类型、文件流数据</li>
<li>可以直接将文件写到服务器   part.write(&quot;文件保存的路径&quot;);</li>
</ol>
</li>
</ol>
<h3 id="apache-commons-fileupload-上传方式">Apache Commons Fileupload 上传方式</h3>
<h4 id="用fileupload上传的核心就是一个接口-两个类">用fileupload上传的核心就是：一个接口、两个类</h4>
<p>接口： FileItem</p>
<p>封装了我们表单中的每个域的数据（可能是普通文本数据，也可能是上传的文件）</p>
<p>类：</p>
<p>DiskFileItemFactory：  用于创建文件上传对象的工厂</p>
<p>ServletFileupload： 文件上传对象</p>
<h4 id="具体操作步骤-2">具体操作步骤</h4>
<ol>
<li>
<p>需要添加依赖： commons-fileupload.jar、commons-io.jar</p>
</li>
<li>
<p>新建处理文件上传的Servlet，然后重写doPost方法</p>
</li>
<li>
<p>调用ServletFileupload对象的静态方法，判断请求是否是一个文件上传请求</p>
<pre><code class="language-java">if(!ServletFileupload.isMultipartContent(request)) {
    // 如果不是multipart请求，代表不是一个有效的文件上传请求， 下面的步骤都可以省略了
}
</code></pre>
</li>
<li>
<p>创建文件上传工厂对象：</p>
<pre><code class="language-java">DiskFileItemFactory factory = new DiskFileItemFactory();
// factory.set.... 可以设置相关参数
</code></pre>
</li>
<li>
<p>创建文件上传对象</p>
<pre><code class="language-java">ServletFileupload upload = new ServletFileupload(factory);
// upload.set.... 可以设置相关参数
</code></pre>
</li>
<li>
<p>用文件上传对象解析请求对象，然后获取解析后的所有FileItem</p>
<pre><code class="language-java">List&lt;FileItem&gt; fileItems = upload.parseRequest(request);
</code></pre>
</li>
<li>
<p>迭代处理每个FileItem</p>
<ol>
<li>文本信息的FileItem获取后进行相关的业务操作</li>
<li>文件类型的FileItem获取后，调用FileItem.write将文件写到服务器某个目录下。</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JSP & EL & JSTL]]></title>
        <id>https://ysjhhhhhhh.github.io/post/jsp-and-el-and-jstl</id>
        <link href="https://ysjhhhhhhh.github.io/post/jsp-and-el-and-jstl">
        </link>
        <updated>2018-03-26T05:57:33.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="jsp基础知识">JSP基础知识</h2>
<blockquote>
<p>JSP全称Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servlet设计，它是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。</p>
</blockquote>
<ul>
<li>什么是jsp</li>
</ul>
<blockquote>
<p>从用户角度看待 ，就是是一个网页 ， 从程序员角度看待 ， 其实是一个java类， 它继承了servlet，所以可以直接说jsp 就是一个Servlet.</p>
</blockquote>
<ul>
<li>为什么会有jsp?</li>
</ul>
<blockquote>
<p>html 多数情况下用来显示静态内容 ， 一成不变的。 但是有时候我们需要在网页上显示一些动态数据， 比如： 查询所有的学生信息， 根据姓名去查询具体某个学生。  这些动作都需要去查询数据库，然后在网页上显示。 html是不支持写java代码  ， jsp里面可以写java代码。</p>
</blockquote>
<ul>
<li>动态网页</li>
</ul>
<blockquote>
<p>所谓的动态网页，是指跟静态网页相对的一种网页编程技术。静态网页，随着html代码的生成，页面的内容和显示效果就基本上不会发生变化了——除非你修改页面代码。而动态网页则不然，页面代码虽然没有变，但是显示的内容却是可以随着时间、环境或者数据库操作的结果而发生改变的。</p>
<p>不要将动态网页和页面内容是否有动感混为一谈。这里说的动态网页，与网页上的各种动画、滚动字幕等视觉上的动态效果没有直接关系，动态网页也可以是纯文字内容的，也可以是包含各种动画的内容，这些只是网页具体内容的表现形式，无论网页是否具有动态效果，只要是采用了动态网站技术生成的网页都可以称为动态网页。</p>
</blockquote>
<h3 id="页面结构">页面结构</h3>
<h3 id="jsp声明变量-方法">JSP声明变量、方法</h3>
<pre><code class="language-jsp">&lt;%! 

  private int age = 0;
	
	public void sayHello() {
     out.println(&quot;Hello World!&quot;);
  }
  
%&gt;
</code></pre>
<h3 id="jsp表达式">JSP表达式</h3>
<pre><code class="language-jsp">&lt;%=age %&gt;
</code></pre>
<h3 id="java代码片段">Java代码片段</h3>
<pre><code class="language-jsp">&lt;%

age = age + 10;
sayHello();

%&gt;
</code></pre>
<h3 id="jsp注释">JSP注释</h3>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>语法</strong></th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&lt;%-- 注释 --%&gt;</td>
<td style="text-align:left">JSP注释，注释内容不会被发送至浏览器甚至不会被编译</td>
</tr>
<tr>
<td style="text-align:left"><!-- 注释 --></td>
<td style="text-align:left">HTML注释，通过浏览器查看网页源代码时可以看见注释内容</td>
</tr>
<tr>
<td style="text-align:left">&lt;%</td>
<td style="text-align:left">代表静态 &lt;%常量</td>
</tr>
<tr>
<td style="text-align:left">%\&gt;</td>
<td style="text-align:left">代表静态 %&gt; 常量</td>
</tr>
<tr>
<td style="text-align:left">\'</td>
<td style="text-align:left">在属性中使用的单引号</td>
</tr>
<tr>
<td style="text-align:left">\&quot;</td>
<td style="text-align:left">在属性中使用的双引号</td>
</tr>
</tbody>
</table>
<h3 id="jsp生命周期">JSP生命周期</h3>
<figure data-type="image" tabindex="1"><img src="img/jsp_life_cycle.jpg" alt="JSP生命周期"></figure>
<ul>
<li>
<p>编译阶段</p>
<p>当浏览器请求JSP页面时，JSP引擎会首先去检查是否需要编译这个文件。如果这个文件没有被编译过，或者在上次编译后被更改过，则编译这个JSP文件。</p>
<ul>
<li>解析JSP文件</li>
<li>将JSP文件转为Servlet</li>
<li>编译Servlet文件</li>
</ul>
</li>
<li>
<p>初始化阶段</p>
<p>加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法</p>
<pre><code class="language-java">// 可以重写此方法，添加初始化逻辑
public void _jspInit() {
}
</code></pre>
</li>
<li>
<p>执行阶段</p>
<p>调用与JSP对应的servlet实例的服务方法</p>
<pre><code class="language-java">public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)throws java.io.IOException, javax.servlet.ServletException {
  // 分发请求
  // doGet
  // doPost
}
</code></pre>
</li>
<li>
<p>销毁阶段</p>
<p>调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例</p>
<pre><code class="language-java">// 可以重写此方法，添加销毁操作
public void _jspDestroy() {
}
</code></pre>
</li>
</ul>
<h2 id="三大jsp指令">三大JSP指令</h2>
<h3 id="指令写法">指令写法</h3>
<p>&lt;%@ 指令名字 属性名=&quot;属性值&quot; %&gt;</p>
<h3 id="page指令">page指令</h3>
<ul>
<li>language</li>
</ul>
<blockquote>
<p>表明jsp页面中可以写java代码</p>
</blockquote>
<ul>
<li>contentType</li>
</ul>
<blockquote>
<p>其实即使说这个文件是什么类型，告诉浏览器我是什么内容类型，以及使用什么编码</p>
</blockquote>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
</code></pre>
<ul>
<li>
<p>pageEncoding  jsp内容编码</p>
</li>
<li>
<p>extends 用于指定jsp翻译成java文件后，继承的父类是谁，一般不用改。</p>
</li>
<li>
<p>import 导包使用的，一般不用手写。</p>
</li>
<li>
<p>session</p>
</li>
</ul>
<blockquote>
<p>值可选的有true or false .</p>
</blockquote>
<blockquote>
<p>用于控制在这个jsp页面里面，能够直接使用session对象。</p>
</blockquote>
<blockquote>
<p>具体的区别是，请看翻译后的java文件   如果该值是true , 那么在代码里面会有getSession（）的调用，如果是false :  那么就不会有该方法调用，也就是没有session对象了。在页面上自然也就不能使用session了。</p>
</blockquote>
<ul>
<li>errorPage</li>
</ul>
<blockquote>
<p>指的是错误的页面， 值需要给错误的页面路径</p>
</blockquote>
<ul>
<li>isErrorPage</li>
</ul>
<blockquote>
<p>上面的errorPage 用于指定错误的时候跑到哪一个页面去。 那么这个isErroPage , 就是声明某一个页面到底是不是错误的页面。</p>
</blockquote>
<h3 id="include指令">include指令</h3>
<blockquote>
<p>包含另外一个jsp的内容进来。</p>
</blockquote>
<pre><code>	&lt;%@ include file=&quot;other02.jsp&quot;%&gt;
</code></pre>
<ul>
<li>背后细节:</li>
</ul>
<blockquote>
<p>把另外一个页面的所有内容拿过来一起输出。 所有的标签元素都包含进来。</p>
</blockquote>
<h3 id="taglib">taglib</h3>
<p>作用：用于引入标签库</p>
<p>语法：&lt;%@ taglib prefix=&quot;&quot;  uri=&quot;&quot;%&gt;</p>
<pre><code>uri: 标签库路径
prefix : 标签库的别名  
</code></pre>
<h2 id="七大jsp-动作标签">七大JSP 动作标签</h2>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdn.net/20160715152725431?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="七大动作标签"></figure>
<h3 id="jspinclude">jsp:include</h3>
<pre><code class="language-jsp">&lt;jsp:include page=&quot;other02.jsp&quot;&gt;&lt;/jsp:include&gt;
</code></pre>
<blockquote>
<p>包含指定的页面， 这里是动态包含。 也就是不把包含的页面所有元素标签全部拿过来输出，而是把它的运行结果拿过来。</p>
</blockquote>
<h3 id="jspforward">jsp:forward</h3>
<pre><code class="language-jsp">&lt;!-- 不带参数跳转 --&gt;
&lt;jsp:forward page=&quot;test.jsp&quot;&gt;&lt;/jsp:forward&gt;
&lt;jsp:forward page=&quot;test.jsp&quot; /&gt;

&lt;!-- 带参数跳转 --&gt;
&lt;!-- 中文参数会出现乱码，因为底层是通过URIEncoding来编码的，默认取的是request.getCharsetEncoding() , 要解决此乱码问题，我们需要再跳转前设置 request.setCharsetEncoding(&quot;UTF-8&quot;);
--&gt;
&lt;% request.setCharsetEncoding(&quot;UTF-8&quot;); %&gt;
&lt;jsp:forward page=&quot;test.jsp&quot;&gt;
	&lt;jsp:param name=&quot;sname&quot; value=&quot;zhangsan&quot; /&gt;
&lt;/jsp:forward&gt;

&lt;!-- 如果这样写，中间必须加上param子标签 --&gt;
&lt;jsp:forward page=&quot;test.jsp&quot;&gt;
&lt;/jsp:forward&gt;
</code></pre>
<blockquote>
<p>前往哪一个页面。</p>
</blockquote>
<h3 id="jspparam">jsp:param</h3>
<blockquote>
<p>意思是： 在包含某个页面的时候，或者在跳转某个页面的时候，加入这个参数。</p>
</blockquote>
<pre><code class="language-jsp">&lt;jsp:forward page=&quot;other02.jsp&quot;&gt;
  &lt;jsp:param value=&quot;beijing&quot; name=&quot;address&quot;/&gt;
&lt;/jsp:forward&gt;

在other02.jsp中获取参数

&lt;br&gt;收到的参数是：&lt;br&gt;

&lt;%= request.getParameter(&quot;address&quot;)%&gt;
</code></pre>
<h3 id="jspusebeanjspsetpropertyjspgetproperty">jsp:useBean&amp;jsp:setProperty&amp;jsp:getProperty</h3>
<p>这组动作标签用于实例化JavaBean，并且设置、获取属性</p>
<pre><code class="language-jsp">&lt;jsp:useBean id=&quot;stu&quot; class=&quot;com.lanou3g.demo.bean.Student&quot; /&gt;
&lt;jsp:setProperty name=&quot;stu&quot; property=&quot;sname&quot; value=&quot;张三&quot; /&gt;
&lt;jsp:getProperty property=&quot;sname&quot; name=&quot;stu&quot;/&gt;
</code></pre>
<h2 id="jsp九大内置对象">JSP九大内置对象</h2>
<blockquote>
<p>所谓内置对象，就是我们可以直接在jsp页面中使用这些对象。 不用创建。</p>
</blockquote>
<h3 id="pagecontext-javaxservletjsppagecontext">pageContext 【javax.servlet.jsp.PageContext】</h3>
<p>作用：为JSP页面包装页面的上下文。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>forward</td>
<td>重定向到另一页面或Servlet组件</td>
</tr>
<tr>
<td>getAttribute</td>
<td>获取某范围中指定名字的属性值</td>
</tr>
<tr>
<td>findAttribute</td>
<td>按范围搜索指定名字的属性</td>
</tr>
<tr>
<td>removeAttribute</td>
<td>删除某范围中指定名字的属性</td>
</tr>
<tr>
<td>setAttribute</td>
<td>设定某范围中指定名字的属性值</td>
</tr>
<tr>
<td>getException</td>
<td>返回当前异常对象</td>
</tr>
<tr>
<td>getRequest</td>
<td>返回当前请求对象</td>
</tr>
<tr>
<td>getResponse</td>
<td>返回当前响应对象</td>
</tr>
<tr>
<td>getServletConfig</td>
<td>返回当前页面的ServletConfig对象</td>
</tr>
<tr>
<td>getServletContext</td>
<td>返回所有页面共享的ServletContext对象</td>
</tr>
<tr>
<td>getSession</td>
<td>返回当前页面的会话对象</td>
</tr>
</tbody>
</table>
<h3 id="request-javaxservlethttphttpservletrequest">request   【javax.servlet.http.HttpServletRequest】</h3>
<p>作用：向服务端请求数据</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>isUserInRole</td>
<td>判断认证后的用户是否属于某一成员组</td>
</tr>
<tr>
<td>getAttribute</td>
<td>获取指定属性的值,如该属性值不存在返回Null</td>
</tr>
<tr>
<td>getAttributeNames</td>
<td>获取所有属性名的集合</td>
</tr>
<tr>
<td>getCookies</td>
<td>获取所有Cookie对象</td>
</tr>
<tr>
<td>getCharacterEncoding</td>
<td>获取请求的字符编码方式</td>
</tr>
<tr>
<td>getContentLength</td>
<td>返回请求正文的长度,如不确定返回-1</td>
</tr>
<tr>
<td>getHeader</td>
<td>获取指定名字报头值</td>
</tr>
<tr>
<td>getHeaders</td>
<td>获取指定名字报头的所有值,一个枚举</td>
</tr>
<tr>
<td>getHeaderNames</td>
<td>获取所有报头的名字,一个枚举</td>
</tr>
<tr>
<td>getInputStream</td>
<td>返回请求输入流,获取请求中的数据</td>
</tr>
<tr>
<td>getMethod</td>
<td>获取客户端向服务器端传送数据的方法</td>
</tr>
<tr>
<td>getParameter</td>
<td>获取指定名字参数值</td>
</tr>
<tr>
<td>getParameterNames</td>
<td>获取所有参数的名字,一个枚举</td>
</tr>
<tr>
<td>getParameterValues</td>
<td>获取指定名字参数的所有值</td>
</tr>
<tr>
<td>getProtocol</td>
<td>获取客户端向服务器端传送数据的协议名称</td>
</tr>
<tr>
<td>getQueryString</td>
<td>获取以get方法向服务器传送的查询字符串</td>
</tr>
<tr>
<td>getRequestURI</td>
<td>获取发出请求字符串的客户端地址</td>
</tr>
<tr>
<td>getRemoteAddr</td>
<td>获取客户端的IP地址</td>
</tr>
<tr>
<td>getRemoteHost</td>
<td>获取客户端的名字</td>
</tr>
<tr>
<td>getSession</td>
<td>获取和请求相关的会话</td>
</tr>
<tr>
<td>getServerName</td>
<td>获取服务器的名字</td>
</tr>
<tr>
<td>getServerPath</td>
<td>获取客户端请求文件的路径</td>
</tr>
<tr>
<td>getServerPort</td>
<td>获取服务器的端口号</td>
</tr>
<tr>
<td>removeAttribute</td>
<td>删除请求中的一个属性</td>
</tr>
<tr>
<td>setAttribute</td>
<td>设置指定名字参数值</td>
</tr>
</tbody>
</table>
<h3 id="session-javaxservlethttphttpsession">session   【javax.servlet.http.HttpSession】</h3>
<p>作用：用来保存每个用户的信息,以便跟踪每个用户的操作状态</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getAttribute</td>
<td>获取指定名字的属性</td>
</tr>
<tr>
<td>getAttributeNames</td>
<td>获取session中全部属性名字,一个枚举</td>
</tr>
<tr>
<td>getCreationTime</td>
<td>返回session的创建时间</td>
</tr>
<tr>
<td>getId</td>
<td>获取会话标识符</td>
</tr>
<tr>
<td>getLastAccessedTime</td>
<td>返回最后发送请求的时间</td>
</tr>
<tr>
<td>getMaxInactiveInterval</td>
<td>返回session对象的生存时间单位千分之一秒</td>
</tr>
<tr>
<td>invalidate</td>
<td>销毁session对象</td>
</tr>
<tr>
<td>isNew</td>
<td>每个请求是否会产生新的session对象</td>
</tr>
<tr>
<td>removeAttribute</td>
<td>删除指定名字的属性</td>
</tr>
<tr>
<td>setAttribute</td>
<td>设定指定名字的属性值</td>
</tr>
</tbody>
</table>
<h3 id="application-javaxservletservletcontext">application  【javax.servlet.ServletContext】</h3>
<p>作用：对应ServletContext对象， 在整个应用的生命周期内共享数据</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getAttribute</td>
<td>获取应用对象中指定名字的属性值</td>
</tr>
<tr>
<td>getAttributeNames</td>
<td>获取应用对象中所有属性的名字,一个枚举</td>
</tr>
<tr>
<td>getInitParameter</td>
<td>返回应用对象中指定名字的初始参数值</td>
</tr>
<tr>
<td>getServletInfo</td>
<td>返回Servlet编译器中当前版本信息</td>
</tr>
<tr>
<td>setAttribute</td>
<td>设置应用对象中指定名字的属性值</td>
</tr>
</tbody>
</table>
<h3 id="out-javaxservletjspjspwriter">out		 【javax.servlet.jsp.JspWriter】</h3>
<p>作用：向客户端输出数据</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>print或println</td>
<td>输出数据</td>
</tr>
<tr>
<td>newLine</td>
<td>输出换行字符</td>
</tr>
<tr>
<td>flush</td>
<td>输出缓冲区数据</td>
</tr>
<tr>
<td>close</td>
<td>关闭输出流</td>
</tr>
<tr>
<td>clear</td>
<td>清除缓冲区中数据,但不输出到客户端</td>
</tr>
<tr>
<td>clearBuffer</td>
<td>清除缓冲区中数据,输出到客户端</td>
</tr>
<tr>
<td>getBufferSize</td>
<td>获得缓冲区大小</td>
</tr>
<tr>
<td>getRemaining</td>
<td>获得缓冲区中没有被占用的空间</td>
</tr>
<tr>
<td>isAutoFlush</td>
<td>是否为自动输出</td>
</tr>
</tbody>
</table>
<h3 id="response-javaxservlethttphttpservletresponse">response  【javax.servlet.http.HttpServletResponse】</h3>
<p>作用：封装了jsp产生的响应,然后被发送到客户端以响应客户的请求</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>addCookie</td>
<td>添加一个Cookie对象</td>
</tr>
<tr>
<td>addHeader</td>
<td>添加Http文件指定名字头信息</td>
</tr>
<tr>
<td>containsHeader</td>
<td>判断指定名字Http文件头信息是否存在</td>
</tr>
<tr>
<td>encodeURL</td>
<td>使用sessionid封装URL</td>
</tr>
<tr>
<td>flushBuffer</td>
<td>强制把当前缓冲区内容发送到客户端</td>
</tr>
<tr>
<td>getBufferSize</td>
<td>返回缓冲区大小</td>
</tr>
<tr>
<td>getOutputStream</td>
<td>返回到客户端的输出流对象</td>
</tr>
<tr>
<td>sendError</td>
<td>向客户端发送错误信息</td>
</tr>
<tr>
<td>sendRedirect</td>
<td>把响应发送到另一个位置进行处理</td>
</tr>
<tr>
<td>setContentType</td>
<td>设置响应的MIME类型</td>
</tr>
<tr>
<td>setHeader</td>
<td>设置指定名字的Http文件头信息</td>
</tr>
</tbody>
</table>
<h3 id="exception-javalangthrowable">exception  【java.lang.Throwable】</h3>
<p>被调用的错误页面的结果,只有在错误页面中才可使用,</p>
<p>即在页面指令中设置:&lt;%@page isErrorPage=“true”%&gt;</p>
<h3 id="page-javalangobject">page	 【java.lang.Object】</h3>
<p>它代表JSP被编译成Servlet,可以使用它来调用Servlet类中所定义的方法</p>
<h3 id="config-javaxservletservletconfig">config 【javax.servlet.ServletConfig】</h3>
<p>作用：表示Servlet的配置,当一个Servlet初始化时,容器把某些信息通过此对象传递给这个Servlet</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getServletContext</td>
<td>返回所执行的Servlet的环境对象</td>
</tr>
<tr>
<td>getServletName</td>
<td>返回所执行的Servlet的名字</td>
</tr>
<tr>
<td>getInitParameter</td>
<td>返回指定名字的初始参数值</td>
</tr>
<tr>
<td>getInitParameterNames</td>
<td>返回该JSP中所有的初始参数名,一个枚举</td>
</tr>
</tbody>
</table>
<h2 id="四个作用域">四个作用域</h2>
<blockquote>
<p>表示这些对象可以存值，他们的取值范围有限定。  setAttribute   和  getAttribute</p>
</blockquote>
<h3 id="使用作用域来存储数据">使用作用域来存储数据</h3>
<pre><code class="language-jsp">&lt;%
pageContext.setAttribute(&quot;name&quot;, &quot;page&quot;);
request.setAttribute(&quot;name&quot;, &quot;request&quot;);
session.setAttribute(&quot;name&quot;, &quot;session&quot;);
application.setAttribute(&quot;name&quot;, &quot;application&quot;);
%&gt;
</code></pre>
<h3 id="取出四个作用域中的值">取出四个作用域中的值</h3>
<pre><code class="language-jsp">&lt;%=pageContext.getAttribute(&quot;name&quot;)%&gt;
&lt;%=request.getAttribute(&quot;name&quot;)%&gt;
&lt;%=session.getAttribute(&quot;name&quot;)%&gt;
&lt;%=application.getAttribute(&quot;name&quot;)%&gt;
</code></pre>
<p>作用域范围大小：</p>
<blockquote>
<p>pageContext -- request --- session -- application</p>
</blockquote>
<h3 id="四个作用域的区别">四个作用域的区别</h3>
<ul>
<li>pageContext 【PageContext】</li>
</ul>
<blockquote>
<p>作用域仅限于当前的页面。</p>
<p>除了可以存储数据， 还可以获取其他8个内置对象</p>
</blockquote>
<ul>
<li>request 【HttpServletRequest】</li>
</ul>
<blockquote>
<p>作用域仅限于一次请求， 只要服务器对该请求做出了响应。 这个域中存的值就没有了。</p>
</blockquote>
<ul>
<li>session 【HttpSession】</li>
</ul>
<blockquote>
<p>作用域限于一次会话（多次请求与响应） 当中。</p>
</blockquote>
<ul>
<li>application 【ServletContext】</li>
</ul>
<blockquote>
<p>整个工程都可以访问， 服务器关闭后就不能访问了。</p>
</blockquote>
<h2 id="el表达式">EL表达式</h2>
<blockquote>
<p>是为了简化咱们的jsp代码，具体一点就是为了简化在jsp里面写的那些java代码。</p>
</blockquote>
<ul>
<li>
<p>语法结构</p>
<p>${expression }</p>
</li>
<li>
<p>从指定的作用域取参数</p>
<p>${requestScope.表达式}</p>
</li>
</ul>
<blockquote>
<p>如果从作用域中取值，会先从小的作用域开始取，如果没有，就往下一个作用域取。  一直把四个作用域取完都没有， 就没有显示。</p>
</blockquote>
<h3 id="如何使用">如何使用</h3>
<ol>
<li>取出4个作用域中存放的值。</li>
</ol>
<pre><code class="language-jsp">&lt;%
pageContext.setAttribute(&quot;name&quot;, &quot;page&quot;);
request.setAttribute(&quot;name&quot;, &quot;request&quot;);
session.setAttribute(&quot;name&quot;, &quot;session&quot;);
application.setAttribute(&quot;name&quot;, &quot;application&quot;);
%&gt;

按普通手段取值&lt;br&gt;

&lt;%= pageContext.getAttribute(&quot;name&quot;)%&gt;
&lt;%= request.getAttribute(&quot;name&quot;)%&gt;
&lt;%= session.getAttribute(&quot;name&quot;)%&gt;
&lt;%= application.getAttribute(&quot;name&quot;)%&gt;

&lt;br&gt;使用EL表达式取出作用域中的值&lt;br&gt;

${ pageScope.name }
${ requestScope.name }
${ sessionScope.name }
${ applicationScope.name }
</code></pre>
<ol start="2">
<li>如果域中所存的是数组</li>
</ol>
<pre><code class="language-jsp">&lt;%
String [] a = {&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;};
pageContext.setAttribute(&quot;array&quot;, a);
%&gt;
      		
使用EL表达式取出作用域中数组的值&lt;br&gt;

${array[0] } , ${array[1] },${array[2] },${array[3] }
</code></pre>
<ol start="3">
<li>如果域中锁存的是集合</li>
</ol>
<pre><code class="language-jsp">&lt;%
List&lt;String&gt; list =  new ArrayList&lt;&gt;();
list.add(&quot;aa&quot;);
list.add(&quot;bb&quot;);
list.add(&quot;cc&quot;);
list.add(&quot;dd&quot;);

pageContext.setAttribute(&quot;li&quot;, list);
%&gt;
使用EL表达式取出作用域中集合的值&lt;br&gt;

${list[0] } , ${li[1] },${li[2] },${li[3] }

</code></pre>
<ol start="4">
<li>取出Map集合的值</li>
</ol>
<pre><code class="language-java">&lt;%
Map map = new HashMap();
map.put(&quot;name&quot;, &quot;zhangsna&quot;);
map.put(&quot;age&quot;,18);
map.put(&quot;address&quot;,&quot;北京..&quot;);

map.put(&quot;address.aa&quot;,&quot;深圳..&quot;);

pageContext.setAttribute(&quot;map&quot;, map);
%&gt;
使用EL表达式取出作用域中Map的值&lt;br&gt;

&lt;!-- map的key中有特殊字符时，我们必须用[]这种方式来获取值 --&gt;
${map.name } , ${map.age } , ${map.address }  , ${map[&quot;address.aa&quot;] }
</code></pre>
<h2 id="el表达式-的11个内置对象">EL表达式 的11个内置对象。</h2>
<p>${ 对象名.成员 }</p>
<ul>
<li>pageContext</li>
</ul>
<p>作用域相关对象</p>
<ul>
<li>pageScope</li>
<li>requestScope</li>
<li>sessionScope</li>
<li>applicationScope</li>
</ul>
<p>头信息相关对象</p>
<ul>
<li>header</li>
<li>headerValues</li>
</ul>
<p>参数信息相关对象</p>
<ul>
<li>
<p>param</p>
</li>
<li>
<p>paramValues</p>
</li>
<li>
<p>cookie</p>
</li>
</ul>
<p>全局初始化参数</p>
<ul>
<li>initParam</li>
</ul>
<h2 id="jstl">JSTL</h2>
<blockquote>
<p>全称 ： JSP Standard Tag Library  jsp标准标签库</p>
</blockquote>
<blockquote>
<p>简化jsp的代码编写。 替换 &lt;%%&gt; 写法。 一般与EL表达式配合</p>
</blockquote>
<h3 id="怎么使用">怎么使用</h3>
<ol>
<li>
<p>导入jar文件到工程的WebContent/Web-Inf/lib  jstl.jar standard.jar</p>
</li>
<li>
<p>在jsp页面上，使用taglib 指令，来引入标签库</p>
</li>
</ol>
<blockquote>
<p>比如引入JSTL核心标签库</p>
</blockquote>
<pre><code class="language-jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
</code></pre>
<ol start="3">
<li>注意： 如果想支持 EL表达式，那么引入的标签库必须选择1.1以上的版本，1.0的版本不支持EL表达式。</li>
</ol>
<h3 id="jstl标签分类">JSTL标签分类</h3>
<h4 id="核心标签最核心-最重用">核心标签(最核心、最重用)</h4>
<pre><code class="language-jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
</code></pre>
<ul>
<li>
<p>表达式控制标签</p>
<ul>
<li>out</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>输出值，如果是常量直接赋值， 如果是变量需要通过EL表达式取值</td>
<td>是</td>
</tr>
<tr>
<td>default</td>
<td>当value为null时， 输出default属性配置的值</td>
<td>否</td>
</tr>
<tr>
<td>escapeXml</td>
<td>是否转义XML特殊字符，取值true/false， 默认是true</td>
<td>否</td>
</tr>
</tbody>
</table>
<ul>
<li>set</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>搭配var属性使用，设置变量的值；搭配property和target使用，设置javabean属性的值</td>
<td>是</td>
</tr>
<tr>
<td>var</td>
<td>定义的变量名称</td>
<td>否</td>
</tr>
<tr>
<td>scope</td>
<td>变量保存到的作用域，默认是pageContext</td>
<td>否</td>
</tr>
<tr>
<td>target</td>
<td>给javabean设置属性，指定那个javabean。需配合&lt;jsp:useBean&gt;标签和property、value属性使用</td>
<td>否</td>
</tr>
<tr>
<td>property</td>
<td>设置javabean的哪个属性的值</td>
<td>否</td>
</tr>
</tbody>
</table>
<ul>
<li>remove</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>var</td>
<td>删除指定的变量，只能删除变量，不能删除javabean的属性</td>
<td>是</td>
</tr>
</tbody>
</table>
<ul>
<li>catch</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>var</td>
<td>存储错误信息</td>
<td>是</td>
</tr>
</tbody>
</table>
<pre><code class="language-jsp">&lt;%-- &lt;c:catch&gt;用于包裹其他容易出错的标签，比如 --%&gt;
&lt;c:catch var=&quot;error&quot;&gt;
  &lt;!-- aa为没有实例化的javabean --&gt;
	&lt;c:set target=&quot;aa&quot; property=&quot;name&quot; value=&quot;zhangsan&quot; /&gt;
&lt;/c:catch&gt;
&lt;c:out value=&quot;${error}&quot; /&gt;
</code></pre>
</li>
<li>
<p>流程控制标签</p>
<ul>
<li>if</li>
</ul>
<pre><code class="language-jsp">&lt;c:if test=&quot;${income &gt; 8000}&quot; var=&quot;ret&quot;&gt;  
  &lt;p&gt;My income is: &lt;c:out value=&quot;${income}&quot;/&gt;&lt;p&gt;  
&lt;/c:if&gt;
&lt;!-- var属性ret存储的是test运算的结果 --&gt;
${ret}
</code></pre>
<ul>
<li>choose&amp;when&amp;otherwise</li>
</ul>
<pre><code class="language-jsp">&lt;c:choose&gt;  
    &lt;c:when test=&quot;${income &lt;= 1000}&quot;&gt;  
       Income is not good.  
    &lt;/c:when&gt;  
    &lt;c:when test=&quot;${income &gt; 10000}&quot;&gt;  
        Income is very good.  
    &lt;/c:when&gt;  
    &lt;c:otherwise&gt;  
       Income is undetermined...  
    &lt;/c:otherwise&gt;  
&lt;/c:choose&gt;  
</code></pre>
<ul>
<li>forEach</li>
</ul>
<pre><code class="language-jsp">&lt;%
 List&lt;String&gt; students = new ArrayList&lt;&gt;();
 students.add(&quot;张三&quot;);
 students.add(&quot;李四&quot;);
 students.add(&quot;王五&quot;);
 students.add(&quot;赵六&quot;);
 
 request.setAttribute(&quot;stus&quot;, students);
%&gt;

&lt;!-- forEach遍历全部元素 --&gt;
&lt;c:forEach var=&quot;stu&quot; items=&quot;${stus}&quot;&gt;
	&lt;c:out value=&quot;${stu}&quot; /&gt; &lt;br /&gt;
&lt;/c:forEach&gt;

&lt;!-- forEach遍历部分元素 --&gt;
&lt;c:forEach var=&quot;stu&quot; items=&quot;${stus}&quot; begin=&quot;1&quot; end=&quot;3&quot;&gt;
	&lt;c:out value=&quot;${stu}&quot; /&gt; &lt;br /&gt;
&lt;/c:forEach&gt;

&lt;!-- forEach遍历部分元素，指定步长 --&gt;
&lt;c:forEach var=&quot;stu&quot; items=&quot;${stus}&quot; begin=&quot;1&quot; step=&quot;2&quot;&gt;
	&lt;c:out value=&quot;${stu}&quot; /&gt; &lt;br /&gt;
&lt;/c:forEach&gt;

&lt;!-- 用法四：部分遍历并带状态 --&gt;
&lt;c:forEach var=&quot;stu&quot; items=&quot;${stus}&quot; begin=&quot;1&quot; end=&quot;3&quot; varStatus=&quot;status&quot;&gt;
&lt;c:out value=&quot;${stu}——四个属性：&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value=&quot;index属性：${status.index}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value=&quot;count属性：${status.count}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value=&quot;first属性：${status.first}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value=&quot;last属性：${status.last}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value=&quot;----------&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;/c:forEach&gt;

&lt;!-- varStatus变量的几个属性：index从0开始；count从1开始；first是否第一个（boolean）；last是否最后一个（boolean）。  --&gt;

</code></pre>
<ul>
<li>forTokens</li>
</ul>
<pre><code class="language-jsp">&lt;c:forTokens items=&quot;zhangsan,lisi,wangwu&quot; delims=&quot;,&quot; var=&quot;item&quot;&gt;
	&lt;c:out value=&quot;${item}&quot; /&gt; &lt;br /&gt;
&lt;/c:forTokens&gt;

&lt;!-- 另外forTokens也支持begin、end、step、varStatus几个属性，用法和forEach一样 --&gt;
</code></pre>
</li>
<li>
<p>URL操作标签</p>
<ul>
<li>url</li>
</ul>
<pre><code class="language-jsp"> &lt;c:url value=&quot;http://localhost:8080/Test/index.jsp&quot; var=&quot;newUrl&quot; scope=&quot;session&quot;&gt;
 		&lt;c:param name=&quot;username&quot;&gt;zhangsan&lt;/c:param&gt;
  		&lt;c:param name=&quot;password&quot;&gt;a123456&lt;/c:param&gt;
 &lt;/c:url&gt;
	&lt;a href=&quot;${newUrl}&quot;&gt;New URL&lt;/a&gt;
</code></pre>
<ul>
<li>redirect</li>
</ul>
<pre><code class="language-jsp">  	&lt;c:redirect url=&quot;www.baidu.com&quot;&gt;
  		&lt;c:param name=&quot;username&quot;&gt;zhangsan&lt;/c:param&gt;
  		&lt;c:param name=&quot;password&quot;&gt;a123456&lt;/c:param&gt;
  	&lt;/c:redirect&gt;
</code></pre>
<ul>
<li>param</li>
</ul>
<p>一般作为其他标签的子标签使用，为其附加参数</p>
</li>
</ul>
<h4 id="格式化标签">格式化标签</h4>
<pre><code class="language-jsp">&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;
</code></pre>
<ul>
<li>格式化时间</li>
</ul>
<pre><code class="language-jsp">&lt;%
	Date date = new Date();
	pageContext.setAttribute(&quot;d&quot;, date);
%&gt;
&lt;fmt:formatDate value=&quot;${d }&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;
</code></pre>
<ul>
<li>格式化数字</li>
</ul>
<pre><code class="language-jsp">&lt;%
	double d1 = 3.5;
	double d2 = 4.4; 
	pageContext.setAttribute(&quot;d1&quot;, d1);
	pageContext.setAttribute(&quot;d2&quot;, d2);
%&gt;
&lt;fmt:formatNumber value=&quot;${d1 }&quot; pattern=&quot;0.00&quot;/&gt;&lt;br/&gt;
&lt;fmt:formatNumber value=&quot;${d2 }&quot; pattern=&quot;#.##&quot;/&gt;
</code></pre>
<h4 id="sql标签">SQL标签</h4>
<pre><code class="language-jsp">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/sql&quot; prefix=&quot;sql&quot;%&gt;  
</code></pre>
<ul>
<li>setDataSource</li>
</ul>
<pre><code class="language-jsp">&lt;sql:setDataSource var=&quot;db&quot; driver=&quot;com.mysql.jdbc.Driver&quot;  
     url=&quot;jdbc:mysql://localhost/test&quot;  
     user=&quot;root&quot;  password=&quot;1234&quot;/&gt;  
</code></pre>
<ul>
<li>query</li>
</ul>
<pre><code class="language-jsp">&lt;sql:query dataSource=&quot;${db}&quot; var=&quot;rs&quot;&gt;  
SELECT * from Students;  
&lt;/sql:query&gt;  
</code></pre>
<ul>
<li>update</li>
</ul>
<pre><code class="language-jsp">&lt;sql:update dataSource=&quot;${db}&quot; var=&quot;count&quot;&gt;  
INSERT INTO Students VALUES (154,'Nasreen', 'jaha', 25);  
&lt;/sql:update&gt;  
</code></pre>
<ul>
<li>param &amp; dateParam</li>
</ul>
<pre><code class="language-jsp">&lt;%
Date DoB = new Date(&quot;2000/10/16&quot;);
int studentId = 151;
%&gt;
&lt;sql:update dataSource=&quot;${db}&quot; var=&quot;count&quot;&gt;
   UPDATE Student SET dob = ? WHERE Id = ?
   &lt;sql:dateParam value=&quot;&lt;%=DoB%&gt;&quot; type=&quot;DATE&quot; /&gt;
   &lt;sql:param value=&quot;&lt;%=studentId%&gt;&quot; /&gt;
&lt;/sql:update&gt;

</code></pre>
<ul>
<li>transaction</li>
</ul>
<pre><code class="language-jsp">&lt;sql:transaction dataSource=&quot;${db}&quot;&gt;  
   &lt;sql:update var=&quot;count&quot;&gt;  
      UPDATE Student SET First_Name = 'Suraj' WHERE Id = 150  
   &lt;/sql:update&gt;  
   &lt;sql:update var=&quot;count&quot;&gt;  
      UPDATE Student SET Last_Name= 'Saifi' WHERE Id = 153  
   &lt;/sql:update&gt;  
   &lt;sql:update var=&quot;count&quot;&gt;  
     INSERT INTO Student   
     VALUES (154,'Supriya', 'Jaiswal', '1995/10/6');  
   &lt;/sql:update&gt;  
&lt;/sql:transaction&gt;  
</code></pre>
<h4 id="xml标签">XML标签</h4>
<p>用的不多，这里不在列举</p>
<p>ps: 更多详细内容，参见：<a href="https://www.javatpoint.com/jstl">https://www.javatpoint.com/jstl</a></p>
<h2 id="总结">总结：</h2>
<ul>
<li>
<p>JSP</p>
<p>三大指令</p>
<pre><code>  	page
  	include
  	taglib
  
  六个动作标签
  	&lt;jsp:include&gt;
  	&lt;jsp:forward&gt;
  	&lt;jsp:param&gt;
</code></pre>
<p>​		jsp:useBean</p>
<p>​		jsp:setProperty</p>
<p>​		jsp:getProperty</p>
<p>九个内置对象</p>
<pre><code>  四个作用域
  	pageContext
  	request
  	session
  	application

  out
  exception
  response
  page
  config
</code></pre>
</li>
</ul>
<p>​</p>
<ul>
<li>
<p>EL</p>
<p>${ 表达式 }</p>
<p>取4个作用域中的值</p>
<p>${ name }</p>
<p>有11个内置对象。</p>
<p>pageContext</p>
<p>pageScope<br>
requestScope<br>
sessionScope<br>
applicationScope</p>
<p>header<br>
headerValues</p>
<p>param<br>
paramValues</p>
<p>cookie<br>
initParam</p>
</li>
<li>
<p>JSTL</p>
</li>
</ul>
<blockquote>
<p>使用1.1的版本， 支持EL表达式， 1.0不支持EL表达式</p>
</blockquote>
<blockquote>
<p>拷贝jar包， 通过taglib 去引入标签库</p>
</blockquote>
<pre><code>&lt;c:set&gt;
&lt;c:if&gt;
&lt;c:forEach&gt;
</code></pre>
<p>​</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据分页]]></title>
        <id>https://ysjhhhhhhh.github.io/post/shu-ju-fen-ye</id>
        <link href="https://ysjhhhhhhh.github.io/post/shu-ju-fen-ye">
        </link>
        <updated>2018-03-25T12:35:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="核心参数">核心参数</h2>
<ul>
<li>总数据条数
<ul>
<li>来源： 后台自己从数据库中查询而来</li>
</ul>
</li>
<li>每页展示条数(pageSize)
<ul>
<li>来源：从前端页面传递过来</li>
</ul>
</li>
<li>总页数（计算得知）
<ul>
<li>来源： 根据总条数和每页展示数量计算得来</li>
</ul>
</li>
<li>当前展示的页码（currentPage)
<ul>
<li>来源：从前端页面传递过来</li>
</ul>
</li>
<li>每页要展示的数据本身
<ul>
<li>来源：后台自己从数据库中查询而来</li>
</ul>
</li>
</ul>
<h2 id="物理分页">物理分页</h2>
<h3 id="概述">概述</h3>
<p>所谓的物理分页其实就是直接通过数据库来实现返回一部分数据。每次只从数据库中查询一页的数据。与之相对应的还有逻辑分页。</p>
<h3 id="mysql中实现语句">Mysql中实现语句</h3>
<pre><code class="language-sql">    SELECT * FROM `shop` LIMIT (currentPage-1)*pageSize, pageSize;
</code></pre>
<h2 id="逻辑分页">逻辑分页</h2>
<p>所谓的逻辑分页其实就是通过内存来进行分页。具体来说，首次查询数据时，将所有数据都取出放到内存中，展示其他页的数据时，在内存中实现数据的截取，展示。</p>
<h2 id="两种分页的对比">两种分页的对比</h2>
<ol>
<li>物理分页节约内存空间，效率相比逻辑分页理论上效率低一些。试用场景：数据量大的时候。</li>
<li>逻辑分页占用空间大，理论上分页性能高一些。试用场景：数据量小，访问用户多。要处理缓存数据同步的问题。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Apache Tomcat下载、安装、配置]]></title>
        <id>https://ysjhhhhhhh.github.io/post/apache-tomcat-xia-zai-an-zhuang-pei-zhi</id>
        <link href="https://ysjhhhhhhh.github.io/post/apache-tomcat-xia-zai-an-zhuang-pei-zhi">
        </link>
        <updated>2018-03-21T02:32:15.000Z</updated>
        <content type="html"><![CDATA[<p>Apache Tomcat下载、安装、配置图文教程自我心得<br>
1、Tomcat下载<br>
（1）Tomcat官网：<a href="http://tomcat.apache.org/">Tomcat官方网址</a>，可以在此处下载Tomcat。<br>
（2）点击左侧Download下的对应版本。<br>
注意有zip和exe两种格式的，zip是免安装版的，exe是安装版。同时观察自己的电脑是64位系统还是32位系统。<br>
例如进入：<a href="http://tomcat.apache.org/download-90.cgi">Tomcat 9 版本下载页面</a>，下滑，到core处选择自己需要的版本，如图所示：<br>
<img src="https://img-blog.csdn.net/20170227190709370?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>我的电脑是64位，可以直接选择32-bit/64-bit Windows Service installer(pgp,md5,sha1)，点击即可选择下载位置，点击下载，此处选择下载的是exe安装版本。若想下载免安装版本的，选择下载64-bit Windows zip(pgp,md5,sha1)。<br>
2、Tomcat安装<br>
2.1 exe版本安装<br>
1、从下载位置双击下载的zip<br>
<img src="https://img-blog.csdn.net/20170227220255334?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>点击next；<br>
2、同意安装协议：即点击I Agree<br>
<img src="https://img-blog.csdn.net/20170227220536666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>3、点开Tomcat，选中Service，以后将可以在管理的服务中启动和关闭Tomcat（也可以默认，不改变配置），点击next<br>
<img src="https://img-blog.csdn.net/20170227220858858?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>4、出现管理提示框，要求输入端口和管理密码，保持默认设置就行。默认的端口号就是8080，这里一般不用设置。点击Next。<br>
<img src="https://img-blog.csdn.net/20170227221248471?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>5、点击Next后会出现下图，它会自动找到JRE位置，如果用户没有安装JRE，可以修改指向JDK目录（很多用户安装后无法编译JSP，就是这里没找到JRE，请务必先要安装JDK，并把这个目录正确指向JRE或者JDK的目录）。<br>
<img src="https://img-blog.csdn.net/20170227221856106?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>6、点击next，之后会出现Tomcat安装路径选择，一般默认安装到C盘，可以直接把C改成D，没有的文件夹会自动创建。修改完毕后点击Install。<br>
<img src="https://img-blog.csdn.net/20170227222133335?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>7、安装完毕，点击finish。<br>
<img src="https://img-blog.csdn.net/20170227222413424?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>8、打开浏览器 键入 <a href="http://localhost:8080/">http://localhost:8080</a> 进入如下页面则表示安装成功：<br>
<img src="https://img-blog.csdn.net/20170227222804476?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbmdwYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>2.2 zip版（免安装版本）<br>
直接解压缩，找到目录bin下的startup.bat，启动Tomcat；shutdown.bat：关闭Tomcat。<br>
3、Tomcat配置<br>
配置Tomcat之前要保证jdk已经配置完成。<br>
右击，计算机——属性——高级系统设置——打开环境变量的配置窗口，在系统环境变量一栏点击新建。变量名为TOMCAT_HOME，变量值为Tomcat安装目录，此处为：D:\Program Files (x86)\Apache Software Foundation\Tomcat 9.0。点击确定即可。<br>
在另外一篇博客中这样介绍Tomcat配置过程：<br>
Tomcat环境变量配置：<br>
如果你的Tomcat安装在C盘里，如：C:\Program Files\Apache Software Foundation\Tomcat 8.0（在这里切记一下，安装Tomcat时，在其字母周围一定不要存在空格，否则最后可能导致配置不成功）<br>
同样，在系统变量里点新建：<br>
变量名：CATALINA_BASE<br>
变量值：C:\Program Files\Apache Software Foundation\Tomcat 8.0;<br>
再次新建：<br>
变量名：CATALINA_HOME<br>
变量值：C:\Program Files\Apache Software Foundation\Tomcat 8.0;<br>
点击确定后在classpath中加入%CATALINA_HOME%\common\lib\servlet-api.jar;（注意加的时候在原变量值后加英文状态下的“；”）<br>
在path中加入%CATALINA_HOME%\bin;（注意加的时候在原变量值后加英文状态下的“；”）<br>
确定后你的Tomcat就配置好了，同样要验证是否配置成功，那就运行Tomcat,点击启动（或Start service）后，打开浏览器，敲入<a href="http://localhost:8080/">http://localhost:8080</a>,如果出现页面，那么配置成功。</p>
]]></content>
    </entry>
</feed>